# 704.二分查找

```java
class Solution {
    // 二分查找算法
    public int search(int[] nums, int target) {
        // 定义左指针初始位置为数组第一个元素的索引
        int left = 0;
        // 定义右指针初始位置为数组最后一个元素的索引
        int right = nums.length - 1;
        // 当左指针小于等于右指针时，进行循环查找
        while(left <= right){
            // 计算中间元素的索引
            int mid = (left + right) / 2;
            // 如果中间元素等于目标值，则返回中间元素的索引
            if (nums[mid] == target)
                return mid;
            // 如果中间元素大于目标值，则将右指针移动到中间元素的左侧
            else if (nums[mid] > target)
                right = mid - 1;
            // 如果中间元素小于目标值，则将左指针移动到中间元素的右侧
            else
                left = mid + 1;
        }
        // 若未找到目标值，则返回-1
        return -1;
    }
}
```

# 27.移除元素

```java
// 定义一个名为Solution的类
class Solution {
    // 定义一个名为removeElement的方法，接收一个整型数组nums和一个整数val作为参数，返回一个整数
    public int removeElement(int[] nums, int val) {
        // 初始化一个变量k，用于记录不等于val的元素个数
        int k = 0;
        // 遍历整型数组nums
        for (int i = 0; i < nums.length; i++){
            // 如果当前元素不等于val
            if (nums[i] != val){
                // 将当前元素移动到数组的前面，并更新k
                nums[k++] = nums[i];
            }
        }
        // 返回不等于val的元素个数
        return k;
    }
}
```

# 977.有序数组的平方

```java
class Solution {
    // 定义一个方法，参数为一个整型数组，返回一个整型数组
    public int[] sortedSquares(int[] nums) {
        // 创建一个与输入数组长度相同的新数组
        int[] res = new int[nums.length];
        // 定义左指针初始值为0
        int left = 0;
        // 定义右指针初始值为数组长度减1
        int right = nums.length - 1;
        // 定义索引初始值为右指针
        int index = right;
        // 当左指针小于等于右指针时循环
        while (left <= right) {
            // 如果左指针指向的元素平方大于右指针指向的元素平方
            if (nums[left] * nums[left] > nums[right] * nums[right]) {
                // 将左指针指向的元素平方放入结果数组中，索引递减，左指针右移
                res[index--] = nums[left] * nums[left];
                left++;
            } else {
                // 否则将右指针指向的元素平方放入结果数组中，索引递减，右指针左移
                res[index--] = nums[right] * nums[right];
                right--;
            }
        }
        // 返回结果数组
        return res;
    }
}
```

# 209.长度最小的子数组

```java
class Solution {
    // 计算长度最小的子数组
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0; // 定义左指针
        int res = Integer.MAX_VALUE; // 初始化结果为整型最大值
        int sum = 0; // 初始化和为0
        for (int right = 0; right < nums.length; right++) { // 遍历数组
            sum += nums[right]; // 累加当前元素到和中
            while (sum >= target) { // 当和大于等于目标值时
                res = Math.min(res, right - left + 1); // 更新结果为当前子数组的长度与之前结果的较小值
                sum -= nums[left++]; // 左指针右移，减去左边元素的值
            }
        }
        return res == Integer.MAX_VALUE ? 0 : res; // 返回结果，如果结果仍为初始值则返回0
    }
}
```

# 59.螺旋矩阵II

```java
class Solution {
    // 生成一个螺旋矩阵
    public int[][] generateMatrix(int n) {
        int [][] res = new int[n][n]; // 创建一个n*n的二维数组用于存储螺旋矩阵
        int loop = 0; // 循环次数
        int start = 0; // 起始位置
        int i, j; // 循环变量i和j
        int num = 1; // 从1开始填充螺旋矩阵的数字

        // 按照顺时针螺旋的顺序填充矩阵
        while(loop++ < n / 2) {
            for (j = start; j < n - loop; j++) {
                res[start][j] = num++; // 从左到右填充数字
            }
            for (i = start; i < n - loop; i++) {
                res[i][j] = num++; // 从上到下填充数字
            }
            for (; j >= loop; j--) {
                res[i][j] = num++; // 从右到左填充数字
            }
            for (; i >= loop; i--) {
                res[i][j] = num++; // 从下到上填充数字
            }
            start++;
        }

        // 处理矩阵为奇数阶时最后一个中心位置的数字
        if (n % 2 == 1) {
            res[start][start] = num;
        }

        return res; // 返回生成的螺旋矩阵
    }
}
```

# 203.移除链表元素

```java
// 定义一个Solution类
class Solution {
    // 定义一个方法，用于移除链表中指定元素
    public ListNode removeElements(ListNode head, int val) {
        // 如果链表为空，直接返回null
        if(head == null)
            return null;
        // 创建一个虚拟头节点，并将其指向链表的头节点
        ListNode dummyHead = new ListNode();
        dummyHead.next = head;
        // 创建一个指针cur指向虚拟头节点
        ListNode cur = dummyHead;
        // 遍历链表
        while(cur.next != null){
            // 如果当前节点的下一个节点的值等于要删除的值val，则将当前节点的next指针指向下下个节点，相当于删除当前节点
            if (cur.next.val == val)
                cur.next = cur.next.next;
            else
                cur = cur.next; // 否则移动cur指针到下一个节点
        }
        // 返回虚拟头节点的下一个节点，即为处理后的链表
        return dummyHead.next;
    }
}
```

# 707.设计链表

```java
// 定义一个链表类
class MyLinkedList {

    int size; // 链表的大小
    ListNode head; // 链表的头节点

    // 构造方法，初始化链表的大小为0，头节点的值为0
    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }
    
    // 获取指定索引处节点的值
    public int get(int index) {
        if(index < 0 || index >= size) // 如果索引小于0或者大于等于链表大小，返回-1
            return -1;
        ListNode cur = head; // 从头节点开始遍历
        for (int i = 0; i <= index; i++){ // 遍历找到指定索引处的节点
            cur = cur.next;
        }
        return cur.val; // 返回指定节点的值
    }
    
    // 在链表头部添加节点
    public void addAtHead(int val) {
        addAtIndex(0, val); // 调用在指定索引处添加节点的方法，在头部添加节点
    }
    
    // 在链表尾部添加节点
    public void addAtTail(int val) {
        addAtIndex(size, val); // 调用在指定索引处添加节点的方法，在尾部添加节点
    }
    
    // 在指定索引处添加节点
    public void addAtIndex(int index, int val) {
        if(index > size) // 如果索引大于链表大小，直接返回
            return;
        if(index < 0) // 如果索引小于0，将索引设为0
            index = 0;
        size++; // 链表大小加1
        ListNode cur = head; // 从头节点开始遍历
        for (int i = 0; i < index; i++){ // 遍历找到指定索引处的节点的前一个节点
            cur = cur.next;
        }
        ListNode newNode = new ListNode(val); // 创建新节点
        newNode.next = cur.next; // 新节点指向原索引处的节点
        cur.next = newNode; // 前一个节点指向新节点
    }
    
    // 删除指定索引处的节点
    public void deleteAtIndex(int index) {
        if(index < 0 || index >= size) // 如果索引小于0或者大于等于链表大小，直接返回
            return;
        ListNode cur = head; // 从头节点开始遍历
        for (int i = 0; i < index; i++){ // 遍历找到指定索引处的节点的前一个节点
            cur = cur.next;
        }
        cur.next = cur.next.next; // 前一个节点指向下下个节点，即删除指定索引处的节点
        size--; // 链表大小减1
    }
}
```

# 206.反转链表

```java
class Solution {
    // 定义一个方法，用于反转链表
    public ListNode reverseList(ListNode head) {
        // 定义三个指针变量
        ListNode temp;
        ListNode pre = null; // pre指向前一个节点
        ListNode cur = head; // cur指向当前节点
        // 遍历链表
        while(cur != null) {
            temp = cur.next; // 临时保存下一个节点
            cur.next = pre; // 当前节点指向前一个节点
            pre = cur; // pre指向当前节点
            cur = temp; // cur指向下一个节点
        }
        return pre; // 返回反转后的链表头节点
    }
}
```

# 24.两两交换链表中的节点

```java
// 定义一个Solution类
class Solution {
    // 定义一个公共方法swapPairs，用于两两交换链表中的节点
    public ListNode swapPairs(ListNode head) {
        // 创建一个虚拟头节点dummyHead，并将其指向头节点head
        ListNode dummyHead =  new ListNode(0);
        dummyHead.next = head;
        // 创建一个指针cur指向dummyHead
        ListNode cur = dummyHead;
        // 当cur的下一个节点和下下个节点都不为空时，进行节点交换操作
        while (cur.next != null && cur.next.next != null) {
            // 临时保存cur的下一个节点
            ListNode temp = cur.next;
            // 将cur的下一个节点指向下下个节点
            cur.next = cur.next.next;
            // 将temp的下一个节点指向下下个节点的下一个节点
            temp.next = cur.next.next;
            // 将cur的下下个节点指向temp，完成节点交换
            cur.next.next = temp;
            // 将cur指向temp，准备进行下一轮节点交换
            cur = temp;
        }
        // 返回虚拟头节点的下一个节点作为交换后的链表头
        return dummyHead.next;
    }
}
```

# 19.删除链表倒数第N个节点

```java
class Solution {
    // 定义一个方法，用于删除链表的倒数第 N 个结点
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 创建一个虚拟头结点，并将其指向头结点
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        // 初始化快指针和慢指针都指向虚拟头结点
        ListNode fast = dummyHead;
        ListNode slow = dummyHead;
        // 快指针先移动 n 步
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }
        // 快指针和慢指针一起向后移动，直到快指针到达链表末尾
        while(fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        // 删除倒数第 N 个结点
        slow.next = slow.next.next;
        // 返回虚拟头结点的下一个结点，即删除倒数第 N 个结点后的链表头结点
        return dummyHead.next;
    }
}
```

# 160.相交链表

```java
public class Solution {
    // 获取两个链表的相交节点
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int countA = 0; // 记录链表A的长度
        int countB = 0; // 记录链表B的长度
        ListNode tempA = headA; // 临时节点指向链表A的头节点
        ListNode tempB = headB; // 临时节点指向链表B的头节点
        
        // 计算链表A的长度
        while(tempA != null) {
            countA++;
            tempA = tempA.next;
        }
        
        // 计算链表B的长度
        while (tempB != null){
            countB++;
            tempB = tempB.next;
        }
        
        // 将较长的链表向后移动，使两个链表剩余部分长度相等
        if(countA > countB){
            for (int i = 0; i < countA - countB; i++){
                headA = headA.next;
            }
        }else {
            for (int i = 0; i < countB - countA; i++){
                headB = headB.next;
            }
        }
        
        // 同时遍历两个链表，直到找到相交节点
        while (headA != headB){
            headA = headA.next;
            headB = headB.next;
        }
        
        return headA; // 返回相交节点
    }
}
```

# 142.环形链表

```java
public class Solution {
    // 寻找环形链表的入口节点
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;  // 快指针，每次移动两步
        ListNode slow = head;  // 慢指针，每次移动一步
        while(fast != null && fast.next != null) {  // 当快指针和快指针的下一个节点都不为空时循环
            fast = fast.next.next;  // 快指针移动两步
            slow = slow.next;  // 慢指针移动一步
            if(fast == slow){  // 当快指针追上慢指针，表示存在环
                ListNode temp = fast;  // 临时节点指向快指针
                while(head != temp){  // 循环直到临时节点等于头节点
                    head = head.next;  // 头节点和临时节点同时移动，直到相遇
                    temp = temp.next;
                }
                return temp;  // 返回环的入口节点
            }
        }
        return null;  // 没有环，返回null
    }
}
```

# 242.有效的字母异位词

```java
class Solution {
    // 判断两个字符串是否为有效的字母异位词
    public boolean isAnagram(String s, String t) {
        // 如果两个字符串长度不相等，则不可能是字母异位词
        if(s.length() != t.length())
            return false;
        
        // 用于记录每个字母出现的次数的哈希表，26个字母对应26个位置
        int [] hash = new int[26];
        
        // 遍历字符串s，统计每个字母出现的次数
        for (int i = 0; i < s.length(); i++){
            hash[s.charAt(i) - 'a']++;
        }
        
        // 遍历字符串t，将哈希表中对应位置的字母次数减一
        for (int i = 0; i <  t.length(); i++){
            hash[t.charAt(i) - 'a']--;
        }
        
        // 检查哈希表中每个位置的值，如果不为0，则不是字母异位词
        for (int i = 0; i < hash.length; i++){
            if(hash[i] != 0)
                return false;
        }
        
        // 若所有位置的值都为0，则是字母异位词
        return true;
    }
}
```

# 349.两个数组的交集

```java
class Solution {
    // 创建一个Solution类
    public int[] intersection(int[] nums1, int[] nums2) {
        // 定义一个方法，参数为两个整型数组，返回一个整型数组
        HashSet<Integer> set = new HashSet();
        // 创建一个HashSet集合set，用于存储nums1数组中的元素
        HashSet<Integer> set1 = new HashSet();
        // 创建一个HashSet集合set1，用于存储nums2数组中的元素
        ArrayList<Integer> list = new ArrayList();
        // 创建一个ArrayList集合list，用于存储两个数组的交集元素
        for(int i = 0; i < nums1.length; i++){
            // 遍历nums1数组
            set.add(nums1[i]);
            // 将nums1数组中的元素添加到set集合中
        }
        for(int i = 0; i < nums2.length; i++){
            // 遍历nums2数组
            set1.add(nums2[i]);
            // 将nums2数组中的元素添加到set1集合中
        }
        for (Integer num : set){
            // 遍历set集合中的元素
            if(set1.contains(num))
                // 如果set1集合中包含当前元素
                list.add(num);
                // 将当前元素添加到list集合中
        }
        return list
            .stream()
            .mapToInt(Integer::intValue).
            toArray();
            // 将list集合转换为流，再映射为int类型，最后转换为数组并返回
    }
}
```

# 202.快乐数

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**示例 2：**

```
输入：n = 2
输出：false
```

```java
/**
 * 判断一个数是否为快乐数
 */
class Solution {
    /**
     * 判断一个数是否为快乐数
     * @param n 给定的整数
     * @return 如果是快乐数，返回true；否则返回false
     */
    public boolean isHappy(int n) {
        // 使用Set集合存储已经出现过的数，用于判断是否进入循环
        Set<Integer> set = new HashSet<>();
        while (n != 1 && !set.contains(n)) {
 			set.add(n); // 将当前数加入集合
 		n = getNext(n); // 获取下一个数
        }
        return n == 1; // 判断最终的数是否为1，是则为快乐数，否则不是
    }

    /**
     * 计算下一个数
     * @param n 当前数
     * @return 下一个数
     */
    private int getNext(int n) {
        int sum = 0;
        while (n > 0) {
 int temp = n % 10; // 取当前数的个位数
 sum += temp * temp; // 将个位数的平方累加到sum中
 n = n / 10; // 去掉个位数
        }
        return sum; // 返回下一个数
    }
}
```

# 1.两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

```java
/**
 * 两数之和
 */
class Solution {
    /**
     * 寻找数组中两个数之和等于目标值的索引
     * @param nums 给定的整数数组
     * @param target 目标值
     * @return 包含两个数索引的数组
     */
    public int[] twoSum(int[] nums, int target) {
        // 用于存储数组元素及其对应索引的哈希表
        Map<Integer, Integer> map = new HashMap<>();
        // 用于存储符合条件的数的索引
        List<Integer> list = new ArrayList<>();
        // 遍历数组
        for (int i = 0; i < nums.length; i++) {
            // 如果哈希表中存在目标值与当前元素之差，则找到符合条件的两个数
            if (map.containsKey(target - nums[i])) {
                list.add(map.get(target - nums[i])); // 添加第一个数的索引
                list.add(i); // 添加第二个数的索引
                break; // 找到即可退出循环
            }
            // 将当前元素及其索引加入哈希表
            map.put(nums[i], i);
        }
        // 将符合条件的两个数的索引存入结果数组
        int[] res = new int[2];
        res[0] = list.get(0);
        res[1] = list.get(1);
        return res;
    }
}
```

# 454.四数相加II

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

**示例 1：**

```
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

```java
class Solution {
    // 计算四个数组中的数两两相加等于0的组合数
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        // 使用HashMap存储两个数组中数的和以及出现的次数
        Map<Integer, Integer> map = new HashMap<>();
        int count = 0;
        // 遍历nums1和nums2数组，将两数之和存入map中
        for (int i = 0; i < nums1.length; i++) {
            for (int j = 0; j < nums2.length; j++) {
                int sum = nums1[i] + nums2[j];
                if (map.containsKey(sum)) {
                    map.put(sum, map.get(sum) + 1);
                } else {
                    map.put(sum, 1);
                }
            }
        }
        // 遍历nums3和nums4数组，查找与其和为0的组合数
        for (int i = 0; i < nums3.length; i++) {
            for (int j = 0; j < nums4.length; j++){
                int sum = nums3[i] + nums4[j];
                if (map.containsKey(-sum)) {
                    count += map.get(-sum);
                }
            }
        }
        // 返回符合条件的组合数
        return count;
    }
}
```

# 383.赎金信

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

**示例 1：**

```
输入：ransomNote = "a", magazine = "b"
输出：false
```

**示例 2：**

```
输入：ransomNote = "aa", magazine = "ab"
输出：false
```

**示例 3：**

```
输入：ransomNote = "aa", magazine = "aab"
输出：true
```

```java
class Solution {
    // 判断是否能用magazine中的字符组成ransomNote
    public boolean canConstruct(String ransomNote, String magazine) {
        // 用于记录magazine中每个字符的出现次数
        int [] hash = new int[26];
        // 统计magazine中每个字符的出现次数
        for (int i = 0; i < magazine.length(); i++) {
            hash[magazine.charAt(i) - 'a']++;
        }
        // 遍历ransomNote，逐个减少hash中对应字符的出现次数，若出现次数小于0则返回false
        for (int i = 0; i < ransomNote.length(); i++) {
            hash[ransomNote.charAt(i) - 'a']--;
            if (hash[ransomNote.charAt(i) - 'a'] < 0) {
                return false;
            }
        }
        // 若遍历完ransomNote后仍未出现出现次数小于0的情况，则返回true
        return true;
    }
}
```

# 15.三数之和

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

```java
/**
 * 三数之和
 */
class Solution {
    /**
     * 寻找数组中三个数之和为0的组合
     * @param nums 给定的整数数组
     * @return 返回所有满足条件的组合
     */
    public List<List<Integer>> threeSum(int[] nums) {
        List <List<Integer>> res = new ArrayList<>(); // 用于存储结果的列表
        Arrays.sort(nums); // 对数组进行排序
        for (int i = 0; i < nums.length - 2; i++){ // 遍历数组
            if (i > 0 && nums[i] == nums[i - 1]) // 如果当前数与前一个数相同，则跳过
                continue;
            int left = i + 1; // 左指针
            int right = nums.length - 1; // 右指针
            while (left < right){ // 循环直到左指针大于等于右指针
                if(nums[i] + nums[left] + nums[right] == 0){ // 如果找到三个数之和为0的组合
                    List <Integer> list = new ArrayList<>(); // 创建一个新的列表
                    list.add(nums[i]); // 将三个数添加到列表中
                    list.add(nums[left]);
                    list.add(nums[right]);
                    res.add(list); // 将列表添加到结果中
                    left++; // 移动左指针
                    right--; // 移动右指针
                    while(left < right && nums[left] == nums[left - 1]) // 跳过重复的左指针
                        left++;
                    while(left < right && nums[right] == nums[right + 1]) // 跳过重复的右指针
                        right--;
                } else if (nums[i] + nums[left] + nums[right] > 0) { // 如果三数之和大于0
                    right--; // 移动右指针
                }else // 如果三数之和小于0
                    left++; // 移动左指针
            }
        }
        return res; // 返回结果列表
    }
}
```

# 18.四数之和

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**示例 2：**

```
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

```java
/**
 * 四数之和
 */
class Solution {
    /**
     * 寻找数组中四个数的和等于目标值的组合
     * @param nums 给定的整数数组
     * @param target 目标值
     * @return 返回所有满足条件的四个数的组合
     */
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List <List<Integer>> res = new ArrayList<>(); // 用于存储结果的列表
        Arrays.sort(nums); // 对数组进行排序
        for (int i = 0; i < nums.length - 3; i++) { // 遍历数组
            if (nums[i] > target && nums[i] >= 0) // 如果当前数大于目标值且大于等于0，则直接返回结果
                return res;
            if(i > 0 && nums[i] == nums[i - 1]) // 如果当前数与前一个数相同，则跳过当前循环
                continue;
            for (int j = i + 1; j < nums.length - 2; j++) { // 再次遍历数组
                if(j > i + 1 && nums[j] == nums[j - 1]) // 如果当前数与前一个数相同，则跳过当前循环
                    continue;
                int left = j + 1; // 左指针
                int right = nums.length - 1; // 右指针
                while (left < right) { // 循环直到左指针大于等于右指针
                    int sum = nums[i] + nums[j] + nums[left] + nums[right]; // 计算四个数的和
                    if (sum == target) { // 如果和等于目标值
                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); // 将满足条件的四个数加入结果列表
                        left++; // 左指针右移
                        right--; // 右指针左移
                        while (left < right && nums[left] == nums[left - 1]) // 跳过重复的左指针值
                            left++;
                        while (left < right && nums[right] == nums[right + 1]) // 跳过重复的右指针值
                            right--;
                    } else if (sum < target) // 如果和小于目标值
                        left++; // 左指针右移
                    else // 如果和大于目标值
                        right--; // 右指针左移
                }
            }
        }
        return res; // 返回结果列表
    }
}
```

# 344.反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

**示例 1：**

```
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

```java
// 定义一个名为Solution的类
class Solution {
    // 定义一个名为reverseString的公共方法，参数为字符数组s
    public void reverseString(char[] s) {
        // 定义整型变量left并赋值为0
        int left = 0;
        // 定义整型变量right并赋值为s的长度减1
        int right = s.length - 1;
        // 当left小于right时执行循环
        while(left < right) {
            // 定义字符型变量temp并赋值为s[left]
            char temp = s[left];
            // 将s[left]赋值为s[right]
            s[left] = s[right];
            // 将s[right]赋值为temp
            s[right] = temp;
            // left自增1
            left++;
            // right自减1
            right--;
        }
    }
}
```

# 541.反转字符串II

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

**示例 2：**

```
输入：s = "abcd", k = 2
输出："bacd"
```

```java
class Solution {
    // 反转字符串的一部分，每2k个字符反转前k个字符
    public String reverseStr(String s, int k) {
        char[] ch = s.toCharArray();
        for(int i = 0;i < ch.length;i += 2 * k){
            int start = i;
            // 判断尾数够不够k个来取决end指针的位置
            int end = Math.min(ch.length - 1,start + k - 1);
            reverseString(ch,start,end); // 调用反转字符串的方法
        }
        return new String(ch);
    }

    // 反转字符数组s中从l到r的部分
    public void reverseString(char[] s, int l, int r) {
        int left = l;
        int right = r;
        while(left < right) {
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
}
```

# 151.翻转字符串里的单词

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

**示例 1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

```java
/**
 * 反转字符串中的单词
 */
class Solution {
    /**
     * 反转字符串中的单词
     * @param s 给定的字符串
     * @return 反转后的字符串
     */
    public String reverseWords(String s) {
        char[] chars = s.toCharArray(); // 将字符串转换为字符数组
        reverseString(chars, 0, chars.length - 1); // 反转整个字符串
        for(int lfet = 0, right = 0; right < chars.length; right++, lfet = right){
            while (right< chars.length && chars[right] != ' ') // 找到单词的末尾
                right++;
            reverseString(chars, lfet, right - 1); // 反转单词
        }
        return new String(chars); // 返回反转后的字符串
    }
    /**
     * 反转字符数组中指定范围的字符
     * @param s 给定的字符数组
     * @param l 范围左边界
     * @param r 范围右边界
     */
    public void reverseString(char[] s, int l, int r) {
        int left = l;
        int right = r;
        while(left < right) {
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
}
```

# 28.找出字符串中第一个匹配项的下标

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

**示例 1：**

```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

**示例 2：**

```
输入：haystack = "leetcode", needle = "leeto"
输出：-1
解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
```

```java
class Solution {
    // 实现字符串匹配算法，返回匹配项的下标
    public int strStr(String haystack, String needle) {
        // 如果needle为空字符串，则返回0
        if (needle.length() == 0) {
            return 0;
        }
        // 获取needle的next数组
        int[] next = getNext(needle);
        int j = 0;
        // 遍历haystack字符串
        for (int i = 0; i < haystack.length(); i++) {
            // 当j大于0，且haystack字符串的第i个字符不等于needle字符串的第j个字符时，j回退到next数组中对应的值
            while (j > 0 && haystack.charAt(i) != needle.charAt(j)) {
                j = next[j - 1];
            }
            // 当haystack字符串的第i个字符等于needle字符串的第j个字符时，j自增
            if (haystack.charAt(i) == needle.charAt(j)) {
                j++;
            }
            // 当j等于needle字符串的长度时，返回i-needle字符串的长度+1
            if (j == needle.length()) {
                return i - needle.length() + 1;
            }
        }
        // 如果没有匹配到，返回-1
        return -1;
    }

    // 获取字符串的next数组
    private int[] getNext(String needle) {
        int[] next = new int[needle.length()];
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < needle.length(); i++) {
            while (j > 0 && needle.charAt(i) != needle.charAt(j)) {
                j = next[j - 1];
            }
            if (needle.charAt(i) == needle.charAt(j))
                j++;
            next[i] = j;
        }
        return next;
    }
}
```

# 459.重复的子字符串

给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。

**示例 1:**

```
输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
```

**示例 2:**

```
输入: s = "aba"
输出: false
```

```java
// 定义一个Solution类
class Solution {
    // 定义一个repeatedSubstringPattern方法，用于判断字符串s是否由重复的子字符串构成
    public boolean repeatedSubstringPattern(String s) {
        // 将字符串s拼接自身，得到一个新的字符串str
        String str =  s + s;
        // 判断去掉首尾字符后的str是否包含原始字符串s，若包含则返回true，否则返回false
        return str.substring(1,str.length()-1).contains(s);
    }
}
```

# 232.用栈实现队列

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

```java
// 用栈实现队列的Java代码
class MyQueue {
    private Stack<Integer> stack1;  // 声明私有栈1
    private Stack<Integer> stack2;  // 声明私有栈2

    public MyQueue() {
        stack1 = new Stack<>();  // 初始化栈1
        stack2 = new Stack<>();  // 初始化栈2
    }

    public void push(int x) {
        stack1.push(x);  // 将元素压入栈1
    }

    public int pop() {
        if (stack2.isEmpty()) {  // 如果栈2为空
            while (!stack1.isEmpty()) {  // 当栈1不为空时
                stack2.push(stack1.pop());  // 将栈1的元素逐个弹出并压入栈2
            }
        }
        return stack2.pop();  // 弹出栈2的顶部元素
    }

    public int peek() {
        if (stack2.isEmpty()) {  // 如果栈2为空
            while (!stack1.isEmpty()) {  // 当栈1不为空时
                stack2.push(stack1.pop());  // 将栈1的元素逐个弹出并压入栈2
            }
        }
        return stack2.peek();  // 返回栈2的顶部元素
    }

    public boolean empty() {
        return stack1.isEmpty() && stack2.isEmpty();  // 判断栈1和栈2是否都为空
    }
}
```

# 225.用队列实现栈

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

```java
// 用队列实现栈
class MyStack {
    Queue<Integer> queue; // 定义一个整型队列
    public MyStack() {
        queue = new LinkedList<>(); // 初始化队列
    }

    public void push(int x) {
        int n = queue.size(); // 获取当前队列的大小
        queue.offer(x); // 将元素入队
        for (int i = 0; i < n; i++) {
            queue.offer(queue.poll()); // 将队列中的元素重新按照栈的顺序排列
        }
    }

    public int pop() {
        return queue.poll(); // 弹出栈顶元素
    }

    public int top() {
        return queue.peek(); // 获取栈顶元素
    }

    public boolean empty() {
        return queue.isEmpty(); // 判断栈是否为空
    }
}
```

# 20.有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

```java
/**
 * 判断括号字符串是否有效的解决方案类
 */
class Solution {
    /**
     * 判断输入的括号字符串是否有效
     * @param s 输入的括号字符串
     * @return 如果括号字符串有效则返回true，否则返回false
     */
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>(); // 使用栈来存储括号字符
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '[') { // 如果是左括号则入栈
                stack.push(c);
            } else if (stack.isEmpty()) { // 如果是右括号且栈为空，则无法匹配，返回false
                return false;
            } else if (c == ')' && stack.peek() == '('){ // 如果是右括号且与栈顶元素匹配，则出栈
                stack.pop();
            } else if (c == '}' && stack.peek() == '{'){
                stack.pop();
            } else if (c == ']' && stack.peek() == '['){
                stack.pop();
            } else // 其他情况均为无效的括号组合，返回false
                return false;
        }
        return stack.isEmpty(); // 最终判断栈是否为空，为空则表示所有括号都匹配，返回true，否则返回false
    }
}
```

# 1047.删除字符串中的所有相邻重复项

给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**示例：**

```
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

```java
class Solution {
    // 使用栈来删除字符串中的所有相邻重复项
    public String removeDuplicates(String s) {
        Stack<Character> stack = new Stack<>();  // 创建一个字符类型的栈
        for (int i = 0; i < s.length(); i++) {  // 遍历字符串
            char c = s.charAt(i);  // 获取字符串中的字符
            if (stack.isEmpty()) {  // 如果栈为空
                stack.push(c);  // 将字符入栈
            } else {
                if (stack.peek() == c) {  // 如果栈顶字符与当前字符相同
                    stack.pop();  // 弹出栈顶字符
                } else {
                    stack.push(c);  // 将当前字符入栈
                }
            }
        }
        StringBuilder sb = new StringBuilder();  // 创建一个字符串构建器
        while (!stack.isEmpty()) {  // 当栈不为空时
            sb.append(stack.pop());  // 将栈顶字符添加到字符串构建器
        }
        return sb.reverse().toString();  // 返回字符串构建器中的字符的逆序
    }
}
```

# 150.逆波兰表达式求值

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

**示例 1：**

```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

```java
// 逆波兰表达式求值
class Solution {
    // 定义方法，接收逆波兰表达式数组，返回计算结果
    public int evalRPN(String[] tokens) {
        // 创建整型栈
        Stack<Integer> stack = new Stack<>();
        // 遍历表达式数组
        for (String token : tokens) {
            // 如果是加号
            if ("+".equals(token)) {
                // 出栈两个数相加后入栈
                int num1 = stack.pop();
                int num2 = stack.pop();
                stack.push(num2 + num1);
            } 
            // 如果是减号
            else if ("-".equals(token)) {
                // 出栈两个数相减后入栈
                int num1 = stack.pop();
                int num2 = stack.pop();
                stack.push(num2 - num1);
            } 
            // 如果是乘号
            else if ("*".equals(token)) {
                // 出栈两个数相乘后入栈
                int num1 = stack.pop();
                int num2 = stack.pop();
                stack.push(num2 * num1);
            } 
            // 如果是除号
            else if ("/".equals(token)) {
                // 出栈两个数相除后入栈
                int num1 = stack.pop();
                int num2 = stack.pop();
                stack.push(num2 / num1);
            } 
            // 如果是数字
            else
                // 将数字入栈
                stack.push(Integer.parseInt(token));
        }
        // 返回栈顶元素，即为计算结果
        return stack.pop();
    }
}
```

# 239.滑动窗口最大值

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

```java
// 滑动窗口最大值解决方案类
class Solution {
    // 返回滑动窗口最大值数组
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 如果数组长度为1，直接返回原数组
        if (nums.length == 1) {
            return nums;
        }
        // 初始化结果数组
        int[] res = new int[nums.length - k + 1];
        // 创建自定义队列对象
        MyQueue queue = new MyQueue();
        int index = 0;
        // 遍历前k个元素，将其加入队列
        for (int i = 0; i < k; i++){
            queue.push(nums[i]);
        }
        // 将队列中的最大值加入结果数组
        res[index++] = queue.peek();
        // 遍历剩余元素
        for (int i = k; i < nums.length; i++){
            // 弹出窗口最左侧元素，加入窗口最右侧元素，将队列中的最大值加入结果数组
            queue.pop(nums[i - k]);
            queue.push(nums[i]);
            res[index++] = queue.peek();
        }
        return res;
    }
}

// 自定义队列类
class MyQueue{
    // 使用双端队列实现
    Deque<Integer> q = new LinkedList<>();

    // 将元素加入队列，保持队列单调递减
    public void push(int val) {
        while (!q.isEmpty() && q.peekLast() < val){
            q.pollLast();
        }
        q.addLast(val);
    }

    // 弹出指定元素
    public void pop(int val) {
        if (!q.isEmpty() && q.peek() == val){
            q.poll();
        }
    }

    // 返回队列中的最大值
    public int peek() {
        return q.peek();
    }
}
```

# 347.前k个高频元素

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        //遍历nums数组，将每个元素和出现次数存入map中
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        //将map中的元素存入list中
        List<Map.Entry<Integer, Integer>> list = new ArrayList<>(map.entrySet());
        //对list进行排序，按照value值降序排列
        list.sort((o1, o2) -> o2.getValue() - o1.getValue());
        //定义一个长度为k的数组，用于存放结果
        int[] res = new int[k];
        //遍历list，将前k个元素存入res中
        for (int i = 0; i < k; i++) {
            res[i] = list.get(i).getKey();
        }
        //返回结果
        return res;
    }
}
```

# 144.二叉树的前序遍历

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**示例 1：**

![image-20240625111913951](C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240625111913951.png)

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

**示例 2：**

```
输入：root = []
输出：[]
```

```java
/**
 * 二叉树的前序遍历
 */
class Solution {
    /**
     * 前序遍历二叉树
     * @param root 二叉树的根节点
     * @return 前序遍历结果列表
     */
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>(); // 用于存储前序遍历结果的列表
        if (root == null) {
            return ans; // 若根节点为空，则直接返回空列表
        }
        Stack<TreeNode> stack = new Stack<>(); // 用于辅助遍历的栈
        stack.push(root); // 将根节点压入栈中
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop(); // 弹出栈顶节点
            ans.add(node.val); // 将节点值加入到结果列表中
            if (node.right != null) {
                stack.push(node.right); // 若右子节点不为空，则将右子节点压入栈中
            }
            if (node.left != null) {
                stack.push(node.left); // 若左子节点不为空，则将左子节点压入栈中
            }
        }
        return ans; // 返回前序遍历结果列表
    }
}
```

# 145.二叉树的后序遍历

```java
// 定义一个Solution类
class Solution {
    // 定义一个公共方法，用于后序遍历二叉树
    public List<Integer> postorderTraversal(TreeNode root) {
        // 创建一个存放结果的列表
        List<Integer> ans = new ArrayList<>();
        // 调用dfs方法进行后序遍历
        dfs(root, ans);
        // 返回结果列表
        return ans;
    }

    // 定义一个私有方法，用于递归遍历二叉树节点并将结果存入列表
    private void dfs(TreeNode root, List<Integer> ans) {
        // 如果当前节点为空，直接返回
        if (root == null) {
            return;
        }
        // 递归遍历左子树
        dfs(root.left, ans);
        // 递归遍历右子树
        dfs(root.right, ans);
        // 将当前节点的值加入结果列表
        ans.add(root.val);
    }
}
```

# 94.二叉树的中序遍历

```java
// 二叉树的中序遍历
class Solution {
    // 中序遍历函数
    public List<Integer> inorderTraversal(TreeNode root) {
        // 用于存储中序遍历结果的列表
        List<Integer> res = new ArrayList<>();
        // 用于辅助遍历的栈
        Deque<TreeNode> stack = new LinkedList<>();
        // 当前节点指针
        TreeNode cur = root;
        // 进行中序遍历
        while (cur != null || !stack.isEmpty()) {
            // 将当前节点及其左子节点入栈
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            // 弹出栈顶节点，将其值加入结果列表
            cur = stack.pop();
            res.add(cur.val);
            // 将指针指向当前节点的右子节点
            cur = cur.right;
        }
        // 返回中序遍历结果
        return res;
    }
}
```

# 102.二叉树的层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![image-20240625112827066](C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240625112827066.png)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

```java
/**
 * 二叉树的层序遍历
 */
class Solution {
    /**
     * 层序遍历二叉树
     * @param root 二叉树的根节点
     * @return 返回二叉树层序遍历的结果
     */
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>(); // 创建一个队列用于层序遍历
        List<List<Integer>> res = new ArrayList<>(); // 用于存储层序遍历的结果
        if (root == null) {
            return res; // 如果根节点为空，直接返回空结果
        }
        queue.add(root); // 将根节点加入队列
        while (!queue.isEmpty()) {
            int size = queue.size(); // 获取当前层的节点个数
            List<Integer> list = new ArrayList<>(); // 用于存储当前层的节点值
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll(); // 从队列中取出节点
                list.add(node.val); // 将节点值加入当前层的列表
                if (node.left != null) {
                    queue.add(node.left); // 将左子节点加入队列
                }
                if (node.right != null) {
                    queue.add(node.right); // 将右子节点加入队列
                }
            }
            res.add(list); // 将当前层的节点值列表加入结果列表
        }
        return res; // 返回层序遍历的结果
    }
}
```

# 107.二叉树的层次遍历

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203151058308.png" alt="107.二叉树的层次遍历II" style="zoom:50%;" />

```java
class Solution {
    // 二叉树的层序遍历 II
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        // 创建一个队列用于层序遍历
        Queue<TreeNode> queue = new LinkedList<>();
        // 创建一个列表用于存储结果
        List<List<Integer>> res = new ArrayList<>();
        // 如果根节点为空，直接返回空结果列表
        if (root == null) {
            return res;
        }
        // 将根节点加入队列
        queue.add(root);
        // 遍历队列直到为空
        while (!queue.isEmpty()) {
            // 获取当前层的节点数
            int size = queue.size();
            // 创建一个列表用于存储当前层的节点值
            List<Integer> list = new ArrayList<>();
            // 遍历当前层的节点
            for (int i = 0; i < size; i++) {
                // 弹出队首节点
                TreeNode node = queue.poll();
                // 将节点值加入当前层列表
                list.add(node.val);
                // 将左子节点加入队列
                if (node.left != null) {
                    queue.add(node.left);
                }
                // 将右子节点加入队列
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
            // 将当前层列表加入结果列表
            res.add(list);
        }
        // 将结果列表反转
        Collections.reverse(res);
        // 返回结果列表
        return res;
    }
}
```

# 199.二叉树的右视图

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

![199.二叉树的右视图](https://code-thinking-1253855093.file.myqcloud.com/pics/20210203151307377.png)

```java
class Solution {
    // 生成二叉树的右视图
    public List<Integer> rightSideView(TreeNode root) {
        // 创建一个队列用于层序遍历
        Queue<TreeNode> queue = new LinkedList<>();
        // 创建一个列表用于存储右视图的节点值
        List<Integer> list = new ArrayList<>();
        // 如果根节点为空，直接返回空列表
        if (root == null) {
            return list;
        }
        // 将根节点加入队列
        queue.add(root);
        // 层序遍历二叉树
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                // 当遍历到当前层的最后一个节点时，将其值加入到列表中
                if (i == size - 1) {
                    list.add(node.val);
                }
                // 将当前节点的左子节点加入队列
                if (node.left != null) {
                    queue.add(node.left);
                }
                // 将当前节点的右子节点加入队列
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
        }
        // 返回右视图的节点值列表
        return list;
    }
}
```

# 637.二叉树的层平均值

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203151350500.png" alt="637.二叉树的层平均值" style="zoom: 50%;" />

```java
class Solution {
    // 计算二叉树每层节点的平均值
    public List<Double> averageOfLevels(TreeNode root) {
        // 使用队列来进行层次遍历
        Queue<TreeNode> queue = new LinkedList<>();
        // 用于存储每层节点的平均值
        List<Double> list = new ArrayList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            double sum = 0;
            // 遍历当前层的节点
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                sum += node.val;
                // 将当前节点的子节点加入队列
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
            // 计算当前层节点的平均值并加入到结果列表中
            list.add(sum / size);
        }
        // 返回每层节点的平均值列表
        return list;
    }
}
```

# 429. N叉树的层序遍历

给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

例如，给定一个 3叉树 :

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203151439168.png" alt="429. N叉树的层序遍历" style="zoom:50%;" />

返回其层序遍历:

[ [1], [3,2,4], [5,6] ]

```java
/**
 * N 叉树的层序遍历
 */
class Solution {
    /**
     * 层序遍历方法
     * @param root N叉树的根节点
     * @return 返回层序遍历结果
     */
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> res = new ArrayList<>(); // 用于存储层序遍历结果
        if (root == null) {
            return res; // 如果根节点为空，直接返回空结果
        }
        Queue<Node> queue = new LinkedList<>(); // 创建一个队列用于层序遍历
        queue.offer(root); // 将根节点加入队列
        while (!queue.isEmpty()) {
            int size = queue.size(); // 获取当前层的节点个数
            List<Integer> list = new ArrayList<>(); // 用于存储当前层的节点值
            for (int i = 0; i < size; i++) {
                Node node = queue.poll(); // 从队列中取出一个节点
                list.add(node.val); // 将节点值加入当前层的列表中
                for (Node child : node.children) {
                    queue.offer(child); // 将当前节点的子节点加入队列
                }
            }
            res.add(list); // 将当前层的节点值列表加入结果列表
        }
        return res; // 返回层序遍历结果
    }
}
```

# 515.在每个树行中找最大值

您需要在二叉树的每一行中找到最大的值。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203151532153.png" alt="515.在每个树行中找最大值" style="zoom:50%;" />

```java
class Solution {
    // 在每个树行中找到最大值的方法
    public List<Integer> largestValues(TreeNode root) {
        // 用于存储每行最大值的列表
        List<Integer> res = new ArrayList<>();
        // 如果根节点为空，直接返回空列表
        if (root == null) {
            return res;
        }
        // 创建一个队列用于层序遍历
        Queue<TreeNode> queue = new LinkedList<>();
        // 将根节点加入队列
        queue.offer(root);
        // 循环直到队列为空
        while (!queue.isEmpty()) {
            // 获取当前层的节点个数
            int size = queue.size();
            // 初始化当前层的最大值为最小整数值
            int max = Integer.MIN_VALUE;
            // 遍历当前层的节点
            for (int i = 0; i < size; i++) {
                // 弹出队首节点
                TreeNode node = queue.poll();
                // 更新当前层的最大值
                max = Math.max(max, node.val);
                // 将左子节点加入队列
                if (node.left != null) {
                    queue.offer(node.left);
                }
                // 将右子节点加入队列
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            // 将当前层的最大值加入结果列表
            res.add(max);
        }
        // 返回每行最大值的列表
        return res;
    }
}
```

# 116.填充每个节点的下一个右侧节点指针

给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```cpp
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203152044855.jpg" alt="116.填充每个节点的下一个右侧节点指针" style="zoom:50%;" />

```java
/**
 * 填充每个节点的下一个右侧节点指针
 */
class Solution {
    /**
     * 连接每个节点的下一个右侧节点
     * @param root 给定的根节点
     * @return 连接后的根节点
     */
    public Node connect(Node root) {
        Queue<Node> queue = new LinkedList<>(); // 创建一个队列用于层序遍历
        if (root == null) { // 如果根节点为空，则直接返回
            return root;
        }
        queue.offer(root); // 将根节点加入队列
        while (!queue.isEmpty()) { // 当队列不为空时循环
            int size = queue.size(); // 获取当前层的节点数量
            for (int i = 0; i < size; i++) { // 遍历当前层的节点
                Node node = queue.poll(); // 弹出队首节点
                if (i < size - 1) { // 如果不是当前层的最后一个节点
                    node.next = queue.peek(); // 将当前节点的next指向队首节点
                }
                if (node.left != null) { // 如果当前节点有左子节点，则加入队列
                    queue.offer(node.left);
                }
                if (node.right != null) { // 如果当前节点有右子节点，则加入队列
                    queue.offer(node.right);
                }
            }
        }
        return root; // 返回连接后的根节点
    }
}
```

# 104.二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：

给定二叉树 [3,9,20,null,null,15,7]，

![104. 二叉树的最大深度](https://code-thinking-1253855093.file.myqcloud.com/pics/20210203153031914-20230310134849764.png)

返回它的最大深度 3 。

```java
/**
 * 计算二叉树的最大深度
 */
class Solution {
    /**
     * 计算二叉树的最大深度
     * @param root 二叉树的根节点
     * @return 二叉树的最大深度
     */
    public int maxDepth(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>(); // 创建一个队列用于层序遍历
        if (root != null) {
            queue.offer(root); // 如果根节点不为空，则将根节点加入队列
        }
        int depth = 0; // 初始化深度为0
        while (!queue.isEmpty()) { // 当队列不为空时循环
            int size = queue.size(); // 获取当前队列的大小，即当前层的节点数
            depth++; // 深度加1，表示进入下一层
            while (size > 0) { // 遍历当前层的节点
                TreeNode node = queue.poll(); // 出队一个节点
                if (node.left != null) {
                    queue.offer(node.left); // 如果左子节点不为空，则加入队列
                }
                if (node.right != null) {
                    queue.offer(node.right); // 如果右子节点不为空，则加入队列
                }
                size--; // 当前层节点数减1
            }
        }
        return depth; // 返回二叉树的最大深度
    }
}
```

# 111.二叉树的最小深度

```java
// 定义Solution类
class Solution {
    // 定义minDepth方法，返回值为int类型，参数为TreeNode类型的root
    public int minDepth(TreeNode root) {
        // 创建一个LinkedList类型的队列queue
        Queue<TreeNode> queue = new LinkedList<>();
        // 如果root为null，返回0
        if (root == null) {
            return 0;
        }
        // 将root加入队列
        queue.offer(root);
        // 初始化深度为1
        int depth = 1;
        // 当队列不为空时循环
        while (!queue.isEmpty()) {
            // 获取当前队列的大小
            int size = queue.size();
            // 遍历当前队列中的节点
            for (int i = 0; i < size; i++) {
                // 从队列中取出节点
                TreeNode node = queue.poll();
                // 如果节点的左右子节点都为null，返回当前深度
                if (node.left == null && node.right == null) {
                    return depth;
                }
                // 如果节点的左子节点不为null，将左子节点加入队列
                if (node.left != null) {
                    queue.offer(node.left);
                }
                // 如果节点的右子节点不为null，将右子节点加入队列
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            // 深度加一
            depth++;
        }
        // 返回深度
        return depth;
    }
}
```

# 226.翻转二叉树

翻转一棵二叉树。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203192644329.png" alt="226.翻转二叉树" style="zoom:50%;" />

```java
// 定义一个名为Solution的类
class Solution {
    // 定义一个名为invertTree的方法，参数为TreeNode类型的root节点
    public TreeNode invertTree(TreeNode root) {
        // 如果root节点为空，则返回null
        if (root == null) {
            return null;
        }
        // 定义一个名为temp的变量，用于暂存root节点的左子节点
        TreeNode temp = root.left;
        // 将root节点的左子节点指向右子节点
        root.left = root.right;
        // 将root节点的右子节点指向temp，即原来的左子节点
        root.right = temp;
        // 递归调用invertTree方法，对root节点的左子节点进行翻转
        root.left = invertTree(root.left);
        // 递归调用invertTree方法，对root节点的右子节点进行翻转
        root.right = invertTree(root.right);
        // 返回翻转后的root节点
        return root;
    }
}
```

# 101.对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203144607387.png" alt="101. 对称二叉树" style="zoom:50%;" />

```java
/**
 * 判断给定的二叉树是否是对称二叉树
 */
class Solution {
    /**
     * 判断二叉树是否对称
     * @param root 二叉树的根节点
     * @return 如果是对称二叉树返回true，否则返回false
     */
    public boolean isSymmetric(TreeNode root) {
        return compare(root.left, root.right);
    }

    /**
     * 比较左右两个节点及其子树是否对称
     * @param left 左子树的根节点
     * @param right 右子树的根节点
     * @return 如果对称返回true，否则返回false
     */
    private boolean compare(TreeNode left, TreeNode right) {
        if (left == null && right == null) {
            return true;
        }
        if (left == null || right == null) {
            return false;
        }
        if (left.val != right.val) {
            return false;
        }
        return compare(left.left, right.right) && compare(left.right, right.left);
    }
}
```

# 222.完全二叉树的节点个数

给出一个完全二叉树，求出该树的节点个数。

示例 1：

- 输入：root = [1,2,3,4,5,6]
- 输出：6

示例 2：

- 输入：root = []
- 输出：0

示例 3：

- 输入：root = [1]
- 输出：1

```java
// 定义一个名为Solution的类
class Solution {
    // 定义一个名为countNodes的公共方法，返回一个整型值，接收一个名为root的TreeNode类型参数
    public int countNodes(TreeNode root) {
        // 如果root为空，则返回0
        if(root == null) {
            return 0;
        }
        // 返回左子树节点数加上右子树节点数再加1（当前节点）
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```

# 110.平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021020315542230.png" alt="110.平衡二叉树" style="zoom:50%;" />

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203155447919.png" alt="110.平衡二叉树1" style="zoom:50%;" />

返回 false 。

```java
/**
 * 检查给定的二叉树是否为平衡二叉树
 */
class Solution {
    /**
     * 判断二叉树是否为平衡二叉树
     * @param root 二叉树的根节点
     * @return 如果是平衡二叉树返回true，否则返回false
     */
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }

    /**
     * 获取二叉树的高度
     * @param root 二叉树的根节点
     * @return 二叉树的高度，如果不是平衡二叉树返回-1
     */
    private int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = getHeight(root.left);
        if (left == -1) {
            return -1;
        }
        int right = getHeight(root.right);
        if (right == -1) {
            return -1;
        }
        return Math.abs(left - right) > 1 ? -1 : Math.max(left, right) + 1;
    }
}
```

# 257. 二叉树的所有路径

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

示例: <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021020415161576.png" alt="257.二叉树的所有路径1" style="zoom:50%;" />

```java
/**
 * 二叉树的所有路径
 */
class Solution {
    /**
     * 返回二叉树所有路径的方法
     * @param root 二叉树的根节点
     * @return 包含所有路径的列表
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> ans = new ArrayList<>();
        if (root == null) {
            return ans;
        }
        dfs(root, ans, "");
        return ans;
    }

    /**
     * 深度优先搜索遍历二叉树的方法
     * @param root 当前节点
     * @param ans 存储路径的列表
     * @param path 当前路径
     */
    private void dfs(TreeNode root, List<String> ans, String path) {
        if (root == null) {
            return;
        }
        path += root.val;
        if (root.left == null && root.right == null) {
            ans.add(path);
        } else {
            path += "->";
            dfs(root.left, ans, path);
            dfs(root.right, ans, path);
        }
    }
}
```

# 404.左叶子之和

计算给定二叉树的所有左叶子之和。

示例：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151927654.png" alt="404.左叶子之和1" style="zoom:50%;" />

```java
// 定义一个名为Solution的类
class Solution {
    // 定义一个名为sumOfLeftLeaves的公共方法，返回类型为整数，参数为TreeNode类型的root
    public int sumOfLeftLeaves(TreeNode root) {
        // 如果root为空，返回0
        if  (root == null) {
            return 0;
        }
        // 递归调用sumOfLeftLeaves方法，传入root的左子节点，并将结果赋值给left
        int left = sumOfLeftLeaves(root.left);
        // 如果root的左子节点不为空且左子节点的左右子节点均为空
        if (root.left != null && root.left.left == null && root.left.right == null) {
            // 将root的左子节点的值赋给left
            left = root.left.val;
        }
        // 递归调用sumOfLeftLeaves方法，传入root的右子节点，并将结果赋值给right
        int right = sumOfLeftLeaves(root.right);

        // 返回left和right的和
        return left + right;
    }
}
```

# **513.找树左下角的值**

给定一个二叉树，在树的最后一行找到最左边的值。

<img src="C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240104114333418.png" alt="image-20240104114333418" style="zoom:50%;" />

一. 层序遍历迭代

1. 每行从右向左遍历，确保最后一个遍历的一定是最后一行最左边的

```java
class Solution{
    
	public int findBottomLeftValue(TreeNode root) {
    	Queue<TreeNode> queue = new LinkedList<>();
   		queue.offer(root);
   		while (!queue.isEmpty()){
     		root = queue.poll();
      		if (root.right != null) queue.offer(root.right);
      		if (root.left != null) queue.offer(root.left);
    	}
    	return root.val;
	}
}
```

2. 每一行遍历时，记录第一个节点，直到最后一行

```java
class Solution {

    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int res = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode poll = queue.poll();
                if (i == 0) {
                    res = poll.val;
                }
                if (poll.left != null) {
                    queue.offer(poll.left);
                }
                if (poll.right != null) {
                    queue.offer(poll.right);
                }
            }
        }
        return res;
    }
}
```

二.递归法

全局变量，Deep用来记录最大深度，value记录最大深度最左节点的数值。

```java
class Solution {
    private int Deep = -1;
    private int value = 0;
    public int findBottomLeftValue(TreeNode root) {
        value = root.val;
        findLeftValue(root,0);
        return value;
    }

    private void findLeftValue (TreeNode root,int deep) {
        if (root == null) return;
        if (root.left == null && root.right == null) {
            if (deep > Deep) {
                value = root.val;
                Deep = deep;
            }
        }
        if (root.left != null) findLeftValue(root.left,deep + 1);
        if (root.right != null) findLeftValue(root.right,deep + 1);
    }
}
```

# **112.路径总和**

![image-20240104114225179](C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240104114225179.png)

```java
class Solution{
	Public boolean haspathSum(TreeNode root,int targetSum){
		if(root == null)
			return false;
		if(root.left == null && root.right == null &&root.val == targetSum)
			return true;
		if(root.left == null && root.right == null)
			return false;
		if(root.left != null)
			if(hasPathSum(root.left, targetSum-root.val))
				return true;
		if(root.right != null)
			if(hasPathSum(root.right, targetSum-root.val))
				return true;
		return false;
	}
}

```

# 113.路径总和2

![image-20240104114255999](C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240104114255999.png)

```java
class Solution{
    public List<List<Integer>> pathSum(TreeNoderoot, int targetSum) {
            List<List<Integer>> res = new ArrayList<>();
            if (root == null) {
                return res;
            }
            backtrack(root, targetSum, new ArrayList<>(), res);
            return res;
        }

    private void backtrack(TreeNode root, int targetSum, List<Integer> list, List<List<Integer>> res) {
            if (root == null) {
                return;
            }
            list.add(root.val);
            targetSum -= root.val;
            if (targetSum == 0 && root.left == null && root.right == null) {
                res.add(new ArrayList<>(list));
            }
            backtrack(root.left, targetSum, list, res);
            backtrack(root.right, targetSum, list, res);
            list.remove(list.size() - 1);
        }
}
```

# 106.中序和后序遍历构造二叉树

![image-20240104114159158](C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240104114159158.png)

```java
class Solution {
    Map<Integer, Integer> map;  // 方便根据数值查找位置
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        map = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) { // 用map保存中序序列的数值对应位置
            map.put(inorder[i], i);
        }

        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  // 前闭后开
    }

    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {
        // 参数里的范围都是前闭后开
        if (inBegin >= inEnd || postBegin >= postEnd) {  // 不满足左闭右开，说明没有元素，返回空树
            return null;
        }
        int rootIndex = map.get(postorder[postEnd - 1]);  // 找到后序遍历的最后一个元素在中序遍历中的位置
        TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点
        int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定后序数列的个数
        root.left = findNode(inorder, inBegin, rootIndex,
                            postorder, postBegin, postBegin + lenOfLeft);
        root.right = findNode(inorder, rootIndex + 1, inEnd,
                            postorder, postBegin + lenOfLeft, postEnd - 1);

        return root;
    }
}
```

# 105.中序和前序遍历构造二叉树

![image-20240104114202323](C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240104114202323.png)

```java
class Solution {
    Map<Integer, Integer> map;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        map = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) { // 用map保存中序序列的数值对应位置
            map.put(inorder[i], i);
        }
        return findNode(preorder, 0, preorder.length, inorder, 0, inorder.length);
    }

    public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) {
        // 参数里的范围都是前闭后开
        if (inBegin >= inEnd || preBegin >= preEnd) {  // 不满足左闭右开，说明没有元素，返回空树
            return null;
        }
        int rootIndex = map.get(preorder[preBegin]);
        TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点
        int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定后序数列的个数
        root.left = findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1,
                inorder, inBegin, rootIndex);
        root.right = findNode(preorder, preBegin + lenOfLeft + 1, preEnd,
                inorder, rootIndex + 1, inEnd);

        return root;
    }
}

```

# 654.最大二叉树

![image-20240104114129381](C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240104114129381.png)

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return construct(nums, 0, nums.length);//使用数组下标索引
    }
    public TreeNode construct(int[] nums, int leftIndex, int rightIndex){
        if(rightIndex - leftIndex < 1)//终止条件
            return null;
        if(rightIndex - leftIndex == 1)//只有一个元素
            return new TreeNode(nums[leftIndex]);
        int maxIndex = leftIndex;
        int maxValue = nums[maxIndex];
        for (int i = leftIndex + 1; i < rightIndex; i++) {
            if (nums[i] > maxValue) {
                maxValue = nums[i];
                maxIndex = i;
            }
        }
        TreeNode root = new TreeNode(maxValue);
        root.left = construct(nums, leftIndex, maxIndex);
        root.right = construct(nums, maxIndex + 1, rightIndex);
        return root;
    }
}
```

# 617.合并二叉树

![image-20240104114058861](C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240104114058861.png)

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null)
            return root2;
        if (root2 == null)
            return root1;
        root1.val += root2.val;
        root1.left = mergeTrees(root1.left, root2.left);
        root1.right = mergeTrees(root1.right, root2.right);
        return root1;
    }
}
```

# 700.二叉搜索树中的搜索

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

<img src="C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240104114017223.png" alt="image-20240104114017223" style="zoom: 80%;" />

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null)
            return null;
        if(root.val == val)
            return root;
        else if(root.val > val)
            return searchBST(root.left, val);
        else
            return searchBST(root.right, val);
    }
}
```

# 98.验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。

- 节点的右子树只包含大于当前节点的数。

- 所有左子树和右子树自身必须也是二叉搜索树。

  <img src="C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240104113914046.png" alt="image-20240104113914046" style="zoom: 67%;" />

```java
class Solution {
    // 递归
    TreeNode max;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        // 左
        boolean left = isValidBST(root.left);
        if (left == false) {
            return false;
        }
        // 中
        if (max != null && root.val <= max.val) {
            return false;
        }
        max = root;
        // 右
        boolean right = isValidBST(root.right);
        return right;
    }
}
```

# 530.二叉搜索树的最小绝对差

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201014223400123.png" alt="530二叉搜索树的最小绝对差" style="zoom:50%;" />

```java
class Solution {

    TreeNode pre = null;//记录上一个遍历的节点
    int min = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        dfs(root);
        return min;
    }

    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        //左
        dfs(root.left);
        //中
        if (pre != null) {
            min = Math.min(min, root.val - pre.val);
        }
        pre = root;
        //右
        dfs(root.right);
    }
}
```

# 501.二叉搜索树中的众数

<img src="C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240105102838104.png" alt="image-20240105102838104" style="zoom: 80%;" />

```java
/**
 * 二叉搜索树中的众数
 */
class Solution {
    TreeNode pre = null; // 前一个节点
    int maxCount = 0; // 众数的出现次数
    int count = 0; // 当前节点的出现次数
    List<Integer> list = new ArrayList<>(); // 存储众数的列表

    /**
     * 查找二叉搜索树中的众数
     * @param root 二叉搜索树的根节点
     * @return 众数数组
     */
    public int[] findMode(TreeNode root) {
        if (root == null) {
            return new int[0];
        }
        inorder(root); // 中序遍历二叉搜索树
        int[] res = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }
        return res;
    }

    /**
     * 中序遍历二叉搜索树
     * @param root 当前节点
     */
    public void inorder(TreeNode root) {
        if (root == null) {
            return;
        }
        inorder(root.left); // 遍历左子树
        if (pre == null) { // 如果前一个节点为空，说明是第一个节点
            pre = root;
            count = 1;
        } else if (pre.val == root.val) { // 如果当前节点的值和前一个节点的值相等
            count++; // 当前节点的出现次数加1
        } else { // 如果当前节点的值和前一个节点的值不相等
            pre = root;
            count = 1; // 当前节点的出现次数重置为1
        }
        if (count == maxCount) { // 如果当前节点的出现次数等于众数的出现次数
            list.add(pre.val); // 将当前节点的值加入众数列表
        }
        if (count > maxCount) { // 如果当前节点的出现次数大于众数的出现次数
            maxCount = count; // 更新众数的出现次数
            list.clear(); // 清空众数列表
            list.add(pre.val); // 将当前节点的值加入众数列表
        }
        inorder(root.right); // 遍历右子树
    }
}
```

# 236.二叉树的最近公共祖先

```java
/**
 * 二叉树的最近公共祖先
 */
class Solution {
    /**
     * 查找二叉树中两个节点的最近公共祖先
     *
     * @param root 二叉树的根节点
     * @param p    第一个节点
     * @param q    第二个节点
     * @return 最近公共祖先节点
     */
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 如果根节点为空或者根节点等于p或者根节点等于q，则返回根节点
        if (root == null || root == p || root == q)
            return root;
        // 在左子树中查找p和q的最近公共祖先
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        // 在右子树中查找p和q的最近公共祖先
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // 如果左子树和右子树都找到了最近公共祖先，则返回根节点
        if (left != null && right != null)
            return root;
        // 如果只有左子树找到了最近公共祖先，则返回左子树的最近公共祖先
        return left != null ? left : right;
    }
}
```

# 235.二叉搜索树的最近公共祖先

```java
/**
 * 二叉搜索树的最近公共祖先
 */
class Solution {
    /**
     * 找到二叉搜索树中两个节点的最近公共祖先
     * @param root 二叉搜索树的根节点
     * @param p 第一个节点
     * @param q 第二个节点
     * @return 最近公共祖先节点
     */
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 如果根节点为空，直接返回null
        if (root == null)
            return null;
        // 如果根节点的值大于p和q的值，说明p和q都在根节点的左子树中，递归调用左子树
        if (root.val > p.val && root.val > q.val)
            return lowestCommonAncestor(root.left, p, q);
        // 如果根节点的值小于p和q的值，说明p和q都在根节点的右子树中，递归调用右子树
        if (root.val < p.val && root.val < q.val)
            return lowestCommonAncestor(root.right, p, q);
        // 如果上述情况都不满足，说明p和q分别在根节点的左右子树中，或者其中一个节点就是根节点，直接返回根节点
        return root;
    }
}
```

# 701.二叉搜索树中的插入操作

```java
/**
 * 二叉搜索树中的插入操作
 */
class Solution {
    /**
     * 向二叉搜索树中插入节点
     * @param root 二叉搜索树的根节点
     * @param val 要插入的节点的值
     * @return 插入节点后的二叉搜索树的根节点
     */
    public TreeNode insertIntoBST(TreeNode root, int val) {
        // 如果根节点为空，直接创建一个新节点作为根节点
        if (root == null) {
            return new TreeNode(val);
        }
        // 如果要插入的值小于根节点的值，递归地将节点插入到左子树中
        if (root.val > val) {
            root.left = insertIntoBST(root.left, val);
        } else {
            // 如果要插入的值大于等于根节点的值，递归地将节点插入到右子树中
            root.right = insertIntoBST(root.right, val);
        }
        return root;
    }
}
```

# 450.删除二叉搜索树中的节点

```java
/**
 * 删除二叉搜索树中的节点
 */
class Solution {
    /**
     * 删除二叉搜索树中的指定节点
     * @param root 二叉搜索树的根节点
     * @param key 要删除的节点的值
     * @return 删除节点后的二叉搜索树的根节点
     */
    public TreeNode deleteNode(TreeNode root, int key) {
        // 如果根节点为空，直接返回null
        if (root == null) {
            return null;
        }
        // 如果根节点的值等于要删除的值
        if (root.val == key) {
            // 如果根节点的左子树为空，返回右子树作为新的根节点
            if (root.left == null) {
                return root.right;
            }
            // 如果根节点的右子树为空，返回左子树作为新的根节点
            if (root.right == null) {
                return root.left;
            }
            // 获取右子树中的最小节点
            TreeNode minNode = getMin(root.right);
            // 将最小节点的值赋给根节点
            root.val = minNode.val;
            // 删除右子树中的最小节点
            root.right = deleteNode(root.right, minNode.val);
        } else if (root.val > key) {
            // 如果根节点的值大于要删除的值，递归删除左子树中的节点
            root.left = deleteNode(root.left, key);
        } else {
            // 如果根节点的值小于要删除的值，递归删除右子树中的节点
            root.right = deleteNode(root.right, key);
        }
        // 返回删除节点后的二叉搜索树的根节点
        return root;
    }
    
    /**
     * 获取二叉搜索树中的最小节点
     * @param node 二叉搜索树的根节点
     * @return 二叉搜索树中的最小节点
     */
    public TreeNode getMin(TreeNode node) {
        // 循环找到最左边的节点
        while (node.left != null) {
            node = node.left;
        }
        // 返回最小节点
        return node;
    }
}
```

# 669.修剪二叉树

```java
/**
 * 修剪二叉搜索树
 */
class Solution {
    /**
     * 修剪二叉搜索树的方法
     * @param root 二叉搜索树的根节点
     * @param low 修剪的下界
     * @param high 修剪的上界
     * @return 修剪后的二叉搜索树的根节点
     */
    public TreeNode trimBST(TreeNode root, int low, int high) {
        // 如果根节点为空，则返回空
        if  (root == null) {
            return null;
        }
        // 如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。
        if (root.val < low) {
            return trimBST(root.right, low, high);
        }
        // 如果root(当前节点)的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。
        if (root.val > high) {
            return trimBST(root.left, low, high);
        }
        // 接下来要将下一层处理完左子树的结果赋给root->left，处理完右子树的结果赋给root->right。
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        return root;
    }
}
```

# 108.将有序数组转换为二叉搜索树

```java
/**
 * 将有序数组转换为二叉搜索树
 */
class Solution {
    /**
     * 将有序数组转换为二叉搜索树
     * @param nums 有序数组
     * @return 二叉搜索树的根节点
     */
    public TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums, 0, nums.length - 1);
    }

    /**
     * 辅助方法，递归构建二叉搜索树
     * @param nums 有序数组
     * @param left 数组左边界
     * @param right 数组右边界
     * @return 当前子树的根节点
     */
    private TreeNode helper(int[] nums, int left, int right) {
        // 如果左边界大于右边界，说明当前子树为空，返回null
        if (left > right) {
            return null;
        }
        // 计算中间位置
        int mid = (left + right) / 2;
        // 创建当前子树的根节点
        TreeNode root = new TreeNode(nums[mid]);
        // 递归构建左子树
        root.left = helper(nums, left, mid - 1);
        // 递归构建右子树
        root.right = helper(nums, mid + 1, right);
        // 返回当前子树的根节点
        return root;
    }
}
```

# 538.将二叉搜索树转换为累加树

![image-20240105113658743](C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240105113658743.png)

```java
class Solution {
    // 定义一个整型变量sum，用于累加节点的值
    int sum = 0;
    
    // 定义一个方法，将二叉搜索树转换为累加树
    public TreeNode convertBST(TreeNode root) {
        // 如果根节点为空，直接返回null
        if (root == null) {
            return null;
        }
        
        // 递归遍历右子树
        convertBST(root.right);
        
        // 将当前节点的值累加到sum上
        sum += root.val;
        
        // 将当前节点的值更新为sum
        root.val = sum;
        
        // 递归遍历左子树
        convertBST(root.left);
        
        // 返回根节点
        return root;
    }
}
```

# 77.组合

```java
/**
 * 组合
 */
class Solution {
    /**
     * 组合方法
     * @param n 组合的总数
     * @param k 组合的长度
     * @return 组合结果列表
     */
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        // 如果k大于n，直接返回空列表
        if (k > n) {
            return res;
        }
        // 创建一个路径列表，用于存储当前组合的元素
        List<Integer> path = new ArrayList<>();
        // 进行深度优先搜索
        dfs(n, k, 1, path, res);
        // 返回组合结果列表
        return res;
    }
    /**
     * 深度优先搜索方法
     * @param n 组合的总数
     * @param k 组合的长度
     * @param start 当前搜索的起始位置
     * @param path 当前组合的路径
     * @param res 组合结果列表
     */
    private void dfs(int n, int k, int start, List<Integer> path, List<List<Integer>> res) {
        // 如果路径长度等于k，说明已经找到一个组合，将其加入结果列表中
        if (path.size() == k) {
            res.add(new ArrayList<>(path));
            return;
        }
        // 遍历从start到n-(k-path.size())+1的数字，已经选择的元素个数：path.size();还需要的元素个数为: k - path.size();在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历,为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。从2开始搜索都是合理的，可以是组合[2, 3, 4]。
        for (int i = start; i <= n - (k - path.size()) + 1; i++) {
            // 将当前数字加入路径中
            path.add(i);
            // 递归搜索下一个数字
            dfs(n, k, i + 1, path, res);
            // 回溯，将当前数字从路径中移除
            path.remove(path.size() - 1);
        }
    }
}
```

# 216.组合总和III

```java
/**
*找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。
*说明：
*所有数字都是正整数。
*解集不能包含重复的组合。
*示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]
*示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]
*/
class Solution {
    /**
     * 组合总和 III
     *
     * @param k 组合中元素的个数
     * @param n 目标和
     * @return 所有可能的组合
     */
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> res = new ArrayList<>(); // 存储结果的列表
        List<Integer> list = new ArrayList<>(); // 存储当前组合的列表
        dfs(k, n, 1, list, res); // 深度优先搜索
        return res; // 返回结果列表
    }

    /**
     * 深度优先搜索
     *
     * @param k     组合中元素的个数
     * @param n     目标和
     * @param start 当前搜索的起始位置
     * @param list  当前组合的列表
     * @param res   存储结果的列表
     */
    private void dfs(int k, int n, int start, List<Integer> list, List<List<Integer>> res) {
        if (n < 0) { // 如果目标和小于0，直接返回
            return;
        }
        if (list.size() == k) { // 如果当前组合的元素个数等于k
            if (n == 0) { // 如果目标和等于0
                res.add(new ArrayList<>(list)); // 将当前组合添加到结果列表中
            }
            return;
        }
        for (int i = start; i <= n - (k - list.size()) + 1; i++) { // 从起始位置开始遍历
            list.add(i); // 将当前元素添加到组合中
            dfs(k, n - i, i + 1, list, res); // 递归搜索下一个元素
            list.remove(list.size() - 1); // 回溯，移除当前元素
        }
    }
}
```

# 17.电话号码的字母组合

```java
/**
 * 电话号码的字母组合
 */
class Solution {
    /**
     * 获取电话号码的字母组合
     * @param digits 电话号码
     * @return 字母组合列表
     */
    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<>();
        if (digits.length() == 0) {
            return res;
        }
        // 数字到字母的映射关系
        String[] map = new String[]{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv",  "wxyz"};
        // 回溯法获取字母组合
        backtrack(res, map, digits, 0, new StringBuilder());
        return res;
    }

    /**
     * 回溯法获取字母组合
     * @param res 结果列表
     * @param map 数字到字母的映射关系
     * @param digits 电话号码
     * @param index 当前处理的数字索引
     * @param sb 当前已经生成的字母组合
     */
    private void backtrack(List<String> res, String[] map, String digits, int index, StringBuilder sb) {
        // 如果已经处理完所有数字，则将当前字母组合加入结果列表
        if (index == digits.length()) {
            res.add(sb.toString());
            return;
        }
        // 获取当前数字对应的字母集合
        String letters = map[digits.charAt(index) - '0'];
        // 遍历当前数字对应的字母集合
        for (int i = 0; i < letters.length(); i++) {
            // 将当前字母加入字母组合
            sb.append(letters.charAt(i));
            // 递归处理下一个数字
            backtrack(res, map, digits, index + 1, sb);
            // 回溯，将当前字母从字母组合中删除
            sb.deleteCharAt(sb.length() - 1);                                                                                  
        }
    }
}
```

# 39.组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

- 所有数字（包括 target）都是正整数。
- 解集不能包含重复的组合。

示例 1：

- 输入：candidates = [2,3,6,7], target = 7,
- 所求解集为： [ [7], [2,2,3] ]

示例 2：

- 输入：candidates = [2,3,5], target = 8,
- 所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ]

```java
/**
 * 组合总和问题的解决方案
 */
class Solution {
    /**
     * 求解组合总和
     * @param candidates 候选数字数组
     * @param target 目标和
     * @return 返回所有可能的组合
     */
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>(); // 存储结果的列表
        List<Integer> list = new ArrayList<>(); // 存储当前组合的列表
        dfs(candidates, target, 0, list, res); // 调用深度优先搜索函数
        return res; // 返回结果列表
    }
    /**
     * 深度优先搜索函数
     * @param candidates 候选数字数组
     * @param target 目标和
     * @param start 当前搜索的起始位置
     * @param list 当前组合的列表
     * @param res 存储结果的列表
     */
    private void dfs(int[] candidates, int target, int start, List<Integer> list, List<List<Integer>> res) {
        if (target < 0) { // 如果目标和小于0，说明当前组合不满足条件，直接返回
            return;
        }
        if (target == 0) { // 如果目标和等于0，说明当前组合满足条件，将其加入结果列表
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < candidates.length; i++) { // 遍历候选数字数组
            list.add(candidates[i]); // 将当前数字加入当前组合
            dfs(candidates, target - candidates[i], i, list, res); // 递归调用深度优先搜索函数
            list.remove(list.size() - 1); // 回溯，将当前数字从当前组合中移除
        }
    }
}
```

# 40.组合总和II

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。

- 示例 1:
- 输入: candidates = [10,1,2,7,6,1,5], target = 8,
- 所求解集为:

```text
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```

- 示例 2:
- 输入: candidates = [2,5,2,1,2], target = 5,
- 所求解集为:

```text
[
  [1,2,2],
  [5]
]
```

```java
/**
 * 组合总和 II
 */
class Solution {
    /**
     * 求解组合总和
     *
     * @param candidates 候选数组
     * @param target     目标和
     * @return 所有符合条件的组合
     */
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        if (candidates == null || candidates.length == 0) {
            return res;
        }
        Arrays.sort(candidates); // 对候选数组进行排序
        backtrack(res, new ArrayList<>(), candidates, target, 0);
        return res;
    }

    /**
     * 回溯法求解组合总和
     *
     * @param res        结果集
     * @param list       当前组合
     * @param candidates 候选数组
     * @param target     目标和
     * @param start      当前起始位置
     */
    private void backtrack(List<List<Integer>> res, List<Integer> list, int[] candidates, int target, int start) {
        if (target == 0) { // 当目标和为0时，将当前组合加入结果集
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            if (i > start && candidates[i] == candidates[i - 1]) { // 去重，避免重复组合
                continue;
            }
            if (candidates[i] > target) { // 当前候选数大于目标和，剪枝
                break;
            }
            list.add(candidates[i]); // 将当前候选数加入当前组合
            backtrack(res, list, candidates, target - candidates[i], i + 1); // 递归求解剩余部分的组合
            list.remove(list.size() - 1); // 回溯，移除当前候选数
        }
    }
}
```

# 131.分割回文串

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回 s 所有可能的分割方案。

示例: 输入: "aab" 输出: [ ["aa","b"], ["a","a","b"] ]

```java
/**
 * 分割回文串
 */
class Solution {
    /**
     * 分割回文串
     *
     * @param s 给定的字符串
     * @return 回文串的所有可能分割结果
     */
    public List<List<String>> partition(String s) {
        List<List<String>> res = new ArrayList<>(); // 存储结果的列表
        if (s == null || s.length() == 0) {
            return res; // 如果字符串为空，直接返回空列表
        }
        List<String> list = new ArrayList<>(); // 存储当前回文串分割的结果
        backtrack(s, 0, list, res); // 回溯算法求解回文串的所有可能分割结果
        return res; // 返回结果列表
    }
    /**
     * 回溯算法求解回文串的所有可能分割结果
     *
     * @param s     给定的字符串
     * @param start 当前回溯的起始位置
     * @param list  当前回文串分割的结果
     * @param res   存储结果的列表
     */
    private void backtrack(String s, int start, List<String> list, List<List<String>> res) {
        if (start == s.length()) {
            res.add(new ArrayList<>(list)); // 当回溯到字符串末尾时，将当前分割结果加入到结果列表中
            return;
        }
        for (int i = start; i < s.length(); i++) {
            if (isPalindrome(s, start, i)) { // 判断从start到i的子串是否为回文串
                list.add(s.substring(start, i + 1)); // 如果是回文串，将该子串加入到当前分割结果中
                backtrack(s, i + 1, list, res); // 继续回溯下一个位置
                list.remove(list.size() - 1); // 回溯完后，移除最后一个加入的子串，以便尝试其他分割方式
            }
        }
    }
    /**
     * 判断字符串的子串是否为回文串
     *
     * @param s    给定的字符串
     * @param start 子串的起始位置
     * @param end   子串的结束位置
     * @return 子串是否为回文串
     */
    private boolean isPalindrome(String s, int start, int end) {
        while (start < end) {
            if (s.charAt(start) != s.charAt(end)) {
                return false; // 如果子串的起始字符和结束字符不相等，则不是回文串
            }
            start++;
            end--;
        }
        return true; // 子串是回文串
    }
}
该代码实现的功能是将给定字符串s分割成回文串的所有可能组合，并返回这些组合的列表。
代码的具体步骤如下：

1. 创建一个空的列表res，用于存储所有可能的回文串组合。
2. 如果输入的字符串s为空或长度为0，直接返回空列表res。
3. 创建一个空的列表list，用于存储当前回文串组合。
4. 调用回溯函数backtrack，传入字符串s、起始位置start、列表list和列表res。
5. 回溯函数backtrack的实现如下：
   - 如果起始位置start等于字符串s的长度，说明已经遍历完整个字符串，将当前回文串组合添加到列表res中，并返回。
   - 循环遍历从起始位置start到字符串s的末尾的所有可能的子串：
     - 如果当前子串是回文串（通过调用isPalindrome函数判断），将其添加到列表list中。
     - 递归调用回溯函数backtrack，传入更新后的起始位置i+1、列表list和列表res。
     - 回溯，将列表list中最后一个元素移除，以便尝试下一个可能的回文串组合。
6. 创建一个辅助函数isPalindrome，用于判断给定字符串s的子串是否是回文串：
   - 使用双指针start和end，分别指向子串的起始位置和末尾位置。
   - 循环判断start指向的字符和end指向的字符是否相等，如果不相等则返回false。
   - 如果循环结束后start小于end，说明子串不是回文串，返回false；否则返回true。
7. 返回列表res，即所有可能的回文串组合。
```

# 93.复原IP地址

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。

示例 1：

- 输入：s = "25525511135"
- 输出：["255.255.11.135","255.255.111.35"]

示例 2：

- 输入：s = "0000"
- 输出：["0.0.0.0"]

示例 3：

- 输入：s = "1111"
- 输出：["1.1.1.1"]

示例 4：

- 输入：s = "010010"

- 输出：["0.10.0.10","0.100.1.0"]

  

```java
/**
 * 复原 IP 地址
 */
class Solution {
    List<String> result = new ArrayList<String>(); // 存储结果的列表
    StringBuilder stringBuilder = new StringBuilder(); // 用于构建 IP 地址的字符串
    public List<String> restoreIpAddresses(String s) {
        restoreIpAddressesHandler(s, 0, 0); // 调用辅助函数进行处理
        return result; // 返回结果列表
    }
    /**
     * 辅助函数，用于递归处理 IP 地址的复原
     * @param s 原始字符串
     * @param start 当前处理的起始位置
     * @param number 当前已经复原的 IP 地址段数
     */
    public void restoreIpAddressesHandler(String s, int start, int number) {
        // 如果已经处理完整个字符串并且已经复原了4个 IP 地址段，则将结果添加到结果列表中
        if (start == s.length() && number == 4) {
            result.add(stringBuilder.toString());
            return;
        }
		// 如果start等于s的长度但是ip段的数量不为4，或者ip段的数量为4但是start小于s的长度，则直接返回
        if (start == s.length() || number == 4) {
            return;
        }
		// 剪枝：ip段的长度最大是3，并且ip段处于[0,255]
        for (int i = start; i < s.length() && i - start < 3 && Integer.parseInt(s.substring(start, i + 1)) >= 0
                && Integer.parseInt(s.substring(start, i + 1)) <= 255; i++) {
            // 如果当前 IP 地址段的长度大于1且以0开头，则跳过
            if (i + 1 - start > 1 && s.charAt(start) - '0' == 0) {
                continue;
            }
            // 将当前 IP 地址段添加到字符串中
            stringBuilder.append(s.substring(start, i + 1));
            // 如果当前 IP 地址段不是最后一个，则添加一个点
            if (number < 3) {
                stringBuilder.append(".");
            }
            number++; // IP 地址段数加1
            // 递归处理下一个 IP 地址段
            restoreIpAddressesHandler(s, i + 1, number);
            number--; // 回溯，IP 地址段数减1
            // 删除当前添加的 IP 地址段
            stringBuilder.delete(start + number, i + number + 2);
        }
    }
}
该代码实现的功能是给定一个字符串，将其拆分成符合 IP 地址规则的形式，并返回所有可能的 IP 地址。
代码的具体步骤如下：
1. 创建一个空的字符串列表 result 和一个 StringBuilder 对象 stringBuilder。
2. 定义一个公共方法 restoreIpAddresses，接受一个字符串 s 作为参数，并返回一个字符串列表。
3. 在 restoreIpAddresses 方法中调用私有方法 restoreIpAddressesHandler，传入参数 s、0 和 0。
4. 在 restoreIpAddressesHandler 方法中，首先判断如果 start 等于 s 的长度且 number 等于 4，说明已经找到了一个符合要求的 IP 地址，将 stringBuilder 转换为字符串并添加到 result 列表中，然后返回。
5. 接着判断如果start等于s的长度但是ip段的数量不为4，或者ip段的数量为4但是start小于s的长度，则直接返回。
6. 使用一个循环遍历字符串 s，从 start 开始到 s 的长度，并且限制每个数字的长度不超过 3，并且每个数字的值在 0 到 255 之间。
7. 在循环中，首先判断如果当前数字的长度大于 1 并且第一个字符为 0，说明该数字不符合规则，直接跳过。
8. 将当前数字添加到 stringBuilder 中。
9. 如果 number 小于 3，说明还需要添加点号，将点号添加到 stringBuilder 中。
10. 增加 number 的值。
11. 递归调用 restoreIpAddressesHandler 方法，传入参数 s、i+1 和 number。
12. 减少 number 的值。
13. 删除 stringBuilder 中从 start+number 到 i+number+1 的字符。
14. 循环结束后，返回到上一层递归调用的位置。
15. 最后，返回 result 列表作为结果。
```

# 78.子集

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]

```java
该代码实现的功能是生成给定数组的所有子集。
代码的具体步骤如下：
1. 创建一个空的列表`res`，用于存储所有子集。
2. 创建一个空的列表`list`，用于存储当前正在构建的子集。
3. 将空列表`list`添加到`res`中，作为初始的空子集。
4. 调用`backtrack`函数，开始构建子集。
5. 在`backtrack`函数中，如果`start`等于数组的长度，则表示已经遍历完所有元素，直接返回。
6. 使用一个循环，从`start`开始遍历数组中的元素。
7. 将当前元素添加到`list`中。
8. 将`list`添加到`res`中，作为一个新的子集。
9. 递归调用`backtrack`函数，传入更新后的`list`、`res`、`nums`和`i + 1`作为参数，继续构建子集。
10. 在递归调用返回后，将`list`中的最后一个元素移除，以便尝试下一个元素。
11. 重复步骤6-10，直到遍历完所有元素。
12. 返回最终的子集列表`res`。
/**
 * 子集
 */
class Solution {
    /**
     * 生成给定数组的所有子集
     * @param nums 给定的数组
     * @return 所有子集的列表
     */
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>(); // 存储结果的列表
        List<Integer> list = new ArrayList<>(); // 存储当前子集的列表
        res.add(new ArrayList<>(list)); // 将空集添加到结果列表中
        backtrack(res, list, nums, 0); // 回溯生成所有子集
        return res; // 返回结果列表
    }

    /**
     * 回溯生成所有子集
     * @param res 结果列表
     * @param list 当前子集的列表
     * @param nums 给定的数组
     * @param start 当前回溯的起始位置
     */
    private void backtrack(List<List<Integer>> res, List<Integer> list, int[] nums, int start) {
        if (start == nums.length) // 如果回溯的起始位置等于数组长度，说明已经遍历完所有元素，返回
            return;
        for (int i = start; i < nums.length; i++){ // 从起始位置开始遍历数组
            list.add(nums[i]); // 将当前元素加入当前子集
            res.add(new ArrayList<>(list)); // 将当前子集添加到结果列表中
            backtrack(res, list, nums, i + 1); // 递归回溯生成下一个子集
            list.remove(list.size() - 1); // 回溯，移除当前子集的最后一个元素
        }
    }
}
```

# 90.子集II

给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

- 输入: [1,2,2]
- 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]

```java
该代码实现的功能是找出给定数组的所有子集，包括重复元素。
代码的具体步骤如下：
1. 创建一个空的结果列表`res`和一个空的列表`list`。
2. 对给定数组`nums`进行排序。
3. 将空列表`list`添加到结果列表`res`中。
4. 调用回溯函数`backtrack`，传入结果列表`res`、空列表`list`、排序后的数组`nums`和起始索引0。
5. 在回溯函数中，从起始索引开始遍历数组`nums`。
6. 如果当前索引大于起始索引且当前元素与前一个元素相同，则跳过当前循环。
7. 将当前元素添加到列表`list`中。
8. 将列表`list`的副本添加到结果列表`res`中。
9. 递归调用回溯函数`backtrack`，传入结果列表`res`、列表`list`、数组`nums`和当前索引加1。
10. 移除列表`list`的最后一个元素，以便进行下一次循环。
11. 返回结果列表`res`。
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> res = new ArrayList<>(); // 创建一个存储结果的列表
        List<Integer> list = new ArrayList<>(); // 创建一个临时列表，用于存储每个子集
        Arrays.sort(nums); // 对数组进行排序，以便处理重复元素
        res.add(new ArrayList<>(list)); // 将空列表添加到结果列表中，作为初始子集
        backtrack(res, new ArrayList<>(), nums, 0); // 回溯生成所有子集
        return res; // 返回结果列表
    }

    private void backtrack(List<List<Integer>> res, List<Integer> list, int[] nums, int start) {
        for (int i = start; i < nums.length; i++){ // 遍历数组中的每个元素
            if (i > start && nums[i] == nums[i - 1]) { // 如果当前元素与前一个元素相同，跳过该元素，避免生成重复的子集
                continue;
            }
            list.add(nums[i]); // 将当前元素添加到临时列表中
            res.add(new ArrayList<>(list)); // 将临时列表添加到结果列表中，生成一个新的子集
            backtrack(res, list, nums, i + 1); // 递归调用，继续生成下一个元素的子集
            list.remove(list.size() - 1); // 回溯，移除最后一个元素，以便生成其他子集
        }
    }
}
```

# 491.非递减子序列

```java
该代码实现的功能是找到给定数组中的所有非递减子序列。

代码的具体步骤如下：
1. 创建一个空的列表`ans`，用于存储所有非递减子序列。
2. 调用`backtrack`方法，传入`ans`、一个空的临时列表`tempList`、给定数组`nums`和起始位置`0`。
3. 在`backtrack`方法中，首先判断`tempList`的长度是否大于等于2，如果是，则将`tempList`的副本添加到`ans`中。
4. 创建一个长度为201的整型数组`used`，用于记录已经使用过的元素。
5. 使用一个循环，从起始位置开始遍历数组`nums`。
6. 在循环中，首先判断两个条件：如果`tempList`不为空且当前元素小于`tempList`中最后一个元素，或者`used`数组中当前元素已经被使用过，则跳过当前循环。
7. 将`nums[i]`对应的索引设置为1，表示该元素已经被使用过。
8. 将`nums[i]`添加到`tempList`中。
9. 递归调用`backtrack`方法，传入`ans`、`tempList`、`nums`和`i + 1`作为新的起始位置。
10. 从`tempList`中移除最后一个元素，以便进行下一次循环。
11. 返回到`findSubsequences`方法，将`ans`作为结果返回。
/**
 * 非递减子序列
 */
class Solution {
    /**
     * 查找给定数组中的所有非递减子序列
     * @param nums 给定的数组
     * @return 所有非递减子序列的列表
     */
    public List<List<Integer>> findSubsequences(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>(); // 存储结果的列表
        backtrack(ans, new ArrayList<>(), nums, 0); // 回溯算法查找非递减子序列
        return ans; // 返回结果列表
    }
    /**
     * 回溯算法查找非递减子序列
     * @param ans 结果列表
     * @param tempList 当前的子序列列表
     * @param nums 给定的数组
     * @param start 当前遍历的起始位置
     */
    private void backtrack(List<List<Integer>> ans, List<Integer> tempList, int[] nums, int start) {
        if (tempList.size() >= 2) { // 如果当前子序列的长度大于等于2
            ans.add(new ArrayList<>(tempList)); // 将当前子序列添加到结果列表中
        }
        int[] used = new int[201]; // 记录已经使用过的数字
        for (int i = start; i < nums.length; i++) { // 从当前位置开始遍历数组
            if ((!tempList.isEmpty() && nums[i] < tempList.get(tempList.size() - 1)) || used[nums[i] + 100] == 1) {
                // 如果当前数字小于子序列的最后一个数字，或者当前数字已经被使用过，则跳过当前数字
                continue;
            }
            used[nums[i] + 100] = 1; // 标记当前数字为已使用
            tempList.add(nums[i]); // 将当前数字添加到子序列中
            backtrack(ans, tempList, nums, i + 1); // 继续向后遍历数组
            tempList.remove(tempList.size() - 1); // 回溯，将当前数字从子序列中移除
        }
    }
}
```

# 122.买卖股票的最佳时机II

给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

- 输入: [7,1,5,3,6,4]
- 输出: 7
- 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

示例 2:

- 输入: [1,2,3,4,5]
- 输出: 4
- 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例  3:

- 输入: [7,6,4,3,1]
- 输出: 0
- 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

**局部最优：收集每天的正利润，全局最优：求得最大利润**。

```java
//贪心算法

// 定义一个Solution类
class Solution {
    // 定义一个方法，用于计算买卖股票的最佳时机
    public int maxProfit(int[] prices) {
        // 初始化最大利润为0
        int ans = 0;
        // 遍历股票价格数组
        for (int i = 1; i < prices.length; ++i) {
            // 计算当前价格与前一天价格的差值，如果差值大于0，则将差值累加到最大利润中
            ans += Math.max(0, prices[i] - prices[i - 1]);
        }
        // 返回最大利润
        return ans;
    }
}
```

# 55.跳跃游戏

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

示例  1:

- 输入: [2,3,1,1,4]
- 输出: true
- 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

示例  2:

- 输入: [3,2,1,0,4]

- 输出: false

- 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。

  **贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。

  局部最优推出全局最优，找不出反例，试试贪心！

  如图：

  <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230203105634.png" alt="img" style="zoom: 50%;" />

```java
// 定义一个名为Solution的类
class Solution {
    // 定义一个名为canJump的公共方法，返回值为布尔类型，参数为一个整型数组nums
    public boolean canJump(int[] nums) {
        // 定义一个整型变量cover，初始值为0，表示当前能够覆盖的最远距离
        int cover = 0;
        // 使用for循环遍历数组nums，循环条件为i小于等于cover
        for (int i = 0; i <= cover; i++) {
            // 更新cover的值，取当前cover和i+nums[i]的较大值
            cover = Math.max(cover, i + nums[i]);
            // 如果cover大于等于数组长度减1，说明可以跳到最后一个位置，返回true
            if (cover >= nums.length - 1) {
                return true;
            }
        }
        // 循环结束后，如果没有返回true，则返回false
        return false;
    }
}
```

# 45.跳跃游戏II

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:

- 输入: [2,3,1,1,4]
- 输出: 2
- 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳  1 步，然后跳  3 步到达数组的最后一个位置。

说明: 假设你总是可以到达数组的最后一个位置。

```java
/**
 * 跳跃游戏 II
 */
class Solution {
    /**
     * 计算跳跃到最后一个位置所需的最小步数
     * @param nums 跳跃数组
     * @return 最小步数
     */
    public int jump(int[] nums) {
        int cur = 0; // 当前能够到达的最远位置
        int next = 0; // 下一步能够到达的最远位置
        int result = 0; // 最小步数
        for (int i = 0; i < nums.length - 1; i++){
            next = Math.max(next, i + nums[i]); // 更新下一步能够到达的最远位置
            if (i == cur){
                cur = next; // 更新当前能够到达的最远位置
                result++; // 步数加一
            }
            if (cur >= nums.length - 1){
                return result; // 如果当前能够到达的最远位置已经超过或等于最后一个位置，则返回最小步数
            }
        }
        return  result;
    }
}
```

# 1005. K次取反后最大化的数组和

给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）

以这种方式修改数组后，返回数组可能的最大和。

示例 1：

- 输入：A = [4,2,3], K = 1
- 输出：5
- 解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。

示例 2：

- 输入：A = [3,-1,0,2], K = 3
- 输出：6
- 解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。

示例 3：

- 输入：A = [2,-3,-1,5,-4], K = 2
- 输出：13
- 解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。

```java
class Solution {
    /**
     * 计算经过K次取反后的数组和的最大值
     * @param nums 给定的整数数组
     * @param k 取反的次数
     * @return 取反后的数组和的最大值
     */
    public int largestSumAfterKNegations(int[] nums, int k) {
        // 将数组转换为流，并按照绝对值的降序进行排序，然后再转换为整数数组
        nums = IntStream.of(nums).boxed().sorted((a, b) -> Math.abs(b) - Math.abs(a)).mapToInt(Integer::intValue).toArray();
        // 遍历数组，将负数取反，直到取反次数用完或者遍历完数组
        for (int i = 0; i < nums.length; i++){
            if (nums[i] < 0 && k > 0){
                nums[i] = -nums[i];
                k--;
            }
        }
        // 如果取反次数为奇数，则将数组中绝对值最小的数取反
        if (k % 2 == 1){
            nums[nums.length - 1] = -nums[nums.length - 1];
        }
        // 返回数组的和
        return Arrays.stream(nums).sum();
    }
}
```

# 134.加油站

在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

说明:

- 如果题目有解，该答案即为唯一答案。
- 输入数组均为非空数组，且长度相同。
- 输入数组中的元素均为非负数。

示例 1: 输入:

- gas = [1,2,3,4,5]
- cost = [3,4,5,1,2]

输出: 3 解释:

- 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
- 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
- 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
- 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
- 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
- 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
- 因此，3 可为起始索引。

```java
/**
 * 加油站问题
 */
class Solution {
    /**
     * 判断是否能够绕行一圈加油站
     * @param gas 加油站的汽油量数组
     * @param cost 到下一站需要消耗的汽油量数组
     * @return 能够绕行一圈返回起始加油站的索引，否则返回-1
     */
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int sum = 0; // 当前累计汽油量与消耗的差值
        int start = 0; // 起始加油站的索引
        int total = 0; // 所有加油站汽油量与消耗的差值
        for (int i = 0; i < gas.length; i++) {
            sum += gas[i] - cost[i]; // 更新累计差值
            total += gas[i] - cost[i]; // 更新总差值
            if (sum < 0) { // 如果累计差值小于0，说明从当前加油站出发无法到达下一站
                start = i + 1; // 更新起始加油站的索引为下一站
                sum = 0; // 重置累计差值为0
            }
        }
        return total >= 0 ? start : -1; // 如果总差值大于等于0，说明可以绕行一圈，返回起始加油站的索引，否则返回-1
    }
}
```

# 135.分发糖果

```java
/**
 * 分发糖果
 */
class Solution {
    public int candy(int[] ratings) {
        int [] candys = new int[ratings.length]; // 创建一个与ratings长度相同的数组，用于存储每个孩子分到的糖果数量
        candys[0] = 1; // 第一个孩子至少分到一个糖果
        for (int i = 1; i < ratings.length; i++) { // 从第二个孩子开始遍历
            if (ratings[i] > ratings[i - 1]) { // 如果当前孩子的评分高于前一个孩子
                candys[i] = candys[i - 1] + 1; // 分到的糖果数量比前一个孩子多一个
            } else  { // 如果当前孩子的评分不高于前一个孩子
                candys[i] = 1; // 分到的糖果数量为1
            }
        }
        for (int i = ratings.length - 2; i >= 0; i--) { // 从倒数第二个孩子开始遍历
            if (ratings[i] > ratings[i + 1]) { // 如果当前孩子的评分高于后一个孩子
                candys[i] = Math.max(candys[i], candys[i + 1] + 1); // 分到的糖果数量取当前孩子和后一个孩子分到糖果数量加1的较大值
            }
        }
        int sum = 0; // 初始化总糖果数量为0
        for (int i = 0; i < candys.length; i++) { // 遍历每个孩子分到的糖果数量
            sum += candys[i]; // 累加糖果数量
        }
        return sum; // 返回总糖果数量
    }
}
```

# 860.柠檬水找零

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five = 0; // 用于记录手中5元纸币的数量
        int ten = 0; // 用于记录手中10元纸币的数量
        
        for (int bill : bills) { // 遍历每一张纸币
            if (bill == 5) { // 如果是5元纸币
                five++; // 5元纸币数量加1
            } else if (bill == 10) { // 如果是10元纸币
                if (five == 0) { // 如果手中没有5元纸币，无法找零
                    return false; // 返回false
                }
                five--; // 用一张5元纸币找零
                ten++; // 10元纸币数量加1
            } else { // 如果是20元纸币
                if (ten > 0 && five > 0) { // 如果手中有一张10元纸币和一张5元纸币
                    ten--; // 用一张10元纸币找零
                    five--; // 用一张5元纸币找零
                } else if (five >= 3) { // 如果手中有至少3张5元纸币
                    five -= 3; // 用3张5元纸币找零
                } else { // 无法找零
                    return false; // 返回false
                }
            }
        }
        return true; // 所有纸币都能找零，返回true
    }
}
```

# 406.根据身高重建队列

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

示例 1：

- 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
- 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
- 解释：
  - 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
  - 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
  - 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
  - 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
  - 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
  - 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
  - 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

```java
/**
 * 根据身高重建队列
 */
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 根据身高降序排序，如果身高相同则按照k值升序排序
        Arrays.sort(people, (a, b) -> {
            if (a[0] != b[0]) {
                return b[0] - a[0];
            } else {
                return a[1] - b[1];
            }
        });
        // 创建一个动态数组用于存储重建后的队列
        List<int[]> res = new ArrayList<>();
        // 将每个人按照k值插入到对应的位置
        for (int[] p : people) {
            res.add(p[1], p);
        }
        // 将动态数组转换为二维数组并返回
        return res.toArray(new int[0][]);
    }
}
```

# 452.用最少数量的箭引爆气球

给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。

示例 1：

- 输入：points = [[10,16],[2,8],[1,6],[7,12]]
- 输出：2
- 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球

```java
// 用最少数量的箭引爆气球
class Solution {
    public int findMinArrowShots(int[][] points) {
        // 按照气球的起始位置进行排序
        Arrays.sort(points,(a,b)->Integer.compare(a[0],b[0]));
        int num = 1; // 初始化箭的数量为1
        for (int i = 1; i < points.length; i++){
            // 如果当前气球的起始位置大于前一个气球的结束位置，说明需要增加一支箭
            if(points[i][0] > points[i-1][1]){
                num++;
            }
            else{
                // 如果当前气球的起始位置小于等于前一个气球的结束位置，说明可以用一支箭引爆这两个气球
                // 更新当前气球的结束位置为两个气球中结束位置较小的那个
                points[i][1] = Math.min(points[i][1],points[i-1][1]);
            }
        }
        return num; // 返回最少需要的箭的数量
    }
}
```

# 435.无重叠区间

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

示例 1:

- 输入: [ [1,2], [2,3], [3,4], [1,3] ]
- 输出: 1
- 解释: 移除 [1,3] 后，剩下的区间没有重叠。

示例 2:

- 输入: [ [1,2], [1,2], [1,2] ]
- 输出: 2
- 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。

示例 3:

- 输入: [ [1,2], [2,3] ]
- 输出: 0
- 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。

```java
// 定义一个Solution类
class Solution {
    // 定义一个方法，用于计算无重叠区间的个数
    public int eraseOverlapIntervals(int[][] intervals) {
        // 如果intervals数组的长度为0，说明没有区间，直接返回0
        if (intervals.length == 0)
            return 0;
        // 对intervals数组按照区间的起始位置进行排序
        Arrays.sort(intervals,(a,b)->Integer.compare(a[0],b[0]));
        // 定义一个计数器，用于记录重叠区间的个数
        int count = 0;
        // 遍历intervals数组，从第二个区间开始判断是否重叠
        for (int i = 1; i < intervals.length; i++){
            // 如果当前区间的起始位置小于前一个区间的结束位置，说明存在重叠
            if (intervals[i][0] < intervals[i - 1][1]){
                // 计数器加1
                count++;
                // 更新当前区间的结束位置为前一个区间的结束位置和当前区间的结束位置中的较小值
                intervals[i][1] = Math.min(intervals[i - 1][1],intervals[i][1]);
            }
        }
        // 返回重叠区间的个数
        return count;
    }
}
```

# 763.划分字母区间

字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

示例：

- 输入：S = "ababcbacadefegdehijhklij"
- 输出：[9,7,8] 解释： 划分结果为 "ababcbaca", "defegde", "hijhklij"。 每个字母最多出现在一个片段中。 像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。



在遍历的过程中相当于是要找每一个字母的边界，**如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了**。此时前面出现过所有字母，最远也就到这个边界了。

可以分为如下两步：

- 统计每一个字符最后出现的位置
- 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点

如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201222191924417.png" alt="763.划分字母区间" style="zoom: 50%;" />

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        int [] lastIndex = new int[26]; // 创建一个长度为26的整型数组，用于存储每个字母在字符串中最后出现的位置
        for (int i = 0; i < s.length(); i++) {
            lastIndex[s.charAt(i) - 'a'] = i; // 将每个字母在字符串中最后出现的位置保存到对应的数组索引位置
        }
        List<Integer> res = new ArrayList<>(); // 创建一个整型列表，用于存储每个划分区间的长度
        int start = 0, end = 0; // 初始化划分区间的起始位置和结束位置
        for (int i = 0; i < s.length(); i++) {
            end = Math.max(end, lastIndex[s.charAt(i) - 'a']); // 更新划分区间的结束位置，取当前字母在字符串中最后出现的位置和当前结束位置的较大值
            if (i == end) { // 如果当前位置等于结束位置，说明当前位置是一个划分区间的结束位置
                res.add(end - start + 1); // 将当前划分区间的长度添加到结果列表中
                start = end + 1; // 更新划分区间的起始位置为结束位置的下一个位置
            }
        }
        return res; // 返回划分区间的长度列表
    }
}
```

# 56.合并区间

给出一个区间的集合，请合并所有重叠的区间。

示例 1:

- 输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
- 输出: [[1,6],[8,10],[15,18]]
- 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2:

- 输入: intervals = [[1,4],[4,5]]
- 输出: [[1,5]]
- 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 对二维数组按照每个子数组的第一个元素进行升序排序
        Arrays.sort(intervals,(a,b)->Integer.compare(a[0],b[0]));
        // 创建一个动态数组用于存储合并后的区间
        List<int[]> list = new ArrayList<>();
        // 将第一个区间加入到动态数组中
        list.add(intervals[0]);
        // 遍历剩余的区间
        for (int i = 1; i < intervals.length; i++) {
            // 如果当前区间的起始位置小于等于动态数组中最后一个区间的结束位置
            if (intervals[i][0] <= list.get(list.size() - 1)[1]){
                // 更新动态数组中最后一个区间的结束位置为当前区间的结束位置和动态数组中最后一个区间的结束位置的较大值
                list.get(list.size() - 1)[1] = Math.max(intervals[i][1],list.get(list.size() - 1)[1]);
            }else {
                // 否则，将当前区间加入到动态数组中
                list.add(intervals[i]);
            }
        }
        // 将动态数组转换为二维数组并返回
        return list.toArray(new int[0][]);
    }
}
```

# 738.单调递增的数字

给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

（当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。）

示例 1:

- 输入: N = 10
- 输出: 9

示例 2:

- 输入: N = 1234
- 输出: 1234

示例 3:

- 输入: N = 332
- 输出: 299

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        // 将整数转换为字符串
        String str =  Integer.toString(n);
        // 将字符串转换为字符数组
        char[] chars = str.toCharArray();
        // 初始化标志位为字符数组的长度
        int flag = chars.length;
        // 从字符数组的最后一个元素开始遍历
        for (int i = chars.length - 1; i > 0; i--) {
            // 如果当前元素的前一个元素大于当前元素
            if (chars[i - 1] > chars[i]) {
                // 更新标志位为当前元素的下标
                flag = i;
                // 将当前元素的前一个元素减1
                chars[i - 1]--;
            }
        }
        // 将标志位之后的所有元素都设置为9
        for (int i = flag; i < chars.length; i++) {
            chars[i] = '9';
        }
        // 将字符数组转换为整数并返回
        return Integer.parseInt(new String(chars));
    }
}
```

# 968.监控二叉树

```java
class Solution {
    int result = 0; // 记录需要安装监控的节点数量

    /**
     * 计算需要安装监控的节点数量
     * @param root 二叉树的根节点
     * @return 需要安装监控的节点数量
     */
    public int minCameraCover(TreeNode root) {
        if (root == null) {
            return result;
        }
        if (dfs(root) == 0) // 如果根节点的返回值为0，表示根节点未被覆盖，需要安装监控
            result++;
        return result;
    }

    /**
     * 深度优先搜索遍历二叉树
     * @param root 当前节点
     * @return 当前节点的状态，0表示未被覆盖，1表示有摄像头，2表示已被覆盖
     */
    private int dfs(TreeNode root) {
        if (root == null) {
            return 2; // 空节点不需要安装监控
        }
        int left = dfs(root.left); // 递归遍历左子树
        int right = dfs(root.right); // 递归遍历右子树
        if(left == 2 && right == 2){ // 如果左右子树都已被覆盖，则当前节点未被覆盖
            return 0;
        }
        if (left == 0 || right == 0) { // 如果左右子树中有一个节点未被覆盖，则需要当前节点有摄像头
            result++;
            return 1;
        }
        if (left == 1 || right == 1) { // 如果左右子树中有一个节点已经有摄像头，则当前节点已被覆盖
            return 2;
        }
        return -1;
    }
}
```

# 509.斐波那契数

```java
// 定义一个类Solution
class Solution {
    // 定义一个公共方法fib，返回类型为int，参数为n
    public int fib(int n) {
        // 如果n等于0，返回0
        if (n == 0)
            return 0;
        // 定义一个长度为n+1的整型数组dp
        int [] dp = new int[n + 1];
        // 初始化dp数组的第一个元素为0
        dp[0] = 0;
        // 初始化dp数组的第二个元素为1
        dp[1] = 1;
        // 循环计算dp数组的第i个元素，i从2到n
        for (int i = 2; i <= n; i++) {
            // dp[i]等于dp[i-1]和dp[i-2]的和
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        // 返回dp数组的第n个元素
        return dp[n];
    }
}
```

# 70.爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

- 输入： 2
- 输出： 2
- 解释： 有两种方法可以爬到楼顶。
  - 1 阶 + 1 阶
  - 2 阶

示例 2：

- 输入： 3
- 输出： 3
- 解释： 有三种方法可以爬到楼顶。
  - 1 阶 + 1 阶 + 1 阶
  - 1 阶 + 2 阶
  - 2 阶 + 1 阶

```java
// 定义一个Solution类
class Solution {
    // 定义一个方法，用于计算爬楼梯的方法数
    public int climbStairs(int n) {
        // 创建一个长度为n+1的数组dp，用于存储每个台阶的爬楼梯方法数
        int[] dp = new int[n + 1];
        // 初始化dp数组的前两个元素
        dp[0] = 1;
        dp[1] = 1;
        // 从第三个台阶开始，计算每个台阶的爬楼梯方法数
        for (int i = 2; i <= n; i++) {
            // 当前台阶的爬楼梯方法数等于前两个台阶的爬楼梯方法数之和
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        // 返回第n个台阶的爬楼梯方法数
        return dp[n];
    }
}
```

# 746.使用最小花费爬楼梯

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

示例 1：

- 输入：cost = [10, 15, 20]
- 输出：15
- 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。

示例 2：

- 输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
- 输出：6
- 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。

```java
/**
 * 使用最小花费爬楼梯
 */
class Solution {
    /**
     * 计算爬楼梯的最小花费
     * @param cost 每个楼梯的花费数组
     * @return 最小花费
     */
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length; // 楼梯的总数
        int[] dp = new int[n + 1]; // 动态规划数组，dp[i]表示到达第i个楼梯的最小花费
        dp[0] = 0; // 初始状态，到达第0个楼梯的最小花费为0
        dp[1] = 0; // 初始状态，到达第1个楼梯的最小花费为0
        for (int i = 2; i <= n; i++) {
            // 动态规划转移方程，到达第i个楼梯的最小花费为到达第i-1个楼梯的最小花费加上从第i-1个楼梯到第i个楼梯的花费，
            // 或者到达第i-2个楼梯的最小花费加上从第i-2个楼梯到第i个楼梯的花费，取两者中的较小值
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        // 返回到达最后一个楼梯的最小花费
        return dp[n];
    }
}
```

# 62.不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

示例 1：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210110174033215.png" alt="img" style="zoom:50%;" />

- 输入：m = 3, n = 7
- 输出：28

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int dp[][] = new int[m][n];  // 创建一个二维数组dp，用于存储路径数量
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;  // 初始化第一列的路径数量为1，因为只能向下走
        }
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;  // 初始化第一行的路径数量为1，因为只能向右走
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  // 动态规划，当前位置的路径数量等于上方位置和左方位置的路径数量之和
            }
        }
        return  dp[m - 1][n - 1];  // 返回右下角位置的路径数量
    }
}
```

# 63.不同路径II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210111204901338.png" alt="img" style="zoom:50%;" />

网格中的障碍物和空位置分别用 1 和 0 来表示。

示例 1：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210111204939971.png" alt="img" style="zoom:67%;" />

- 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
- 输出：2 

```java
/**
 * 该类实现了一个方法，用于计算从起点到终点的不同路径数量，其中包含障碍物的网格。
 */
class Solution {
    /**
     * 计算从起点到终点的不同路径数量
     * @param obstacleGrid 包含障碍物的网格
     * @return 不同路径数量
     */
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        // 获取网格的行数和列数
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        
        // 创建一个二维数组dp，用于存储到达每个位置的不同路径数量
        int[][] dp = new int[m][n];
        
        // 初始化第一列的路径数量
        for (int i = 0; i < m; i++) {
            if (obstacleGrid[i][0] == 1) {
                dp[i][0] = 0; // 如果第一列某个有障碍物，则无法到达该位置，路径数量为0
                break; // 如果遇到障碍物，后面的位置都无法到达，直接跳出循环
            }
            dp[i][0] = 1; // 如果第一列没有障碍物，则路径数量为1
        }
        
        // 初始化第一行的路径数量
        for (int i = 0; i < n; i++) {
            if (obstacleGrid[0][i] == 1) {
                dp[0][i] = 0; // 如果第一行有障碍物，则无法到达该位置，路径数量为0
                break; // 如果遇到障碍物，后面的位置都无法到达，直接跳出循环
            }
            dp[0][i] = 1; // 如果第一行没有障碍物，则路径数量为1
        }
        
        // 计算其他位置的路径数量
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) {
                    dp[i][j] = 0; // 如果当前位置有障碍物，则无法到达该位置，路径数量为0
                } else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // 如果当前位置没有障碍物，则路径数量等于上方位置和左方位置的路径数量之和
                }
            }
        }
        
        // 返回终点位置的路径数量
        return dp[m - 1][n - 1];
    }
}
```

# 343.整数拆分

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

- 输入: 2
- 输出: 1
- 解释: 2 = 1 + 1, 1 × 1 = 1。

示例 2:

- 输入: 10
- 输出: 36
- 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
- 说明: 你可以假设 n 不小于 2 且不大于 58。

```java
/**
 * 整数拆分
 */
class Solution {
    /**
     * 计算整数拆分的最大乘积
     * @param n 待拆分的整数
     * @return 拆分后的最大乘积
     */
    public int integerBreak(int n) {
        // 创建一个数组用于存储拆分后的最大乘积
        int [] dp = new int[n + 1];
        // 初始化拆分后的最大乘积
        dp[2] = 1;
        // 遍历从3到n的整数
        for (int i = 3; i <= n; i++) {
            // 遍历从1到i/2的整数，计算拆分后的最大乘积
            for (int j = 1; j <= i / 2; j++) {
                // 更新拆分后的最大乘积
                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
            }
        }
        // 返回拆分后的最大乘积
        return  dp[n];
    }
}
```

# 96.不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210113161941835.png" alt="img" style="zoom:50%;" />

```java
// 定义一个Solution类
class Solution {
    // 定义一个方法，用于计算不同的二叉搜索树的数量
    public int numTrees(int n) {
        // 创建一个长度为n+1的数组dp，用于存储计算结果
        int dp[] = new int[n + 1];
        // 初始化dp数组的前两个元素
        dp[0] = 1;
        dp[1] = 1;
        // 从i=2开始遍历到n，计算dp[i]的值
        for (int i = 2; i <= n; i++) {
            // 遍历j从1到i，计算dp[i]的值
            for (int j = 1; j <= i; j++) {
                // dp[i]的值等于dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        // 返回dp[n]，即不同的二叉搜索树的数量
        return dp[n];
    }
}
```

# 416.分割等和子集

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200

示例 1:

- 输入: [1, 5, 11, 5]
- 输出: true
- 解释: 数组可以分割成 [1, 5, 5] 和 [11].

示例 2:

- 输入: [1, 2, 3, 5]
- 输出: false
- 解释: 数组不能分割成两个元素和相等的子集.

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0; // 定义变量sum，用于存储数组nums的元素之和
        for (int num : nums) {
            sum += num; // 将数组nums的元素累加到sum中
        }
        if (sum % 2 != 0) { // 如果sum为奇数，则无法分割成两个相等的子集，返回false
            return false;
        }
        int target = sum / 2; // 计算目标值target，即每个子集的和
        int dp[] = new int[target + 1]; // 创建一个长度为target+1的数组dp，用于存储状态转移的结果
        for (int num : nums) { // 遍历数组nums的元素
            for (int i = target; i >= num; i--) { // 从target开始递减遍历
                dp[i] = Math.max(dp[i], dp[i - num] + num); // 更新dp数组的值，表示当前和为i的子集的最大和
            }
        }
        return dp[target] == target; // 如果dp[target]等于target，则说明存在一个子集的和为target，返回true；否则返回false
    }
}
```

# 1049.最后一块石头的重量II

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；

如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。

示例：

- 输入：[2,7,4,1,8,1]
- 输出：1

解释：

- 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
- 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
- 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
- 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0; // 初始化总重量为0
        for (int stone : stones) {
            sum += stone; // 计算石头的总重量
        }
        int target = sum / 2; // 目标重量为总重量的一半
        int[] dp = new int[target + 1]; // 创建一个长度为目标重量加1的数组
        for (int stone : stones) {
            for (int i = target; i >= stone; i--) {
                dp[i] = Math.max(dp[i], dp[i - stone] + stone); // 动态规划，计算最大重量
            }
        }
        return sum - 2 * dp[target]; // 返回最后一块石头的重量
    }
}
```

# 494.目标和

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

示例：

- 输入：nums: [1, 1, 1, 1, 1], S: 3
- 输出：5

解释：

- -1+1+1+1+1 = 3
- +1-1+1+1+1 = 3
- +1+1-1+1+1 = 3
- +1+1+1-1+1 = 3
- +1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。

假设加法的总和为x，那么减法对应的总和就是sum - x。

所以我们要求的是 x - (sum - x) = target

x = (target + sum) / 2

**此时问题就转化为，装满容量为x的背包，有几种方法**。

这里的x，就是bagSize，也就是我们后面要求的背包容量。



只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。

例如：dp[j]，j 为5，

- 已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。
- 已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。
- 已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包
- 已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包
- 已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包

那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0; // 定义变量sum，用于存储数组nums中所有元素的和
        for (int num : nums) {
            sum += num; // 将数组nums中的每个元素累加到sum中
        }
        if (target < 0 && sum < -target) // 如果目标值target小于0且sum小于-target，则返回0
            return 0;
        int left = (target + sum) / 2; // 计算目标值target和sum的和的一半，存储在变量left中
        if ((target + sum) % 2 != 0) // 如果目标值target和sum的和为奇数，则返回0
            return 0;
        int[] dp = new int[left + 1]; // 创建一个长度为left+1的数组dp，用于存储计算结果
        dp[0] = 1; // 将dp数组的第一个元素设置为1
        for (int num : nums) {
            for (int i = left; i >= num; i--) {
                dp[i] += dp[i - num]; // 根据动态规划的思想，更新dp数组的值，dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法
            }
        }
        return dp[left]; // 返回dp数组的最后一个元素，即为结果
    }
}
```

# 474.一和零

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

示例 1：

- 输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
- 输出：4
- 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。 其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3



**dp[i] [j]：最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]**。



dp[i] [j]可以由上一个strs里的字符串推导出来，假设strs里当前的字符串有zeroNum个0，oneNum个1。

dp[i] [j]就可以是 dp[i - zeroNum] [j - oneNum] + 1。

然后我们在遍历的过程中，取dp[i] [j]的最大值。

所以递推公式：dp[i] [j] = max(dp[i] [j], dp[i - zeroNum] [j - oneNum] + 1);

此时大家可以回想一下01背包的递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。

**这就是一个典型的01背包！** 只不过物品的重量有了两个维度而已。

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1]; // 创建一个二维数组dp，用于记录字符串中0和1的数量
        for (String str : strs) { // 遍历给定的字符串数组
            int zero = 0, one = 0; // 初始化0和1的数量为0
            for (char c : str.toCharArray()) { // 遍历当前字符串的每个字符
                if (c == '0') { // 如果字符为0
                    zero++; // 0的数量加1
                }
                if (c == '1') { // 如果字符为1
                    one++; // 1的数量加1
                }
            }
            for (int i = m; i >= zero; i--) { // 从m开始递减，表示当前剩余可用的0的数量
                for (int j = n; j >= one; j--) { // 从n开始递减，表示当前剩余可用的1的数量
                    dp[i][j] = Math.max(dp[i][j], dp[i - zero][j - one] + 1); // 更新dp数组中的值，取当前值和之前的值加1的较大值
                }
            }
        }
        return dp[m][n]; // 返回dp数组中最后一个元素的值，即为结果
    }
}
```

# 518.零钱兑换II

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

示例 1:

- 输入: amount = 5, coins = [1, 2, 5]
- 输出: 4

解释: 有四种方式可以凑成总金额:

- 5=5
- 5=2+2+1
- 5=2+1+1+1
- 5=1+1+1+1+1



01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历。

01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。

**在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！**



**求装满背包有几种方法，公式都是：dp[j] += dp[j - nums[i]];**

在求装满背包有几种方案的时候，认清遍历顺序是非常关键的。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

```java
// 零钱兑换 II
class Solution {
    public int change(int amount, int[] coins) {
        int [] dp = new int[amount + 1]; // 创建一个长度为amount+1的数组dp，用于存储兑换金额为i时的兑换方法数
        dp[0] = 1; // 初始化dp[0]为1，表示兑换金额为0时只有一种兑换方法，即不兑换
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount]; // 返回兑换金额为amount的兑换方法数
    }
}
```

# 377.组合总和IV

给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

示例:

- nums = [1, 2, 3]
- target = 4

所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。

本题题目描述说是求组合，但又说是可以元素相同顺序不同的组合算两个组合，**其实就是求排列！**

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

```java
/**
 * 组合总和 Ⅳ
 */
class Solution {
    /**
     * 计算组合总和
     * @param nums 给定的数字数组
     * @param target 目标总和
     * @return 组合总和的数量
     */
    public int combinationSum4(int[] nums, int target) {
        // 创建一个长度为target+1的数组dp，用于存储组合总和的数量
        int [] dp = new int[target + 1];
        // 初始化dp[0]为1，表示目标总和为0时有1种组合方式
        dp[0] = 1;
        // 遍历目标总和从1到target
        for (int i = 1; i <= target; i++) {
            // 遍历给定的数字数组
            for (int num : nums) {
                // 如果当前目标总和大于等于当前数字
                if (i >= num) {
                    // 将当前目标总和减去当前数字的组合总和数量累加到dp[i]中
                    dp[i] += dp[i - num];
                }
            }
        }
        // 返回目标总和为target时的组合总和数量
        return dp[target];
    }
}
```

# 322.零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

示例 1：

- 输入：coins = [1, 2, 5], amount = 11
- 输出：3
- 解释：11 = 5 + 5 + 1



本题求钱币最小个数，**那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数**。可以看作为求最小子集，而474.一和零是求最大子集，唯一不同是在递推公式上，本题递推公式为 dp[i] = Math.min(dp[i], dp[i - coin] + 1); 一和零的递推公式为dp[i] [j] = Math.max(dp[i] [j], dp[i - zero] [j - one] + 1); 基本上一样，只不过是max和min的区别。

所以本题并不强调集合是组合还是排列。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

```java
/**
 * 零钱兑换
 */
class Solution {
    /**
     * 计算兑换零钱的最少硬币数量
     * @param coins 零钱的面值数组
     * @param amount 需要兑换的金额
     * @return 最少硬币数量，如果无法兑换则返回-1
     */
    public int coinChange(int[] coins, int amount) {
        // 创建一个长度为amount+1的数组，用于存储兑换不同金额所需的最少硬币数量
        int [] dp = new int[amount + 1];
        // 考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。所以下标非0的元			素都是应该是最大值。
        Arrays.fill(dp, amount + 1);
        // 兑换0元不需要硬币
        dp[0] = 0;
        // 遍历每种硬币的面值
        for (int coin : coins) {
            // 从硬币的面值开始遍历到目标金额
            for (int i = coin; i <= amount; i++) {
                // 计算兑换金额i所需的最少硬币数量
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
        // 如果目标金额无法兑换，则返回-1，否则返回最少硬币数量
        return dp[amount] == amount + 1 ? -1 : dp[amount];
    }
}
```

# 279.完全平方数

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

示例 1：

- 输入：n = 12
- 输出：3
- 解释：12 = 4 + 4 + 4

示例 2：

- 输入：n = 13
- 输出：2
- 解释：13 = 4 + 9



**我来把题目翻译一下：完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？**

```java
/**
 * 完全平方数
 */
class Solution {
    /**
     * 计算n的最小完全平方数个数
     * @param n 目标数
     * @return 最小完全平方数个数
     */
    public int numSquares(int n) {
        // 创建一个长度为n+1的数组，用于存储每个数的最小完全平方数个数
        int [] dp = new int[n + 1];
        // 将数组dp的每个元素初始化为最大值，从递归公式dp[j] = min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，所以非0下标的dp[j]			一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖。
        Arrays.fill(dp, Integer.MAX_VALUE);
        // 将dp[0]设为0，表示0的最小完全平方数个数为0
        dp[0] = 0;
        // 遍历1到n的每个数
        for (int i = 1; i *  i <= n; i++) {
            // 遍历i的平方到n的每个数
            for (int j = i * i; j <= n; j++) {
                // 更新dp[j]的值为dp[j]和dp[j - i * i] + 1的较小值
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        // 返回dp[n]，即n的最小完全平方数个数
        return dp[n];
    }
}
```

# 139.单词拆分

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。

你可以假设字典中没有重复的单词。

示例 1：

- 输入: s = "leetcode", wordDict = ["leet", "code"]
- 输出: true
- 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

示例 2：

- 输入: s = "applepenapple", wordDict = ["apple", "pen"]
- 输出: true
- 解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
- 注意你可以重复使用字典中的单词。

示例 3：

- 输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
- 输出: false



单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。

拆分时可以重复使用字典中的单词，说明就是一个完全背包！

动规五部曲分析如下：

1. 确定dp数组以及下标的含义

**dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词**。

1. 确定递推公式

如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）。

所以递推公式是 if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。

1. dp数组如何初始化

从递推公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递推的根基，**dp[0]一定要为true**，否则递推下去后面都都是false了。

那么dp[0]有没有意义呢？

dp[0]表示如果字符串为空的话，说明出现在字典里。

但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。

下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。

1. 确定遍历顺序

题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。

还要讨论两层for循环的前后顺序。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

我在这里做一个总结：

求组合数：[动态规划：518.零钱兑换II (opens new window)](https://programmercarl.com/0518.零钱兑换II.html)

求排列数：[动态规划：377. 组合总和 Ⅳ (opens new window)](https://programmercarl.com/0377.组合总和.html)、[动态规划：70. 爬楼梯进阶版（完全背包） (opens new window)](https://programmercarl.com/0070.爬楼梯完全背包版本.html)

求最小数：[动态规划：322. 零钱兑换 (opens new window)](https://programmercarl.com/0322.零钱兑换.html)、[动态规划：279.完全平方数(opens new window)](https://programmercarl.com/0279.完全平方数.html)

而本题其实我们求的是排列数，为什么呢。 拿 s = "applepenapple", wordDict = ["apple", "pen"] 举例。

"apple", "pen" 是物品，那么我们要求 物品的组合一定是 "apple" + "pen" + "apple" 才能组成 "applepenapple"。

"apple" + "apple" + "pen" 或者 "pen" + "apple" + "apple" 是不可以的，那么我们就是强调物品之间顺序。

所以说，**本题一定是 先遍历 背包，再遍历物品**。

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1]; // 创建一个长度为s.length()+1的布尔数组dp，用于记录字符串s的拆分情况
        dp[0] = true; // 初始化dp[0]为true，表示空字符串可以被拆分
        for (int i = 1; i <= s.length(); i++) { // 遍历字符串s的每个字符
            for (int j = 0; j <= wordDict.size() - 1; j++) { // 遍历单词字典中的每个单词
                String word = wordDict.get(j); // 获取当前单词
                int len = word.length(); // 获取当前单词的长度
                if (i - len >= 0 && dp[i - len] && wordDict.contains(s.substring(i - len, i))) {
                    // 如果当前位置i减去当前单词长度len大于等于0，并且dp[i - len]为true，并且单词字典中包含从位置i-len到位置i的子字符串
                    dp[i] = true; // 则将dp[i]设置为true，表示字符串s可以被拆分
                    break; // 跳出内层循环
                }
            }
        }
        return dp[s.length()]; // 返回dp数组的最后一个元素，表示字符串s是否可以被拆分
    }
}
```

# 198.打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

- 示例 1：
- 输入：[1,2,3,1]
- 输出：4

解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。  偷窃到的最高金额 = 1 + 3 = 4 。



1.确定dp数组以及下标的含义

**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。

2.确定递推公式

决定dp[i]的因素就是第i房间偷还是不偷。

如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。

如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（**注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点**）

然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);

3.dp数组如何初始化

从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]

从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);

```java
class Solution {
    public int rob(int[] nums) {
        // 如果数组为空或者长度为0，则返回0
        if (nums == null || nums.length == 0) return 0;
        // 如果数组长度为1，则直接返回数组中的唯一元素
        if (nums.length == 1) return nums[0];

        // 创建一个与原数组长度相同的数组，用于存储每个位置的最大金额
        int[] dp = new int[nums.length];
        // 初始化dp数组的前两个元素
        dp[0] = nums[0];
        dp[1] = Math.max(dp[0], nums[1]);
        // 从第三个位置开始遍历原数组
        for (int i = 2; i < nums.length; i++) {
            // 当前位置的最大金额等于前一个位置的最大金额和前两个位置的最大金额加上当前位置的金额的较大值
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        // 返回dp数组的最后一个元素，即为最终的最大金额
        return dp[nums.length - 1];
    }
}
```

# 213.打家劫舍II

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着**第一个房屋和最后一个房屋是紧挨着的**。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。

示例 1：

- 输入：nums = [2,3,2]
- 输出：3
- 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。



对于一个数组，成环的话主要有如下三种情况：

- 情况一：考虑不包含首尾元素

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160748643-20230310134000692.jpg" alt="213.打家劫舍II" style="zoom:50%;" />

- 情况二：考虑包含首元素，不包含尾元素

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160821374-20230310134003961.jpg" alt="213.打家劫舍II1" style="zoom:50%;" />

- 情况三：考虑包含尾元素，不包含首元素

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160842491-20230310134008133.jpg" alt="213.打家劫舍II2" style="zoom:50%;" />

**注意我这里用的是"考虑"**，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！ 对于情况三，取nums[1] 和 nums[3]就是最大的。

**而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了**。

分析到这里，本题其实比较简单了。 剩下的和[198.打家劫舍 (opens new window)](https://programmercarl.com/0198.打家劫舍.html)就是一样的了。

```java
/**
 * 打家劫舍 II
 */
class Solution {
    /**
     * 计算最大金额
     * @param nums 房屋金额数组
     * @return 最大金额
     */
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return nums[0];
        }
        if (n == 2){
            return Math.max(nums[0],nums[1]);
        }
        // 返回两种情况下的最大金额
        return Math.max(robRange(nums, 0, nums.length - 2),
                robRange(nums, 1, nums.length - 1));
    }

    /**
     * 计算指定范围内的最大金额
     * @param nums 房屋金额数组
     * @param start 起始位置
     * @param end 结束位置
     * @return 最大金额
     */
    private int robRange(int[] nums, int start, int end) {
        int[] dp = new int[nums.length];
        dp[start] = nums[start];
        dp[start + 1] = Math.max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            // 动态规划计算最大金额
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[end];
    }
}
```

# 337.打家劫舍III

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210223173849619.png" alt="337.打家劫舍III" style="zoom:50%;" />

```java
/**
 * 打家劫舍 III
 */
class Solution {
    /**
     * 计算能够偷取的最大金额
     * @param root 根节点
     * @return 最大金额
     */
    public int rob(TreeNode root) {
        // 调用后序遍历方法，获取每个节点能够偷取的最大金额
        int[] dp = postorder(root);
        // 返回根节点能够偷取的最大金额
        return Math.max(dp[0], dp[1]);
    }

    /**
     * 后序遍历二叉树，计算每个节点能够偷取的最大金额
     * @param root 当前节点
     * @return 当前节点能够偷取的最大金额
     */
    private int[] postorder(TreeNode root) {
        // 如果当前节点为空，则返回金额为0的数组
        if (root == null) {
            return new int[]{0, 0};
        }
        // 递归调用后序遍历方法，计算左子树节点能够偷取的最大金额
        int[] left = postorder(root.left);
        // 递归调用后序遍历方法，计算右子树节点能够偷取的最大金额
        int[] right = postorder(root.right);
        // 创建一个长度为2的数组，用于存储当前节点能够偷取的最大金额，dp[0]表示当前节点不偷取，dp[1]表示当前节点偷取
        int[] dp = new int[2];
        // 当前节点不偷取时，左子树和右子树节点能够偷取的最大金额之和
        dp[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        // 当前节点偷取时，当前节点的值加上左子树不偷取和右子树不偷取的最大金额之和
        dp[1] = root.val + left[0] + right[0];
        // 返回当前节点能够偷取的最大金额
        return dp;
    }
}
```

# 121.买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

- 示例 1：
- 输入：[7,1,5,3,6,4]
- 输出：5
  解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
- 示例 2：
- 输入：prices = [7,6,4,3,1]
- 输出：0
  解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

```java
// 定义一个Solution类
class Solution {
    // 定义一个方法，用于计算买卖股票的最佳时机
    public int maxProfit(int[] prices) {
        // dp[i]表示考虑i天内卖出股票的最大利润
        int dp[] = new int[prices.length];
        // 定义一个变量，用于存储最低股票价格
        int min = prices[0];
        // 遍历股票价格数组
        for (int i = 1; i < prices.length; i++) {
            // min表示到i天为止的最小价格
            min = Math.min(min, prices[i]);
            // dp[i]为考虑i天内卖出股票的最大利润，分两种情况，一是第i天不卖，即dp[i-1]；二是第i天卖，即是prices[i] - min
            dp[i] = Math.max(dp[i - 1], prices[i] - min);
        }
        // 返回考虑最后一天的最大利润
        return dp[prices.length - 1];
    }
}
```

# 122.买卖股票的最佳时机II

- dp[i] 0] 表示第i天不持有股票所得现金。
- dp[i] [1] 表示第i天持有股票所得最多现金

如果第i天不持有股票即dp[i] [0]， 那么可以由两个状态推出来

- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [0]
- 第i天卖出股票，所得现金就是昨天持有股票的所得现金加去 今天的股票价格 即：dp[i - 1] [1] + prices[i]

如果第i天持有股票即dp[i] [1]的情况， 依然可以由两个状态推出来

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [1]
- 第i天买入股票，所得现金就是按照今天股票价格买入后所得现金即：dp[i - 1] [0] - prices[i]

```java
/**
 * 买卖股票的最佳时机 II
 */
class Solution {
    /**
     * 计算最大利润
     * @param prices 股票价格数组
     * @return 最大利润
     */
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];     // 创建二维数组存储状态

        dp[0][0] = 0;                   // 初始状态，第一天不持有股票，利润为0
        dp[0][1] = -prices[0];          // 初始状态，第一天持有股票，利润为负的第一天股票价格

        for (int i = 1; i < n; ++i) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);    // 第 i 天，不持有股票，取前一天不持有股票和前一天持有股票并在第i天卖出的最大利润
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);    // 第 i 天，持有股票，取前一天持有股票和前一天没有股票并在第i天买入的最大利润
        }

        return dp[n - 1][0];    // 卖出股票收益高于持有股票收益，因此取[0]
    }
}
```

# 123.买卖股票的最佳时机III

1. 确定dp数组以及下标的含义

一天一共就有五个状态，

​	0.没有操作 （其实我们也可以不设置这个状态）

​	1.第一次持有股票

​	2.第一次不持有股票

​	3.第二次持有股票

​	4.第二次不持有股票

dp[i] [j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。

需要注意：dp[i] [1]，**表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区**。

例如 dp[i] [1] ，并不是说 第i天一定买入股票，有可能 第 i-1天 就买入了，那么 dp[i] [1] 延续买入股票的这个状态。

1. 确定递推公式

达到dp[i][1]状态，有两个具体操作：

- 操作一：第i天买入股票了，那么dp[i] [1] = dp[i-1] [0] - prices[i]
- 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1] 1]

那么dp[i] [1]究竟选 dp[i-1] [0] - prices[i]，还是dp[i - 1] [1]呢？

一定是选最大的，所以 dp[i] [1] = max(dp[i-1] [0] - prices[i], dp[i - 1] [1]);

同理dp[i][2]也有两个操作：

- 操作一：第i天卖出股票了，那么dp[i] [2] = dp[i - 1] [1] + prices[i]
- 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1] [2]

所以dp[i] [2] = max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])

同理可推出剩下状态部分：

dp[i] [3] = max(dp[i - 1] [3], dp[i - 1] [2] - prices[i]);

dp[i] [4] = max(dp[i - 1] [4], dp[i - 1] [3] + prices[i]);

1. dp数组如何初始化

第0天没有操作，这个最容易想到，就是0，即：dp[0] [0] = 0;

第0天做第一次买入的操作，dp[0] [1] = -prices[0];

第0天做第一次卖出的操作，这个初始值应该是多少呢？

此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，所以dp[0] [2] = 0;

第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？

第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。

所以第二次买入操作，初始化为：dp[0] [3] = -prices[0];

同理第二次卖出初始化dp[0] [4] = 0;

1. 确定遍历顺序

从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。

```java
/**
 * 买卖股票的最佳时机 III
 */
class Solution {
    public int maxProfit(int[] prices) {
        // 创建一个二维数组dp，用于记录每天的最大利润
        int dp[][] = new int[prices.length][5];
        // 初始化第一天的利润
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        // 遍历每一天的价格
        for (int i = 1; i < prices.length; i++) {
            // 第i天第一次持有股票的最大利润，可以选择继续持有或者买入
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            // 第i天第一次不持有股票的最大利润，可以选择继续不持有或者卖出
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            // 第i天第二次持有股票的最大利润，可以选择继续持有或者买入
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            // 第i天第二次不持有股票的最大利润，可以选择继续不持有或者卖出
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        // 返回最后一天不持有股票的最大利润
        return dp[prices.length - 1][4];
    }
}
```

# 188.买卖股票的最佳时机IV

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

- 示例 1：
- 输入：k = 2, prices = [2,4,1]
- 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2。
- 示例 2：
- 输入：k = 2, prices = [3,2,6,5,0,3]
- 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。



动规五部曲，分析如下：

1. 确定dp数组以及下标的含义

在[动态规划：123.买卖股票的最佳时机III (opens new window)](https://programmercarl.com/0123.买卖股票的最佳时机III.html)中，我是定义了一个二维dp数组，本题其实依然可以用一个二维dp数组。

使用二维数组 dp[i] [j] ：第i天的状态为j，所剩下的最大现金是dp[i] [j]

j的状态表示为：

- 0 表示不操作
- 1 第一次买入
- 2 第一次卖出
- 3 第二次买入
- 4 第二次卖出
- .....

**大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入**。

题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。

所以二维dp数组的C++定义为：

```cpp
vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
```

1. 确定递推公式

还要强调一下：dp[i] [1]，**表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区**。

达到dp[i] [1]状态，有两个具体操作：

- 操作一：第i天买入股票了，那么dp[i] [1] = dp[i - 1] [0] - prices[i]
- 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i] [1] = dp[i - 1] [1]

选最大的，所以 dp[i] [1] = max(dp[i - 1] [0] - prices[i], dp[i - 1] [1]);

同理dp[i] [2]也有两个操作：

- 操作一：第i天卖出股票了，那么dp[i] [2] = dp[i - 1] [1] + prices[i]
- 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i] [2] = dp[i - 1] [2]

所以dp[i] [2] = max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])

同理可以类比剩下的状态，代码如下：

```cpp
for (int j = 0; j < 2 * k - 1; j += 2) {
    dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
    dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])
}

```

**本题和[动态规划：123.买卖股票的最佳时机III (opens new window)](https://programmercarl.com/0123.买卖股票的最佳时机III.html)最大的区别就是这里要类比j为奇数是买，偶数是卖的状态**。

1. dp数组如何初始化

第0天没有操作，这个最容易想到，就是0，即：dp[0] [0] = 0;

第0天做第一次买入的操作，dp[0] [1] = -prices[0];

第0天做第一次卖出的操作，这个初始值应该是多少呢？

此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，所以dp[0] [2] = 0;

第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？

第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。

所以第二次买入操作，初始化为：dp[0] [3] = -prices[0];

第二次卖出初始化dp[0] [4] = 0;

**所以同理可以推出dp[0] [j]当j为奇数的时候都初始化为 -prices[0]**

代码如下：

```cpp
for (int j = 1; j < 2 * k; j += 2) {
    dp[0][j] = -prices[0];
}
```

**在初始化的地方同样要类比j为偶数是卖、奇数是买的状态**。

1. 确定遍历顺序

从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int dp[][] = new int[prices.length][2*k+1]; // 创建一个二维数组dp，用于存储买卖股票的最大利润
        for (int i = 1; i < 2*k+1; i += 2) { // 初始化第一天的买入状态
            dp[0][i] = -prices[0]; // 第一天买入股票的利润为负的股票价格
        }
        for (int i = 1; i < prices.length; i++) { // 遍历每一天的股票价格
            for (int j = 1; j < 2*k+1; j+=2){ // 遍历每一天的买入和卖出状态
                dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1] - prices[i]); // 计算买入股票的最大利润
                dp[i][j+1] = Math.max(dp[i-1][j+1], dp[i-1][j] + prices[i]); // 计算卖出股票的最大利润
            }
        }
        return dp[prices.length - 1][2*k]; // 返回最后一天卖出股票的最大利润
    }
}
```

# 309.最佳买卖股票时机含冷冻期

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例:

- 输入: [1,2,3,0,2]
- 输出: 3
- 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]



动规五部曲，分析如下：

1. 确定dp数组以及下标的含义

dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。

**其实本题很多同学搞的比较懵，是因为出现冷冻期之后，状态其实是比较复杂度**，例如今天买入股票、今天卖出股票、今天是冷冻期，都是不能操作股票的。

具体可以区分出如下四个状态：

- 状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
- 不持有股票状态，这里就有两种卖出股票状态
  - 状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
  - 状态三：今天卖出股票
- 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/518d5baaf33f4b2698064f8efb42edbf.png" alt="img" style="zoom: 67%;" />

j的状态为：

- 0：状态一
- 1：状态二
- 2：状态三
- 3：状态四

很多题解为什么讲的比较模糊，是因为把这四个状态合并成三个状态了，其实就是把状态二和状态四合并在一起了。

从代码上来看确实可以合并，但从逻辑上分析合并之后就很难理解了，所以我下面的讲解是按照这四个状态来的，把每一个状态分析清楚。

如果大家按照代码随想录顺序来刷的话，会发现 买卖股票最佳时机 1，2，3，4 的题目讲解中

- [动态规划：121.买卖股票的最佳时机(opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)
- [动态规划：122.买卖股票的最佳时机II(opens new window)](https://programmercarl.com/0122.买卖股票的最佳时机II（动态规划）.html)
- [动态规划：123.买卖股票的最佳时机III(opens new window)](https://programmercarl.com/0123.买卖股票的最佳时机III.html)
- [动态规划：188.买卖股票的最佳时机IV(opens new window)](https://programmercarl.com/0188.买卖股票的最佳时机IV.html)

「今天卖出股票」我是没有单独列出一个状态的归类为「不持有股票的状态」，而本题为什么要单独列出「今天卖出股票」 一个状态呢？

因为本题我们有冷冻期，而冷冻期的前一天，只能是 「今天卖出股票」状态，如果是 「不持有股票状态」那么就很模糊，因为不一定是 卖出股票的操作。

如果没有按照 代码随想录 顺序去刷的录友，可能看这里的讲解 会有点困惑，建议把代码随想录本篇之前股票内容的讲解都看一下，领会一下每天 状态的设置。

**注意这里的每一个状态，例如状态一，是持有股票股票状态并不是说今天一定就买入股票，而是说保持买入股票的状态即：可能是前几天买入的，之后一直没操作，所以保持买入股票的状态**。

1. 确定递推公式

**达到买入股票状态**（状态一）即：dp[i] [0]，有两个具体操作：

- 操作一：前一天就是持有股票状态（状态一），dp[i] [0] = dp[i - 1] [0]
- 操作二：今天买入了，有两种情况
  - 前一天是冷冻期（状态四），dp[i - 1] [3] - prices[i]
  - 前一天是保持卖出股票的状态（状态二），dp[i - 1] [1] - prices[i]

那么dp[i] [0] = max(dp[i - 1] [0], dp[i - 1] [3] - prices[i], dp[i - 1] [1] - prices[i]);

**达到保持卖出股票状态**（状态二）即：dp[i][1]，有两个具体操作：

- 操作一：前一天就是状态二
- 操作二：前一天是冷冻期（状态四）

dp[i] [1] = max(dp[i - 1] [1], dp[i - 1] [3]);

**达到今天就卖出股票状态**（状态三），即：dp[i] [2] ，只有一个操作：

昨天一定是持有股票状态（状态一），今天卖出

即：dp[i] [2] = dp[i - 1] [0] + prices[i];

**达到冷冻期状态**（状态四），即：dp[i][3]，只有一个操作：

昨天卖出了股票（状态三）

dp[i] [3] = dp[i - 1] [2];

综上分析，递推代码如下：

```cpp
dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
dp[i][2] = dp[i - 1][0] + prices[i];
dp[i][3] = dp[i - 1][2];
```

1. dp数组如何初始化

这里主要讨论一下第0天如何初始化。

如果是持有股票状态（状态一）那么：dp[0] [0] = -prices[0]，一定是当天买入股票。

保持卖出股票状态（状态二），这里其实从 「状态二」的定义来说 ，很难明确应该初始多少，这种情况我们就看递推公式需要我们给他初始成什么数值。

如果i为1，第1天买入股票，那么递归公式中需要计算 dp[i - 1] [1] - prices[i] ，即 dp[0] [1] - prices[1]，那么大家感受一下 dp[0] [1] （即第0天的状态二）应该初始成多少，只能初始为0。想一想如果初始为其他数值，是我们第1天买入股票后 手里还剩的现金数量是不是就不对了。

今天卖出了股票（状态三），同上分析，dp[0] [2]初始化为0，dp[0] [3]也初始为0。

1. 确定遍历顺序

从递归公式上可以看出，dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。

```java
/**
 * 买卖股票的最佳时机含冷冻期
 */
class Solution {
    public int maxProfit(int[] prices) {
        // 创建二维数组dp，用于记录每天的股票状态
        int dp[][] = new int[prices.length][4];
        // 初始化第一天的股票状态
        dp[0][0] = -prices[0];
        // 遍历每一天的股票状态
        for (int i = 1; i < prices.length; i++) {
            // 计算第i天持有股票的最大收益
            dp[i][0] = Math.max(dp[i -1][0], Math.max(dp[i - 1][1] - prices[i], dp[i - 1][3] - prices[i]));
            // 计算第i天保持不持有股票的最大收益
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
            // 计算第i天卖出的最大收益
            dp[i][2] = dp[i - 1][0] + prices[i];
            // 计算第i天处于冷冻期的最大收益
            dp[i][3] = dp[i - 1][2];
        }
        // 返回最后一天的最大收益
        return Math.max(dp[prices.length - 1][1], Math.max(dp[prices.length - 1][2], dp[prices.length - 1][3]));
    }
}
```

# 714.买卖股票的最佳时机含手续费

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

示例 1:

- 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
- 输出: 8

解释: 能够达到的最大利润:

- 在此处买入 prices[0] = 1
- 在此处卖出 prices[3] = 8
- 在此处买入 prices[4] = 4
- 在此处卖出 prices[5] = 9
- 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.



```java
/**
 * 买卖股票的最佳时机含手续费
 */
class Solution {
    /**
     * 计算最大利润
     * @param prices 股票价格数组
     * @param fee 手续费
     * @return 最大利润
     */
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        dp[0][0] = -prices[0]; // 第一天持有股票的最大利润
        dp[0][1] = 0; // 第一天不持有股票的最大利润
        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 当前持有股票的最大利润
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee); // 当前不持有股票的最大利润
        }
        return dp[n - 1][1]; // 返回最后一天不持有股票的最大利润
    }
}
```

# 300.最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：

- 输入：nums = [10,9,2,5,3,7,101,18]
- 输出：4
- 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。



**dp[i]表示以nums[i]结尾的最长递增子序列的长度**

为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在 做 递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。

1. 状态转移方程

位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。

所以：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);

**注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值**。

1. dp[i]的初始化

每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.

1. 确定遍历顺序

dp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。

j其实就是遍历0到i-1，那么是从前到后，还是从后到前遍历都无所谓，只要吧 0 到 i-1 的元素都遍历了就行了。 所以默认习惯 从前向后遍历。

```java
/**
 * 最长递增子序列问题
 */
class Solution {
    /**
     * 计算最长递增子序列的长度
     * @param nums 给定的整数数组
     * @return 最长递增子序列的长度
     */
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n]; // dp数组用于记录以当前元素结尾的最长递增子序列的长度
        Arrays.fill(dp, 1); // 初始化dp数组为1，因为每个元素本身就是一个递增子序列
        int res = 1; // 记录最长递增子序列的长度
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) { // 如果当前元素大于前面的元素，则可以将当前元素加入到以前面元素结尾的递增子序列中
                    dp[i] = Math.max(dp[i], dp[j] + 1); // 更新以当前元素结尾的最长递增子序列的长度
                }
            }
            res = Math.max(res, dp[i]); // 更新最长递增子序列的长度
        }
        return res;
    }
}
```

# 674. 最长连续递增序列

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

示例 1：

- 输入：nums = [1,3,5,4,7]
- 输出：3
- 解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。



动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

**dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]**。

注意这里的定义，一定是以下标i为结尾，并不是说一定以下标0为起始位置。

1. 确定递推公式

如果 nums[i] > nums[i - 1]，那么以 i 为结尾的连续递增的子序列长度 一定等于 以i - 1为结尾的连续递增的子序列长度 + 1 。

即：dp[i] = dp[i - 1] + 1;

**注意这里就体现出和[动态规划：300.最长递增子序列 (opens new window)](https://programmercarl.com/0300.最长上升子序列.html)的区别！**

因为本题要求连续递增子序列，所以就只要比较nums[i]与nums[i - 1]，而不用去比较nums[j]与nums[i] （j是在0到i之间遍历）。

既然不用j了，那么也不用两层for循环，本题一层for循环就行，比较nums[i] 和 nums[i - 1]。

这里大家要好好体会一下！

1. dp数组如何初始化

以下标i为结尾的连续递增的子序列长度最少也应该是1，即就是nums[i]这一个元素。

所以dp[i]应该初始1;

1. 确定遍历顺序

从递推公式上可以看出， dp[i + 1]依赖dp[i]，所以一定是从前向后遍历。

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int n = nums.length; // 数组长度
        int dp[] = new int[n]; // dp数组，用于存储最长连续递增子序列的长度
        Arrays.fill(dp, 1); // 将dp数组初始化为1，表示每个元素自身就是一个递增子序列
        int res = 1; // 最长连续递增子序列的长度，默认为1
        for (int i = 1; i < n; i++) { // 遍历数组
            if (nums[i] > nums[i - 1]) { // 如果当前元素大于前一个元素
                // 则将dp[i]更新为dp[i-1]+1，表示以当前元素结尾的最长连续递增子序列的长度
                dp[i] = dp[i - 1] + 1;
            }
            // 更新最长连续递增子序列的长度
            res = Math.max(res, dp[i]);
        }
        return res; // 返回最长连续递增子序列的长度
    }
}
```

# 718. 最长重复子数组

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

示例：

输入：

- A: [1,2,3,2,1]
- B: [3,2,1,4,7]
- 输出：3
- 解释：长度最长的公共子数组是 [3, 2, 1] 。



1. 确定dp数组（dp table）以及下标的含义

dp[i] [j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i] [j]。 （**特别注意**： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）

此时细心的同学应该发现，那dp[0] [0]是什么含义呢？总不能是以下标-1为结尾的A数组吧。

其实dp[i] [j]的定义也就决定着，我们在遍历dp[i] [j]的时候i 和 j都要从1开始。

那有同学问了，我就定义dp[i] [j]为 以下标i为结尾的A，和以下标j 为结尾的B，最长重复子数组长度。不行么？

行倒是行！ 但实现起来就麻烦一点，需要单独处理初始化部分，在本题解下面的拓展内容里，我给出了 第二种 dp数组的定义方式所对应的代码和讲解，大家比较一下就了解了。

1. 确定递推公式

根据dp[i] [j]的定义，dp[i] [j]的状态只能由dp[i - 1] [j - 1]推导出来。

即当A[i - 1] 和B[j - 1]相等的时候，dp[i] [j] = dp[i - 1] [j - 1] + 1;

根据递推公式可以看出，遍历i 和 j 要从1开始！

1. dp数组如何初始化

根据dp[i] [j]的定义，dp[i] [0] 和dp[0] [j]其实都是没有意义的！

但dp[i] [0] 和dp[0] [j]要初始值，因为 为了方便递归公式dp[i] [j] = dp[i - 1] [j - 1] + 1;

所以dp[i] [0] 和dp[0] [j]初始化为0。

举个例子A[0]如果和B[0]相同的话，dp[1] [1] = dp[0] [0] + 1，只有dp[0] [0]初始为0，正好符合递推公式逐步累加起来。

1. 确定遍历顺序

外层for循环遍历A，内层for循环遍历B。

那又有同学问了，外层for循环遍历B，内层for循环遍历A。不行么？

也行，一样的，我这里就用外层for循环遍历A，内层for循环遍历B了。

同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把dp[i] [j]的最大值记录下来。

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int n1 = nums1.length; // 数组nums1的长度
        int n2 = nums2.length; // 数组nums2的长度
        int[][] dp = new int[n1 + 1][n2 + 1]; // 创建一个二维数组dp，用于存储最长公共子数组的长度
        int max = 0; // 最长公共子数组的长度
        for (int i = 1; i <= n1; i++) { // 遍历数组nums1
            for (int j = 1; j <= n2; j++) { // 遍历数组nums2
                if (nums1[i - 1] == nums2[j - 1]) { // 如果nums1的第i-1个元素等于nums2的第j-1个元素
                    dp[i][j] = dp[i - 1][j - 1] + 1; // 最长公共子数组的长度加1
                    max = Math.max(max, dp[i][j]); // 更新最长公共子数组的长度
                }
            }
        }
        return max; // 返回最长公共子数组的长度
    }
}
```

# 1143.最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

示例 1:

- 输入：text1 = "abcde", text2 = "ace"
- 输出：3
- 解释：最长公共子序列是 "ace"，它的长度为 3。



dp[i] [j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]

有同学会问：为什么要定义长度为[0, i - 1]的字符串text1，定义为长度为[0, i]的字符串text1不香么？

这样定义是为了后面代码实现方便，如果非要定义为长度为[0, i]的字符串text1也可以，我在 [动态规划：718. 最长重复子数组 (opens new window)](https://programmercarl.com/0718.最长重复子数组.html)中的「拓展」里 详细讲解了区别所在，其实就是简化了dp数组第一行和第一列的初始化逻辑。

1. 确定递推公式

主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同

如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i] [j] = dp[i - 1] [j - 1] + 1;

如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。

即：dp[i] [j] = max(dp[i - 1] [j], dp[i] [j - 1]);

代码如下：

```cpp
if (text1[i - 1] == text2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1] + 1;
} else {
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
}
```

1. dp数组如何初始化

先看看dp[i][0]应该是多少呢？

test1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i] [0] = 0;

同理dp[0] [j]也是0。

其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。

代码：

```text
vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
```

1

1. 确定遍历顺序

从递推公式，可以看出，有三个方向可以推出dp[i] [j]，如图：

![1143.最长公共子序列](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204115139616.jpg)

那么为了在递推的过程中，这三个方向都是经过计算的数值，所以要从前向后，从上到下来遍历这个矩阵。

```java
/**
 * 最长公共子序列问题
 */
class Solution {
    /**
     * 计算两个字符串的最长公共子序列的长度
     * @param text1 第一个字符串
     * @param text2 第二个字符串
     * @return 最长公共子序列的长度
     */
    public int longestCommonSubsequence(String text1, String text2) {
        // 创建一个二维数组dp，用于保存最长公共子序列的长度
        int [][] dp = new int[text1.length() + 1][text2.length() + 1];
        // 遍历text1和text2的所有字符
        for (int i = 1; i <= text1.length(); i++) {
            for (int j = 1; j <= text2.length(); j++) {
                // 如果当前字符相等，则最长公共子序列的长度加1
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 如果当前字符不相等，则最长公共子序列的长度为前一个字符的最长公共子序列长度
                    // 和当前字符的前一个字符的最长公共子序列长度中的较大值
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        // 返回text1和text2的最长公共子序列的长度
        return dp[text1.length()][text2.length()];
    }
}
```

# 1035.不相交的线

我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。

现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。

以这种方法绘制线条，并返回我们可以绘制的最大连线数。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021032116363533.png" alt="1035.不相交的线" style="zoom:50%;" />

**本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！**

```java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        // 创建一个二维数组dp，用于存储最大不相交线的数量
        int [][] dp = new int[nums1.length + 1][nums2.length + 1];
        // 遍历nums1数组
        for (int i = 1; i <= nums1.length; i++) {
            // 遍历nums2数组
            for (int j = 1; j <= nums2.length; j++) {
                // 如果nums1[i - 1]和nums2[j - 1]相等
                if (nums1[i - 1] == nums2[j - 1]) {
                    // dp[i][j]等于dp[i - 1][j - 1]加1
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 否则，dp[i][j]等于dp[i - 1][j]和dp[i][j - 1]中的较大值
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        // 返回dp[nums1.length][nums2.length]，即最大不相交线的数量
        return dp[nums1.length][nums2.length];
    }
}
```

# 53. 最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

- 输入: [-2,1,-3,4,-1,2,1,-5,4]
- 输出: 6
- 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。



动规五部曲如下：

1. 确定dp数组（dp table）以及下标的含义

**dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]**。

1. 确定递推公式

dp[i]只有两个方向可以推出来：

- dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和
- nums[i]，即：从头开始计算当前连续子序列和

一定是取最大的，所以dp[i] = max(dp[i - 1] + nums[i], nums[i]);

1. dp数组如何初始化

从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。

dp[0]应该是多少呢?

根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] = nums[0]。

1. 确定遍历顺序

递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。

```java
/**
 * 计算最大子数组和的解决方案类
 */
class Solution {
    /**
     * 计算最大子数组和
     * @param nums 给定的整数数组
     * @return 最大子数组和
     */
    public int maxSubArray(int[] nums) {
        int res = nums[0]; // 初始化最大子数组和为数组的第一个元素
        int[] dp = new int[nums.length]; // 创建一个与给定数组长度相同的数组dp，用于存储子问题的解
        dp[0] = nums[0]; // 初始化dp数组的第一个元素为给定数组的第一个元素
        for (int i = 1; i < nums.length; i++) { // 从第二个元素开始遍历给定数组
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); // 计算当前位置的最大子数组和，取当前元素与前一个元素的和与当前元素中的较大值
            res = Math.max(res, dp[i]); // 更新最大子数组和
        }
        return res; // 返回最大子数组和
        
        
    }
}
```

# 392.判断子序列

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

示例 1：

- 输入：s = "abc", t = "ahbgdc"
- 输出：true

示例 2：

- 输入：s = "axc", t = "ahbgdc"
- 输出：false



动态规划五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

**dp[i] [j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i] [j]**。

注意这里是判断s是否为t的子序列。即t的长度是大于等于s的。

有同学问了，为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？

为什么这么定义我在 [718. 最长重复子数组 (opens new window)](https://programmercarl.com/0718.最长重复子数组.html)中做了详细的讲解。

其实用i来表示也可以！

但我统一以下标i-1为结尾的字符串来计算，这样在下面的递归公式中会容易理解一些，如果还有疑惑，可以继续往下看。

1. 确定递推公式

在确定递推公式的时候，首先要考虑如下两种操作，整理如下：

- if (s[i - 1] == t[j - 1])
  - t中找到了一个字符在s中也出现了
- if (s[i - 1] != t[j - 1])
  - 相当于t要删除元素，继续匹配

if (s[i - 1] == t[j - 1])，那么dp[i] [j] = dp[i - 1] [j - 1] + 1;，因为找到了一个相同的字符，相同子序列长度自然要在dp[i-1] [j-1]的基础上加1（**如果不理解，在回看一下dp[i] [j]的定义**）

if (s[i - 1] != t[j - 1])，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么dp[i] [j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i] [j] = dp[i] [j - 1];

其实这里 大家可以发现和 [1143.最长公共子序列 (opens new window)](https://programmercarl.com/1143.最长公共子序列.html)的递推公式基本那就是一样的，区别就是 本题 如果删元素一定是字符串t，而 1143.最长公共子序列 是两个字符串都可以删元素。

1. dp数组如何初始化

从递推公式可以看出dp[i] [j]都是依赖于dp[i - 1] [j - 1] 和 dp[i] [j - 1]，所以dp[0] [0]和dp[i] [0]是一定要初始化的。

这里大家已经可以发现，在定义dp[i][j]含义的时候为什么要**表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i] [j]**。

因为这样的定义在dp二维矩阵中可以留出初始化的区间，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210303173115966.png" alt="392.判断子序列" style="zoom: 67%;" />

如果要是定义的dp[i][j]是以下标i为结尾的字符串s和以下标j为结尾的字符串t，初始化就比较麻烦了。

dp[i][0] 表示以下标i-1为结尾的字符串，与空字符串的相同子序列长度，所以为0. dp[0][j]同理。

```cpp
vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
```

1

1. 确定遍历顺序

同理从递推公式可以看出dp[i][j]都是依赖于dp[i - 1] [j - 1] 和 dp[i] [j - 1]，那么遍历顺序也应该是从上到下，从左到右

如图所示：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210303172354155.jpg" alt="392.判断子序列1" style="zoom:67%;" />

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int [][]dp = new int[s.length() + 1][t.length() + 1];  // 创建一个二维数组dp，用于存储子序列匹配的结果
        for (int i = 1; i <= s.length(); i++) {  // 遍历字符串s的每个字符
            for (int j = 1; j <= t.length(); j++) {  // 遍历字符串t的每个字符
                if (s.charAt(i - 1) == t.charAt(j - 1)) {  // 如果s的第i个字符与t的第j个字符相等
                    dp[i][j] = dp[i - 1][j - 1] + 1;  // 则将dp[i][j]的值设为dp[i-1][j-1]的值加1
                } else {
                    dp[i][j] =  dp[i][j - 1];  // 否则，将dp[i][j]的值设为dp[i][j-1]的值
                }
            }
        }
        return dp[s.length()][t.length()] == s.length();  // 返回dp[s.length()][t.length()]是否等于s的长度，即判断s是否为t的子序列
    }
}
```

# 115.不同的子序列

给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

题目数据保证答案符合 32 位带符号整数范围。

<img src="https://code-thinking.cdn.bcebos.com/pics/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E7%A4%BA%E4%BE%8B.jpg" alt="115.不同的子序列示例" style="zoom:67%;" />



动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

dp[i] [j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i] [j]。

为什么i-1，j-1 这么定义我在 [718. 最长重复子数组 (opens new window)](https://programmercarl.com/0718.最长重复子数组.html)中做了详细的讲解。

1. 确定递推公式

这一类问题，基本是要分析两种情况

- s[i - 1] 与 t[j - 1]相等
- s[i - 1] 与 t[j - 1] 不相等

当s[i - 1] 与 t[j - 1]相等时，dp[i] [j]可以有两部分组成。

一部分是用s[i - 1]来匹配，那么个数为dp[i - 1] [j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1] [j-1]。

一部分是不用s[i - 1]来匹配，个数为dp[i - 1] [j]。

**这里可能有录友不明白了，为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊**。

例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。

当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。

所以当s[i - 1] 与 t[j - 1]相等时，dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j];

当s[i - 1] 与 t[j - 1]不相等时，dp[i] [j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1] [j]

所以递推公式为：dp[i] [j] = dp[i - 1] [j];

这里可能有录友还疑惑，为什么只考虑 “不用s[i - 1]来匹配” 这种情况， 不考虑 “不用t[j - 1]来匹配” 的情况呢。

这里大家要明确，我们求的是 s 中有多少个 t，而不是 求t中有多少个s，所以只考虑 s中删除元素的情况，即 不用s[i - 1]来匹配 的情况。

1. dp数组如何初始化

从递推公式dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j]; 和 dp[i] [j] = dp[i - 1] [j]; 中可以看出dp[i][j] 是从上方和左上方推导而来，如图：，那么 dp[i] [0] 和dp[0] [j]是一定要初始化的。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20221222165412.png" alt="img" style="zoom:50%;" />

每次当初始化的时候，都要回顾一下dp[i][j]的定义，不要凭感觉初始化。

dp[i] [0]表示什么呢？

dp[i] [0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。

那么dp[i] [0]一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。

再来看dp[0] [j]，dp[0] [j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。

那么dp[0] [j]一定都是0，s如论如何也变成不了t。

最后就要看一个特殊位置了，即：dp[0] [0] 应该是多少。

dp[0] [0]应该是1，空字符串s，可以删除0个元素，变成空字符串t。

初始化分析完毕，代码如下：

```cpp
vector<vector<long long>> dp(s.size() + 1, vector<long long>(t.size() + 1));
for (int i = 0; i <= s.size(); i++) dp[i][0] = 1;
for (int j = 1; j <= t.size(); j++) dp[0][j] = 0; // 其实这行代码可以和dp数组初始化的时候放在一起，但我为了凸显初始化的逻辑，所以还是加上了。
```

1. 确定遍历顺序

从递推公式dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j]; 和 dp[i] [j] = dp[i - 1] [j]; 中可以看出dp[i][j]都是根据左上方和正上方推出来的。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20221222165412.png" alt="img" style="zoom:50%;" />

所以遍历的时候一定是从上到下，从左到右，这样保证dp[i] [j]可以根据之前计算出来的数值进行计算。

```java
/**
 * 计算字符串s中包含的不同子序列t的个数
 */
class Solution {
    public int numDistinct(String s, String t) {
        // 创建一个二维数组dp，用于存储计算结果
        // dp[i][j]表示以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i] [j]。
        int [][] dp = new int[s.length() + 1][t.length() + 1];
        
        // 初始化dp数组的第一列，表示当t为空字符串时，s中的任意子序列都是t的子序列，所以都为1
        for (int i = 0; i <= s.length(); i++) {
            dp[i][0] = 1;
        }
       
        // 遍历s和t的每个字符，计算dp数组的值
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= t.length(); j++) {
                // 如果s的第i个字符和t的第j个字符相等
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    // s[i-1]与t[j-1]相等的话，可以用s[i-1]去匹配t[j-1]，也可以删除s[i-1]，用s[i-2]去匹配
                    // dp[i][j]等于以i-2为结尾的s子序列中出现以j-2为结尾的t的个数加上以i-2为结尾的s子序列中出现以j-1为结尾的t的个数
                    dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]);
                } else {
                    // 不相等只能删除s[i-1]，用s[i-2]去匹配
                    // dp[i][j]等于以i-2为结尾的s子序列中出现以j-2为结尾的t的个数
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        // 返回dp数组的最后一个元素，即s和t的子序列个数
        return dp[s.length()][t.length()];
    }
}
```

# 583.两个字符串的删除操作

给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

示例：

- 输入: "sea", "eat"
- 输出: 2
- 解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"



1. 确定dp数组（dp table）以及下标的含义

dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。

这里dp数组的定义有点点绕，大家要撸清思路。

1. 确定递推公式

- 当word1[i - 1] 与 word2[j - 1]相同的时候
- 当word1[i - 1] 与 word2[j - 1]不相同的时候

当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i] [j] = dp[i - 1] [j - 1];

当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：

情况一：删word1[i - 1]，最少操作次数为dp[i - 1] [j] + 1

情况二：删word2[j - 1]，最少操作次数为dp[i] [j - 1] + 1

情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1] [j - 1] + 2

那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i][j] = min({dp[i - 1] [j - 1] + 2, dp[i - 1] [j] + 1, dp[i] [j - 1] + 1});

因为 dp[i] [j - 1] + 1 = dp[i - 1] [j - 1] + 2，所以递推公式可简化为：dp[i] [j] = min(dp[i - 1] [j] + 1, dp[i] [j - 1] + 1);

这里可能不少录友有点迷糊，从字面上理解 就是 当 同时删word1[i - 1]和word2[j - 1]，dp[i] [j-1] 本来就不考虑 word2[j - 1]了，那么我在删 word1[i - 1]，是不是就达到两个元素都删除的效果，即 dp[i] [j-1] + 1。

1. dp数组如何初始化

从递推公式中，可以看出来，dp[i] [0] 和 dp[0] [j]是一定要初始化的。

dp[i] [0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i] [0] = i。

dp[0] [j]的话同理，所以代码如下：

```cpp
vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));
for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
```

1. 确定遍历顺序

从递推公式 dp[i] [j] = min(dp[i - 1] [j - 1] + 2, min(dp[i - 1] [j], dp[i] [j - 1]) + 1); 和dp[i] [j] = dp[i - 1] [j - 1]可以看出dp[i] [j]都是根据左上方、正上方、正左方推出来的。

所以遍历的时候一定是从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算。

1. 举例推导dp数组

以word1:"sea"，word2:"eat"为例，推导dp数组状态图如下：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210714101750205.png" alt="583.两个字符串的删除操作1" style="zoom:50%;" />

```java
/**
 * 计算两个字符串的删除操作次数
 */
class Solution {
    /**
     * 计算两个字符串的删除操作次数
     * @param word1 字符串1
     * @param word2 字符串2
     * @return 删除操作次数
     */
    public int minDistance(String word1, String word2) {
        // 创建一个二维数组dp，用于存储删除操作次数
        int [][]  dp = new int[word1.length() + 1][word2.length() + 1];
        
        // 初始化第一行，表示将word1的前i个字符删除，需要的操作次数
        for (int i = 0; i <= word1.length(); i++) {
            dp[i][0] = i;
        }
        
        // 初始化第一列，表示将word2的前j个字符删除，需要的操作次数
        for (int i = 0; i <= word2.length(); i++) {
            dp[0][i] = i;
        }
        
        // 动态规划计算删除操作次数
        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                // 如果word1的第i个字符和word2的第j个字符相等，则不需要删除操作
                // dp[i][j]等于dp[i-1][j-1]
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 如果word1的第i个字符和word2的第j个字符不相等，则需要进行删除操作
                    // dp[i][j]等于dp[i-1][j-1] + 2（删除word1的第i个字符和删除word2的第j个字符）
                    // 或者dp[i][j]等于dp[i-1][j] + 1（删除word1的第i个字符）
                    // 或者dp[i][j]等于dp[i][j-1] + 1（删除word2的第j个字符）
                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 2,
                            Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }
        
        // 返回删除操作次数
        return dp[word1.length()][word2.length()];
    }
}
```

# 72.编辑距离

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符
- 示例 1：
- 输入：word1 = "horse", word2 = "ros"
- 输出：3
- 解释： horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e')
- 示例 2：
- 输入：word1 = "intention", word2 = "execution"
- 输出：5
- 解释： intention -> inention (删除 't') inention -> enention (将 'i' 替换为 'e') enention -> exention (将 'n' 替换为 'x') exention -> exection (将 'n' 替换为 'c') exection -> execution (插入 'u')



**1. 确定dp数组（dp table）以及下标的含义**

**dp[i] [j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i] [j]**。

有同学问了，为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？

为什么这么定义我在 [718. 最长重复子数组 (opens new window)](https://programmercarl.com/0718.最长重复子数组.html)中做了详细的讲解。

其实用i来表示也可以！ 用i-1就是为了方便后面dp数组初始化的。

**2. 确定递推公式**

在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：

```text
if (word1[i - 1] == word2[j - 1])
    不操作
if (word1[i - 1] != word2[j - 1])
    增
    删
    换
```

也就是如上4种情况。

```
if (word1[i - 1] == word2[j - 1])` 那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j] = dp[i - 1][j - 1];
```

此时可能有同学有点不明白，为啥要即`dp[i][j] = dp[i - 1][j - 1]`呢？

那么就在回顾上面讲过的`dp[i][j]`的定义，`word1[i - 1]` 与 `word2[j - 1]`相等了，那么就不用编辑了，以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串`word2`的最近编辑距离`dp[i - 1][j - 1]`就是 `dp[i][j]`了。

在下面的讲解中，如果哪里看不懂，就回想一下`dp[i][j]`的定义，就明白了。

**在整个动规的过程中，最为关键就是正确理解`dp[i][j]`的定义！**

`if (word1[i - 1] != word2[j - 1])`，此时就需要编辑了，如何编辑呢？

- 操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。

即 `dp[i][j] = dp[i - 1][j] + 1;`

- 操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。

即 `dp[i][j] = dp[i][j - 1] + 1;`

这里有同学发现了，怎么都是删除元素，添加元素去哪了。

**word1添加一个元素，相当于word2删除一个元素**，例如 `word1 = "ad" ，word2 = "a"`，`word1`删除元素`'d'` 和 `word2`添加一个元素`'d'`，变成`word1="a", word2="ad"`， 最终的操作数是一样！ dp数组如下图所示意的：

```text
            a                         a     d
   +-----+-----+             +-----+-----+-----+
   |  0  |  1  |             |  0  |  1  |  2  |
   +-----+-----+   ===>      +-----+-----+-----+
 a |  1  |  0  |           a |  1  |  0  |  1  |
   +-----+-----+             +-----+-----+-----+
 d |  2  |  1  |
   +-----+-----+
```

操作三：替换元素，`word1`替换`word1[i - 1]`，使其与`word2[j - 1]`相同，此时不用增删加元素。

可以回顾一下，`if (word1[i - 1] == word2[j - 1])`的时候我们的操作 是 `dp[i][j] = dp[i - 1][j - 1]` 对吧。

那么只需要一次替换的操作，就可以让 word1[i - 1] 和 word2[j - 1] 相同。

所以 `dp[i][j] = dp[i - 1][j - 1] + 1;`

综上，当 `if (word1[i - 1] != word2[j - 1])` 时取最小的，即：`dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;`

递归公式代码如下：

**3. dp数组如何初始化**

再回顾一下dp[i][j]的定义：

**dp[i] [j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i] [j]**。

那么dp[i] [0] 和 dp[0] [j] 表示什么呢？

dp[i] [0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i] [0]。

那么dp[i] [0]就应该是i，对word1里的元素全部做删除操作，即：dp[i] [0] = i;

同理dp[0] [j] = j;

所以C++代码如下：

```cpp
for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
```

**4. 确定遍历顺序**

从如下四个递推公式：

- `dp[i][j] = dp[i - 1][j - 1]`
- `dp[i][j] = dp[i - 1][j - 1] + 1`
- `dp[i][j] = dp[i][j - 1] + 1`
- `dp[i][j] = dp[i - 1][j] + 1`

可以看出dp[i] [j]是依赖左方，上方和左上方元素的，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210114162113131.jpg" alt="72.编辑距离" style="zoom:50%;" />

```java
class Solution {
    public int minDistance(String word1, String word2) {
        // 创建一个二维数组dp，用于存储编辑距离
        int [][] dp = new int[word1.length() + 1][word2.length() + 1];
        
        // 初始化第一行，表示将word1的前i个字符转换为空字符串的编辑距离
        for (int i = 0; i <= word1.length(); i++) {
            dp[i][0] = i;
        }
        
        // 初始化第一列，表示将空字符串转换为word2的前j个字符的编辑距离
        for (int j = 0; j <= word2.length(); j++) {
            dp[0][j] = j;
        }
        
        // 计算word1和word2之间的编辑距离
        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                // 如果word1的第i个字符和word2的第j个字符相等，则编辑距离不变
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                // 否则，取替换、插入和删除操作中的最小编辑距离
                else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 1,
                            Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }
        
        // 返回word1和word2之间的最小编辑距离
        return dp[word1.length()][word2.length()];
    }
}
```

# 647.回文子串

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

示例 1：

- 输入："abc"
- 输出：3
- 解释：三个回文子串: "a", "b", "c"

示例 2：

- 输入："aaa"
- 输出：6
- 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"



动规五部曲：

1. 确定dp数组（dp table）以及下标的含义

如果大家做了很多这种子序列相关的题目，在定义dp数组的时候 很自然就会想题目求什么，我们就如何定义dp数组。

绝大多数题目确实是这样，不过本题如果我们定义，dp[i] 为 下标i结尾的字符串有 dp[i]个回文串的话，我们会发现很难找到递归关系。

dp[i] 和 dp[i-1] ，dp[i + 1] 看上去都没啥关系。

所以我们要看回文串的性质。 如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230102170752.png" alt="img" style="zoom:50%;" />

我们在判断字符串S是否是回文，那么如果我们知道 s[1]，s[2]，s[3] 这个子串是回文的，那么只需要比较 s[0]和s[4]这两个元素是否相同，如果相同的话，这个字符串s 就是回文串。

那么此时我们是不是能找到一种递归关系，也就是判断一个子字符串（字符串的下表范围[i,j]）是否回文，依赖于，子字符串（下表范围[i + 1, j - 1]）） 是否是回文。

所以为了明确这种递归关系，我们的dp数组是要定义成一位二维dp数组。

布尔类型的dp[i] [j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i] [j]为true，否则为false。

1. 确定递推公式

在确定递推公式时，就要分析如下几种情况。

整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。

当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。

当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况

- 情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
- 情况二：下标i 与 j相差为1，例如aa，也是回文子串
- 情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1] [j - 1]是否为true。

以上三种情况分析完了，那么递归公式如下：

```cpp
if (s[i] == s[j]) {
    if (j - i <= 1) { // 情况一 和 情况二
        result++;
        dp[i][j] = true;
    } else if (dp[i + 1][j - 1]) { // 情况三
        result++;
        dp[i][j] = true;
    }
}
```

result就是统计回文子串的数量。

注意这里我没有列出当s[i]与s[j]不相等的时候，因为在下面dp[i] [j]初始化的时候，就初始为false。

1. dp数组如何初始化

dp[i] [j]可以初始化为true么？ 当然不行，怎能刚开始就全都匹配上了。

所以dp[i] [j]初始化为false。

1. 确定遍历顺序

遍历顺序可有有点讲究了。

首先从递推公式中可以看出，情况三是根据dp[i + 1] [j - 1]是否为true，在对dp[i] [j]进行赋值true的。

dp[i + 1] [j - 1] 在 dp[i][j]的左下角，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210121171032473-20230310132134822.jpg" alt="647.回文子串" style="zoom:50%;" />

如果这矩阵是从上到下，从左到右遍历，那么会用到没有计算过的dp[i + 1] [j - 1]，也就是根据不确定是不是回文的区间[i+1,j-1]，来判断了[i,j]是不是回文，那结果一定是不对的。

**所以一定要从下到上，从左到右遍历，这样保证dp[i + 1] [j - 1]都是经过计算的**。

有的代码实现是优先遍历列，然后遍历行，其实也是一个道理，都是为了保证dp[i + 1] [j - 1]都是经过计算的。

```java
class Solution {
    public int countSubstrings(String s) {
        // dp[i][j]表示s[i]到s[j]是否是回文串，是就是1，不是就是0
        int[][] dp = new int[s.length()][s.length()];
        int count = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            for (int j = i; j < s.length(); j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (j - i <= 1) {
                        dp[i][j] = 1; // 如果i和j相邻或者相等，则s[i]到s[j]是回文串
                        count++; // 回文串数量加1
                    } else {
                        dp[i][j] = dp[i + 1][j - 1]; // 如果s[i]到s[j]是回文串，则s[i+1]到s[j-1]也是回文串
                        if (dp[i][j] == 1) {
                            count++; // 回文串数量加1
                        }
                    }
                }
            }
        }
        return count; // 返回回文串的数量
    }
}
```

# 516.最长回文子序列

给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

示例 1: 输入: "bbbab" 输出: 4 一个可能的最长回文子序列为 "bbbb"。

示例 2: 输入:"cbbd" 输出: 2 一个可能的最长回文子序列为 "bb"。



动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

**dp[i] [j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i] [j]**。

1. 确定递推公式

在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。

如果s[i]与s[j]相同，那么dp[i] [j] = dp[i + 1] [j - 1] + 2;

如图： ![516.最长回文子序列](https://code-thinking-1253855093.file.myqcloud.com/pics/20210127151350563.jpg)

（如果这里看不懂，回忆一下dp[i] [j]的定义）

如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。

加入s[j]的回文子序列长度为dp[i + 1] [j]。

加入s[i]的回文子序列长度为dp[i] [j - 1]。

那么dp[i] [j]一定是取最大的，即：dp[i] [j] = max(dp[i + 1] [j], dp[i][j - 1]);

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210127151420476.jpg" alt="516.最长回文子序列1" style="zoom:50%;" />

代码如下：

```cpp
if (s[i] == s[j]) {
    dp[i][j] = dp[i + 1][j - 1] + 2;
} else {
    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
}
```

1. dp数组如何初始化

首先要考虑当i 和j 相同的情况，从递推公式：dp[i] [j] = dp[i + 1] [j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。

所以需要手动初始化一下，当i与j相同，那么dp[i] [j]一定是等于1的，即：一个字符的回文子序列长度就是1。

其他情况dp[i] [j]初始为0就行，这样递推公式：dp[i] [j] = max(dp[i + 1] [j], dp[i][j - 1]); 中dp[i][j]才不会被初始值覆盖。

```cpp
vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
for (int i = 0; i < s.size(); i++) dp[i][i] = 1;
```

1. 确定遍历顺序

从递归公式中，可以看出，dp[i] [j] 依赖于 dp[i + 1] [j - 1] ，dp[i + 1] [j] 和 dp[i][j - 1]，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230102172155.png" alt="img" style="zoom:50%;" />

**所以遍历i的时候一定要从下到上遍历，这样才能保证下一行的数据是经过计算的**。

j的话，可以正常从左向右遍历。

代码如下：

```cpp
for (int i = s.size() - 1; i >= 0; i--) {
    for (int j = i + 1; j < s.size(); j++) {
        if (s[i] == s[j]) {
            dp[i][j] = dp[i + 1][j - 1] + 2;
        } else {
            dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
        }
    }
}
```

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        // dp[i][j]表示s[i]到s[j]的最长回文子序列的长度
        int[][] dp = new int[s.length()][s.length()];
        for (int i = 0; i < s.length(); i++) {
            dp[i][i] = 1; // 初始化对角线上的元素为1，表示单个字符是回文子序列
        }
        for (int i = s.length() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.length(); j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2; // 如果s[i]和s[j]相等，那么dp[i][j]等于dp[i+1][j-1]的长度加2
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); // 如果s[i]和s[j]不相等，那么dp[i][j]等于dp[i+1][j]和dp[i][j-1]的较大值
                }
            }
        }
        return dp[0][s.length() - 1]; // 返回dp[0][s.length()-1]，即整个字符串的最长回文子序列的长度
    }
}
```

# 739.每日温度

请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

```java
// 定义一个类Solution
class Solution {
    // 定义一个方法dailyTemperatures，参数为一个整型数组temperatures，返回一个整型数组
    public int[] dailyTemperatures(int[] temperatures) {
        // 创建一个长度与temperatures相同的整型数组result
        int[] result = new int[temperatures.length];
        // 创建一个栈stack，用于存储数组元素的索引
        Stack<Integer> stack = new Stack<>();
        // 遍历temperatures数组
        for (int i = 0; i < temperatures.length; i++) {
            // 当栈不为空且当前温度大于栈顶元素对应的温度时，进入循环
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                // 弹出栈顶元素的索引
                int index = stack.pop();
                // 计算当前索引与弹出的索引之间的距离，即相邻更高温度的天数
                result[index] = i - index;
            }
            // 将当前索引入栈
            stack.push(i);
        }
        // 返回结果数组result
        return result;
    }
}
```

# 496.下一个更大元素

给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。

请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。

nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

示例 1:

输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。
对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。
对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。

示例 2:
输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出-1 。



```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int []  res = new int[nums1.length];  // 创建一个与nums1长度相同的数组res，用于存储结果
        Stack<Integer> stack = new Stack<>();  // 创建一个栈stack，用于存储nums2中的元素
        Map<Integer,Integer> map = new HashMap<>();  // 创建一个哈希表map，用于存储nums2中每个元素的下一个更大元素
        for(int i = 0;i < nums2.length;i++){  // 遍历nums2数组
            while(!stack.isEmpty() && nums2[i] > stack.peek()){  // 如果栈不为空且当前元素大于栈顶元素
                map.put(stack.pop(),nums2[i]);  // 将栈顶元素作为键，当前元素作为值，存入哈希表map中
            }
            stack.push(nums2[i]);  // 将当前元素入栈
        }
        while(!stack.isEmpty()){  // 当栈不为空时
            map.put(stack.pop(),-1);  // 将栈中剩余的元素作为键，值设为-1，存入哈希表map中
        }
        for(int i = 0;i < nums1.length;i++){  // 遍历nums1数组
            res[i] = map.get(nums1[i]);  // 从哈希表map中获取nums1中每个元素的下一个更大元素，并存入结果数组res中
        }
        return res;  // 返回结果数组res
    }
}
```

# 503.下一个更大元素II

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

示例 1:

- 输入: [1,2,1]
- 输出: [2,-1,2]
- 解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数；第二个 1 的下一个最大的数需要循环搜索，结果也是 2。

```java
/**
 * 下一个更大元素 II
 */
class Solution {
    /**
     * 查找下一个更大的元素
     * @param nums 给定的数组
     * @return 返回一个数组，数组中的每个元素表示对应位置元素的下一个更大元素，如果不存在则为-1
     */
    public int[] nextGreaterElements(int[] nums) {
        // 创建一个与给定数组长度相同的结果数组，并将其所有元素初始化为-1
        int[] res = new int[nums.length];
        Arrays.fill(res, -1);
        
        // 创建一个栈用于存储数组元素的索引
        Stack<Integer> stack = new Stack<>();
        
        // 遍历数组元素，由于是循环数组，所以遍历两倍的数组长度
        for (int i = 0; i < nums.length * 2; i++) {
            // 当栈不为空且栈顶元素对应的数组元素小于当前元素时，将栈顶元素出栈，并将当前元素赋值给结果数组中对应的位置
            while (!stack.isEmpty() && nums[stack.peek()] < nums[i % nums.length]) {
                res[stack.pop()] = nums[i % nums.length];
            }
            // 将当前元素的索引入栈
            stack.push(i % nums.length);
        }
        
        // 返回结果数组
        return res;
    }
}
```

# 42.接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

示例 1：

![img](https://code-thinking-1253855093.cos.ap-guangzhou.myqcloud.com/pics/20210713205038.png)

- 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
- 输出：6
- 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

```java
class Solution {
    public int trap(int[] height) {
        int sum = 0; // 存储接雨水的总量
        int len = height.length; // 数组的长度
        Stack<Integer> stack = new Stack<>(); // 使用栈来存储数组的索引
        stack.push(0); // 将第一个索引入栈
        for (int i = 1; i < len; i++) { // 遍历数组
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) { // 当栈不为空且当前高度大于栈顶高度时
                int top = stack.pop(); // 弹出栈顶元素
                if (stack.isEmpty()) { // 如果栈为空，说明无法形成凹槽，结束循环
                    break;
                }
                int distance = i - stack.peek() - 1; // 计算两个柱子之间的距离
                int boundedHeight = Math.min(height[i], height[stack.peek()]) - height[top]; // 计算凹槽的高度
                sum += distance * boundedHeight; // 计算凹槽的面积并累加到总量中
            }
            stack.push(i); // 将当前索引入栈
        }                 
        return sum; // 返回接雨水的总量
    }
}
```

# 84.柱状图最大的图形

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210803220437.png" alt="img" style="zoom:50%;" />

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210803220506.png" alt="img" style="zoom:50%;" />

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> st = new Stack<Integer>(); // 使用栈来存储索引

        int [] newHeights = new int[heights.length + 2]; // 创建一个新的数组，用于处理边界情况
        newHeights[0] = 0; // 在新数组的开头和结尾添加0，用于处理边界情况
        newHeights[newHeights.length - 1] = 0;
        for (int index = 0; index < heights.length; index++){
            newHeights[index + 1] = heights[index]; // 将原始数组的值复制到新数组中
        }

        heights = newHeights; // 将新数组赋值给原始数组

        st.push(0); // 将新数组的第一个索引入栈
        int result = 0; // 初始化结果变量
        for (int i = 1; i < heights.length; i++) { // 遍历新数组
            if (heights[i] > heights[st.peek()]) { // 如果当前高度大于栈顶索引对应的高度
                st.push(i); // 将当前索引入栈
            } else if (heights[i] == heights[st.peek()]) { // 如果当前高度等于栈顶索引对应的高度
                st.pop(); // 弹出栈顶索引
                st.push(i); // 将当前索引入栈
            } else { // 如果当前高度小于栈顶索引对应的高度
                while (heights[i] < heights[st.peek()]) { // 循环直到当前高度大于栈顶索引对应的高度
                    int mid = st.peek(); // 获取栈顶索引
                    st.pop(); // 弹出栈顶索引
                    int left = st.peek(); // 获取新的栈顶索引
                    int right = i; // 当前索引
                    int w = right - left - 1; // 计算宽度
                    int h = heights[mid]; // 获取高度
                    result = Math.max(result, w * h); // 更新结果
                }
                st.push(i); // 将当前索引入栈
            }
        }
        return result; // 返回结果
    }
}
```

# 797.所有可能的路径

给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）

graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i] [j]存在一条有向边）。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20221203135439.png" alt="img" style="zoom: 50%;" />

```java
/**
 * 所有可能的路径
 */
class Solution {
    /**
     * 获取从起点到终点的所有可能路径
     * @param graph 图的邻接矩阵表示
     * @return 所有可能的路径列表
     */
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        List<List<Integer>> res = new ArrayList<>(); // 存储结果的列表
        List<Integer> path = new ArrayList<>(); // 存储当前路径的列表
        path.add(0); // 将起点添加到路径中
        dfs(graph, 0, path, res); // 从起点开始深度优先搜索
        return res; // 返回结果列表
    }

    /**
     * 深度优先搜索
     * @param graph 图的邻接矩阵表示
     * @param node 当前节点
     * @param path 当前路径
     * @param res 结果列表
     */
    private void dfs(int[][] graph, int node, List<Integer> path, List<List<Integer>> res) {
        if (node == graph.length - 1) { // 如果当前节点是终点
            res.add(new ArrayList<>(path)); // 将当前路径添加到结果列表中
            return; // 返回
        }
        for (int next : graph[node]) { // 遍历当前节点的邻接节点
            path.add(next); // 将邻接节点添加到路径中
            dfs(graph, next, path, res); // 递归搜索邻接节点
            path.remove(path.size() - 1); // 回溯，将邻接节点从路径中移除
        }
    }
}
```

# 200.岛屿数量

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220726093256.png" alt="img" style="zoom: 50%;" />



本题思路，是用遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。

在遇到标记过的陆地节点和海洋节点的时候直接跳过。 这样计数器就是最终岛屿的数量。

下面的代码使用的是深度优先搜索 DFS 的做法。为了统计岛屿数量同时不重复记录，每当我们搜索到一个岛后，就将这个岛 “淹没” —— 将这个岛所占的地方从 “1” 改为 “0”，这样就不用担心后续会重复记录这个岛屿了。而 DFS 的过程就体现在 “淹没” 这一步中。详见代码：

```java
public int numIslands(char[][] grid) {
    int res = 0; //记录找到的岛屿数量
    for(int i = 0;i < grid.length;i++){
        for(int j = 0;j < grid[0].length;j++){
        	//找到“1”，res加一，同时淹没这个岛
            if(grid[i][j] == '1'){
                res++;
                dfs(grid,i,j);
            }
        }
    }
    return res;
}
//使用DFS“淹没”岛屿
public void dfs(char[][] grid, int i, int j){
	//搜索边界：索引越界或遍历到了"0"
    if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') return;
    //将这块土地标记为"0"
    grid[i][j] = '0';
    //根据"每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成"，对上下左右的相邻顶点进行dfs
    dfs(grid,i - 1,j);
    dfs(grid,i + 1,j);
    dfs(grid,i,j + 1);
    dfs(grid,i,j - 1);
}
```



```java
/**
 * 岛屿数量
 */
class Solution {
    boolean[][] visited; // 记录是否访问过的数组
    int[][] move = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // 移动的方向，右、左、下、上

    /**
     * 计算岛屿数量
     * @param grid 二维字符数组表示的地图
     * @return 岛屿数量
     */
    public int numIslands(char[][] grid) {
        int res = 0; // 岛屿数量
        visited = new boolean[grid.length][grid[0].length]; // 初始化visited数组

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (!visited[i][j] && grid[i][j] == '1') { // 如果当前位置未访问过且为陆地
                    bfs(grid, i, j); // 进行广度优先搜索
                    res++; // 岛屿数量加1
                }
            }
        }

        return res;
    }

    /**
     * 广度优先搜索
     * @param grid 二维字符数组表示的地图
     * @param y 当前位置的纵坐标
     * @param x 当前位置的横坐标
     */
    public void bfs(char[][] grid, int y, int x) {
        Deque<int[]> queue = new ArrayDeque<>(); // 使用队列保存待访问的位置
        queue.offer(new int[]{y, x}); // 将当前位置加入队列
        visited[y][x] = true; // 标记当前位置为已访问

        while (!queue.isEmpty()) {
            int[] cur = queue.poll(); // 取出队列中的当前位置
            int curY = cur[0]; // 当前位置的纵坐标
            int curX = cur[1]; // 当前位置的横坐标

            for (int i = 0; i < 4; i++) { // 遍历四个方向
                int nextY = curY + move[i][0]; // 计算下一个位置的纵坐标
                int nextX = curX + move[i][1]; // 计算下一个位置的横坐标

                // 如果下一个位置在地图范围内，且未访问过且为陆地
                if (nextY >= 0 && nextY < grid.length && nextX >= 0 && nextX < grid[0].length
                        && !visited[nextY][nextX] && grid[nextY][nextX] == '1') {
                    queue.offer(new int[]{nextY, nextX}); // 将下一个位置加入队列
                    visited[nextY][nextX] = true; // 标记下一个位置为已访问
                }
            }
        }
    }
}
```

# 695.岛屿的最大面积

```java
/**
 * 计算岛屿的最大面积
 */
class Solution {
    /**
     * 计算岛屿的最大面积
     * @param grid 岛屿的二维数组表示
     * @return 最大面积
     */
    public int maxAreaOfIsland(int[][] grid) {
        boolean[][] visited = new boolean[grid.length][grid[0].length]; // 创建一个与岛屿二维数组相同大小的visited数组，用于标记已访问的位置
        int maxArea = 0; // 初始化最大面积为0
        for (int i = 0; i < grid.length; i++) { // 遍历岛屿二维数组的行
            for (int j = 0; j < grid[0].length; j++) { // 遍历岛屿二维数组的列
                if (grid[i][j] == 1 && !visited[i][j]) { // 如果当前位置是陆地且未被访问过
                    maxArea = Math.max(maxArea, dfs(grid, visited, i, j)); // 使用深度优先搜索计算当前岛屿的面积，并更新最大面积
                }
            }
        }
        return maxArea; // 返回最大面积
    }

    /**
     * 深度优先搜索计算岛屿的面积
     * @param grid 岛屿的二维数组表示
     * @param visited 访问标记数组
     * @param i 当前位置的行索引
     * @param j 当前位置的列索引
     * @return 当前岛屿的面积
     */
    private int dfs(int[][] grid, boolean[][] visited, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0 || visited[i][j]) {
            return 0; // 如果当前位置超出岛屿范围、为水域、或已被访问过，则返回面积为0
        }
        visited[i][j] = true; // 标记当前位置为已访问
        return 1 + dfs(grid, visited, i - 1, j) // 递归计算上、下、左、右四个方向的面积，并将结果累加
                + dfs(grid, visited, i + 1, j)
                + dfs(grid, visited, i, j - 1)
                + dfs(grid, visited, i, j + 1);
    }
}
```

# 1020. 飞地的数量

给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。

一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。

返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220830100710.png" alt="img" style="zoom:50%;" />

- 输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
- 输出：3
- 解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220830100742.png" alt="img" style="zoom:50%;" />

- 输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
- 输出：0
- 解释：所有 1 都在边界上或可以到达边界。



本题要求找到不靠边的陆地面积，那么我们只要从周边找到陆地然后 通过 dfs或者bfs 将周边靠陆地且相邻的陆地都变成海洋，然后再去重新遍历地图的时候，统计此时还剩下的陆地就可以了。

```java
/**
 * 计算飞地的数量
 */
class Solution {

    // 定义四个方向的偏移量
    int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    int res = 0;

    /**
     * 计算飞地的数量
     * @param grid 二维网格
     * @return 飞地的数量
     */
    public int numEnclaves(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        // 遍历第一列和最后一列
        for (int i = 0; i < m; i++) {
            if(grid[i][0] == 1)
                dfs(grid, i, 0);
            if(grid[i][n - 1] == 1)
                dfs(grid, i, n - 1);
        }
        // 遍历第一行和最后一行
        for (int j = 1; j < n; j++) {
            if (grid[0][j] == 1)
                dfs(grid, 0, j);
            if (grid[m - 1][j] == 1)
                dfs(grid, m - 1, j);
        }
        // 统计剩余的飞地数量
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++){
                if (grid[i][j] == 1)
                    res++;
            }
        }
        return res;
    }

    /**
     * 深度优先搜索
     * @param grid 二维网格
     * @param i 当前位置的行索引
     * @param j 当前位置的列索引
     */
    private void dfs(int[][] grid, int i, int j) {
        // 将当前位置标记为已访问
        grid[i][j] = 0;
        // 遍历四个方向
        for (int[] dir : dirs) {
            int x = i + dir[0];
            int y = j + dir[1];
            // 判断是否在网格范围内且为飞地
            if (x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 1)
                dfs(grid, x, y);
        }
    }
}
```

# 130. 被围绕的区域

给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220901104745.png" alt="img" style="zoom:50%;" />

- 输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
- 输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
- 解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。



步骤一：深搜或者广搜将地图周边的'O'全部改成'A'，如图所示：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220902102337.png" alt="图一" style="zoom: 33%;" />

步骤二：在遍历地图，将'O'全部改成'X'（地图中间的'O'改成了'X'），将'A'改回'O'（保留的地图周边的'O'），如图所示：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220902102831.png" alt="图二" style="zoom:33%;" />

```java
/**
 * 被围绕的区域
 */
class Solution {

    // 定义四个方向的偏移量
    int [][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    int res = 0;

    /**
     * 解决被围绕的区域问题
     * @param board 二维字符数组表示的棋盘
     */
    public void solve(char[][] board) {
        if (board.length == 0) {
            return;
        }
        int m = board.length;
        int n = board[0].length;
        // 遍历第一列和最后一列
        for (int i = 0; i < m; i++){
            if (board[i][0] == 'O')
                dfs(board, i, 0);
            if (board[i][n - 1] == 'O')
                dfs(board, i, n - 1);
        }
        // 遍历第一行和最后一行
        for (int j = 1; j < n; j++){
            if (board[0][j] == 'O')
                dfs(board, 0, j);
            if (board[m - 1][j] == 'O')
                dfs(board, m - 1, j);
        }
        // 将剩余的'O'变为'X'，将标记的'#'变回'O'
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
                if (board[i][j] == '#') {
                    board[i][j] = 'O';
                }
            }
        }
    }

    /**
     * 深度优先搜索，将与边界相连的'O'标记为'#'
     * @param board 二维字符数组表示的棋盘
     * @param i 当前位置的行索引
     * @param j 当前位置的列索引
     */
    private void dfs(char[][] board, int i, int j) {
        board[i][j] = '#';
        for (int[] dir : dirs) {
            int x = i + dir[0];
            int y = j + dir[1];
            // 判断是否越界，并且下一个位置是'O'
            if (x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] == 'O')
                dfs(board, x, y);
        }
    }
}
```

# 417. 太平洋大西洋水流问题

有一个 m × n 的矩形岛屿，与 太平洋 和 大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。

这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights ， heights[r][c] 表示坐标 (r, c) 上单元格 高于海平面的高度 。

岛上雨水较多，如果相邻单元格的高度 小于或等于 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。

返回网格坐标 result 的 2D 列表 ，其中 result[i] = [ri, ci] 表示雨水从单元格 (ri, ci) 流动 既可流向太平洋也可流向大西洋 。

示例 1：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230129103212.png" alt="img" style="zoom:33%;" />

- 输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
- 输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]

示例 2：

- 输入: heights = [[2,1],[1,2]]
- 输出: [[0,0],[0,1],[1,0],[1,1]]



那么我们可以 反过来想，从太平洋边上的节点 逆流而上，将遍历过的节点都标记上。 从大西洋的边上节点 逆流而长，将遍历过的节点也标记上。 然后两方都标记过的节点就是既可以流太平洋也可以流大西洋的节点。

从太平洋边上节点出发，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220722103029.png" alt="图一" style="zoom:33%;" />

从大西洋边上节点出发，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220722103330.png" alt="图二" style="zoom:33%;" />

```java
class Solution {

    int [][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 定义四个方向的偏移量

    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        List<List<Integer>> res = new ArrayList<>(); // 存储结果的列表
        if (heights == null || heights.length == 0) { // 如果输入为空或者高度矩阵的行数为0，则直接返回结果列表
            return res;
        }
        int m = heights.length; // 高度矩阵的行数
        int n = heights[0].length; // 高度矩阵的列数
        boolean[][] pacific = new boolean[m][n]; // 记录能流入太平洋的位置
        boolean[][] atlantic = new boolean[m][n]; // 记录能流入大西洋的位置
        for (int i = 0; i < m; i++) { // 从第一列和最后一列开始DFS，并记录能流入太平洋和大西洋的位置
            dfs(heights, pacific, i, 0, m, n);
            dfs(heights, atlantic, i, n - 1, m, n);
        }
        for (int i = 0; i < n; i++) { // 从第一行和最后一行开始DFS，并记录能流入太平洋和大西洋的位置
            dfs(heights, pacific, 0, i, m, n);
            dfs(heights, atlantic, m - 1, i, m, n);
        }
        for (int i = 0; i < m; i++) { // 遍历整个高度矩阵
            for (int j = 0; j < n; j++) {
                if (pacific[i][j] && atlantic[i][j]) { // 如果一个位置既能流入太平洋又能流入大西洋，则将其加入结果列表
                    List<Integer> list = new ArrayList<>();
                    list.add(i);
                    list.add(j);
                    res.add(list);
                }
            }
        }
        return res; // 返回结果列表
    }

    private void dfs(int[][] heights, boolean[][] visited, int i, int j, int m, int n){
        if (visited[i][j]) { // 如果当前位置已经被访问过，则直接返回
            return;
        }
        visited[i][j] = true; // 将当前位置标记为已访问
        for (int[] dir : dirs) { // 遍历四个方向
            int x = i + dir[0]; // 计算下一个位置的行坐标
            int y = j + dir[1]; // 计算下一个位置的列坐标
            if (x >= 0 && x < m && y >= 0 && y < n && heights[x][y] >= heights[i][j]) { // 如果下一个位置在矩阵范围内且高度不低于当前位置，则继续深度优先搜索
                dfs(heights, visited, x, y, m, n);
            }
        }
    }
}
```

# 827.最大人工岛

给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。

返回执行此操作后，grid 中最大的岛屿面积是多少？

岛屿 由一组上、下、左、右四个方向相连的 1 形成。

示例 1:

- 输入: grid = [[1, 0], [0, 1]]
- 输出: 3
- 解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。

示例 2:

- 输入: grid = [[1, 1], [1, 0]]
- 输出: 4
- 解释: 将一格0变成1，岛屿的面积扩大为 4。

示例 3:

- 输入: grid = [[1, 1], [1, 1]]
- 输出: 4
- 解释: 没有0可以让我们变成1，面积依然为 4。



第一步：一次遍历地图，得出各个岛屿的面积，并做编号记录。可以使用map记录，key为岛屿编号，value为岛屿面积 第二步：在遍历地图，遍历0的方格（因为要将0变成1），并统计该1（由0变成的1）周边岛屿面积，将其相邻面积相加在一起，遍历所有 0 之后，就可以得出 选一个0变成1 之后的最大面积。

```java
class Solution {

    int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};  // 定义方向数组，表示上、右、下、左四个方向的偏移量

    public int largestIsland(int[][] grid) {
        int ans = Integer.MIN_VALUE, size = grid.length, mark = 2;  // 初始化最大岛屿面积ans为最小值，size为grid的大小，mark为标记值
        Map<Integer, Integer> getSize = new HashMap<>();  // 创建一个HashMap用于存储每个岛屿的面积
        for (int row = 0; row < size; row++) {  // 遍历grid的每个位置
            for (int col = 0; col < size; col++) {
                if (grid[row][col] == 1) {  // 如果当前位置是陆地
                    int areaSize = 1 + dfs(grid, row, col, mark);  // 计算当前岛屿的面积
                    getSize.put(mark++, areaSize);  // 将当前岛屿的面积存入HashMap中，并更新mark的值
                }
            }
        }
        for (int row = 0; row < size; row++) {  // 遍历grid的每个位置
            for (int col = 0; col < size; col++) {
                if (grid[row][col] != 0) 
                    continue;  // 如果当前位置不是水域，则跳过
                Set<Integer> hashSet = new HashSet<>();  // 创建一个HashSet用于存储相邻岛屿的标记值
                int curSize = 1;  // 初始化当前水域的面积为1
                for (int[] dir: dirs) {  // 遍历四个方向
                    int curRow = row + dir[0], curCol = col + dir[1];  // 计算相邻位置的坐标
                    if (curRow < 0 || curRow >= grid.length || curCol < 0 || curCol >= grid.length) 								continue;  // 如果相邻位置超出边界，则跳过
                    int curMark = grid[curRow][curCol];  // 获取相邻位置的标记值
                    if (hashSet.contains(curMark) || !getSize.containsKey(curMark)) 
                        continue;  // 如果相邻位置的标记值已经存在于HashSet中，或者HashMap中不存在该标记值，则跳过
                    hashSet.add(curMark);  // 将相邻位置的标记值加入HashSet中
                    curSize += getSize.get(curMark);  // 更新当前水域的面积
                }
                ans = Math.max(ans, curSize);  // 更新最大岛屿面积
            }
        }
        return ans == Integer.MIN_VALUE ? size * size : ans;  // 如果最大岛屿面积仍然是初始值，则返回整个grid的面积，否则返回最大岛屿面积
    }

    public int dfs(int[][] grid, int row, int col, int mark) {
        int ans = 0;  // 初始化岛屿面积为0
        grid[row][col] = mark;  // 将当前位置标记为mark
        for (int[] dir: dirs) {  // 遍历四个方向
            int curRow = row + dir[0], curCol = col + dir[1];  // 计算相邻位置的坐标
            if (curRow >= 0 && curRow < grid.length && curCol >= 0 && curCol < grid.length && grid[curRow]	[curCol] == 1)
                ans += 1 + dfs(grid, curRow, curCol, mark); // 如果相邻位置不超出边界且是陆地，则递归计算岛屿面积
        }
        return ans;  // 返回岛屿面积
    }
}
```

# 127. 单词接龙

字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：

- 序列中第一个单词是 beginWord 。
- 序列中最后一个单词是 endWord 。
- 每次转换只能改变一个字母。
- 转换过程中的中间单词必须是字典 wordList 中的单词。
- 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。

示例 1：

- 输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
- 输出：5
- 解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。

示例 2：

- 输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
- 输出：0
- 解释：endWord "cog" 不在字典中，所以无法进行转换。



以示例1为例，从这个图中可以看出 hit 到 cog的路线，不止一条，有三条，一条是最短的长度为5，两条长度为6。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210827175432.png" alt="img" style="zoom: 25%;" />

本题只需要求出最短路径的长度就可以了，不用找出路径。

所以这道题要解决两个问题：

- 图中的线是如何连在一起的
- 起点和终点的最短路径长度

首先题目中并没有给出点与点之间的连线，而是要我们自己去连，条件是字符只能差一个，所以判断点与点之间的关系，要自己判断是不是差一个字符，如果差一个字符，那就是有链接。

然后就是求起点和终点的最短路径长度，**这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径**。因为广搜就是以起点中心向四周扩散的搜索。

**本题如果用深搜，会比较麻烦，要在到达终点的不同路径中选则一条最短路**。 而广搜只要达到终点，一定是最短路。

另外需要有一个注意点：

- 本题是一个无向图，需要用标记位，标记着节点是否走过，否则就会死循环！
- 本题给出集合是数组型的，可以转成set结构，查找更快一些

```java
/**
 * 单词接龙
 */
class Solution {
    /**
     * 计算从beginWord到endWord的最短转换序列长度
     *
     * @param beginWord 起始单词
     * @param endWord   目标单词
     * @param wordList  单词列表
     * @return 最短转换序列长度，如果无法转换则返回0
     */
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        // 使用HashSet存储单词列表，方便查找
        HashSet<String> wordSet = new HashSet<>(wordList);
        // 如果单词列表为空或者目标单词不在列表中，则无法转换，返回0
        if (wordSet.size() == 0 || !wordSet.contains(endWord)) {
            return 0;
        }
        // 使用队列存储待处理的单词
        Queue<String> queue = new LinkedList<>();
        // 将起始单词加入队列
        queue.offer(beginWord);
        // 使用Map存储单词及其对应的转换序列长度
        Map<String, Integer> map = new HashMap<>();
        // 起始单词的转换序列长度为1
        map.put(beginWord, 1);

        // 开始循环处理队列中的单词
        while (!queue.isEmpty()) {
            // 取出队列中的单词
            String word = queue.poll();
            // 获取当前单词的转换序列长度
            int path = map.get(word);
            // 遍历当前单词的每个字符
            for (int i = 0; i < word.length(); i++) {
                // 将当前单词转换为字符数组
                char[] chars = word.toCharArray();
                // 遍历26个字母
                for (char k = 'a'; k <= 'z'; k++) {
                    // 将当前字符替换为不同的字母
                    chars[i] = k;
                    // 构造新的单词
                    String newWord = String.valueOf(chars);
                    // 如果新单词等于目标单词，返回转换序列长度+1
                    if (newWord.equals(endWord)) {
                        return path + 1;
                    }
                    // 如果新单词在单词列表中且未被访问过
                    if (wordSet.contains(newWord) && !map.containsKey(newWord)) {
                        // 将新单词加入队列
                        queue.offer(newWord);
                        // 更新新单词的转换序列长度
                        map.put(newWord, path + 1);
                    }
                }
            }
        }
        // 无法转换，返回0
        return 0;
    }
}
```

# 841.钥匙和房间

有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。

在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。

最初，除 0 号房间外的其余所有房间都被锁住。

你可以自由地在房间之间来回走动。

如果能进入每个房间返回 true，否则返回 false。

示例 1：

- 输入: [[1],[2],[3],[]]
- 输出: true
- 解释: 我们从 0 号房间开始，拿到钥匙 1。 之后我们去 1 号房间，拿到钥匙 2。 然后我们去 2 号房间，拿到钥匙 3。 最后我们去了 3 号房间。 由于我们能够进入每个房间，我们返回 true。

示例 2：

- 输入：[[1,3],[3,0,1],[2],[0]]
- 输出：false
- 解释：我们不能进入 2 号房间。



本题其实给我们是一个有向图， 意识到这是有向图很重要！

图中给我的两个示例： `[[1],[2],[3],[]]` `[[1,3],[3,0,1],[2],[0]]`，画成对应的图如下：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220714101414.png" alt="img" style="zoom: 33%;" />

我们可以看出图1的所有节点都是链接的，而图二中，节点2 是孤立的。

这就很容易让我们想起岛屿问题，只要发现独立的岛，就是不能进入所有房间。

此时也容易想到用并查集的方式去解决。

**但本题是有向图**，在有向图中，即使所有节点都是链接的，但依然不可能从0出发遍历所有边。 给大家举一个例子：

图3：[[5], [], [1, 3], [5]] ，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220714102201.png" alt="img" style="zoom:33%;" />

在图3中，大家可以发现，节点0只能到节点5，然后就哪也去不了了。

所以本题是一个有向图搜索全路径的问题。 只能用深搜（DFS）或者广搜（BFS）来搜。

```java
class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size(); // 获取房间的数量
        boolean[] visited = new boolean[n]; // 创建一个布尔数组，用于记录房间是否被访问过
        dfs(rooms, 0, visited); // 从第一个房间开始进行深度优先搜索
        for (boolean b : visited) { // 遍历visited数组
            if (!b) { // 如果有房间未被访问过
                return false; // 返回false
            }
        }
        return true; // 如果所有房间都被访问过，则返回true
    }

    private void dfs(List<List<Integer>> rooms, int i, boolean[] visited) {
        visited[i] = true; // 将当前房间标记为已访问
        for (int j : rooms.get(i)) { // 遍历当前房间的钥匙列表
            if (!visited[j]) { // 如果钥匙对应的房间未被访问过
                dfs(rooms, j, visited); // 递归地访问该房间
            }
        }
    }
}
```

# 463. 岛屿的周长

给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。

网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230829180848.png" alt="img" style="zoom:50%;" />

- 输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
- 输出：16
- 解释：它的周长是上面图片中的 16 个黄色的边

示例 2：

- 输入：grid = [[1]]
- 输出：4



```java
/**
 * 计算岛屿的周长
 */
class Solution {
    /**
     * 计算岛屿的周长
     * @param grid 岛屿的二维数组表示
     * @return 岛屿的周长
     */
    public int islandPerimeter(int[][] grid) {
        int count = 0; // 初始化周长计数器
        for (int i = 0; i < grid.length; i++) { // 遍历二维数组的行
            for (int j = 0; j < grid[0].length; j++) { // 遍历二维数组的列
                if (grid[i][j] == 1) { // 如果当前位置是岛屿
                    count += 4; // 周长加4
                    if (i > 0 && grid[i - 1][j] == 1) { // 如果上方也是岛屿
                        count -= 2; // 周长减2
                    }
                    if (j > 0 && grid[i][j - 1] == 1) { // 如果左方也是岛屿
                        count -= 2; // 周长减2
                    }
                }
            }
        }
        return count; // 返回岛屿的周长
    }
}
```



# Hot 100

## 461.汉明距离

给你两个整数 `x` 和 `y`，计算并返回它们之间的汉明距离。

**示例 1：**

```java
输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
```

```java
class Solution {
    // 计算两个整数的汉明距离
    public int hammingDistance(int x, int y) {
        // 使用异或运算符(^)得到两个整数对应位不同的结果，再使用Integer类的bitCount方法计算结果中1的个数，即为汉明距离
        return Integer.bitCount(x ^ y);
    }
}
```

## 617.合并二叉树

<img src="C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240104114058861.png" alt="image-20240104114058861" style="zoom: 80%;" />

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null)
            return root2;
        if (root2 == null)
            return root1;
        root1.val += root2.val;
        root1.left = mergeTrees(root1.left, root2.left);
        root1.right = mergeTrees(root1.right, root2.right);
        return root1;
    }
}
```

## 226.翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img" style="zoom:50%;" />

```java
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

```java
class Solution {
    // 定义一个方法，用于翻转二叉树
    public TreeNode invertTree(TreeNode root) {
        // 如果根节点为空，则直接返回null
        if (root == null) {
            return null;
        }
        // 交换当前节点的左右子树
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        // 递归调用翻转左子树
        root.left = invertTree(root.left);
        // 递归调用翻转右子树
        root.right = invertTree(root.right);
        // 返回翻转后的根节点
        return root;
    }
}
```

## 104.二叉树的最大深度

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。



**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img" style="zoom:50%;" />



```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

```java
class Solution {
    // 计算二叉树的最大深度
    public int maxDepth(TreeNode root) {
        // 创建一个队列用于层序遍历
        Queue<TreeNode> queue = new LinkedList<>();
        // 如果根节点不为空，则将根节点加入队列
        if (root != null) {
            queue.offer(root);
        }
        // 初始化深度为0
        int depth = 0;
        // 循环直到队列为空
        while (!queue.isEmpty()) {
            // 获取当前层的节点个数
            int size = queue.size();
            // 深度加1
            depth++;
            // 遍历当前层的所有节点
            while (size > 0) {
                // 出队一个节点
                TreeNode node = queue.poll();
                // 如果左子节点不为空，则加入队列
                if (node.left != null) {
                    queue.offer(node.left);
                }
                // 如果右子节点不为空，则加入队列
                if (node.right != null) {
                    queue.offer(node.right);
                }
                size--;
            }
        }
        // 返回最大深度
        return depth;
    }
}
```

## 206.反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

```java
class Solution {
    // 定义一个方法，用于反转链表
    public ListNode reverseList(ListNode head) {
        // 定义三个指针，分别指向当前节点、前一个节点和临时节点
        ListNode temp;
        ListNode pre = null;
        ListNode cur = head;
        // 遍历链表
        while(cur != null) {
            // 保存当前节点的下一个节点
            temp = cur.next;
            // 将当前节点指向前一个节点，实现反转
            cur.next = pre;
            // 更新前一个节点和当前节点
            pre = cur;
            cur = temp;
        }
        // 返回反转后的链表头节点
        return pre;
    }
}
```

## 136.只出现一次的数字

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

**示例 1 ：**

```
输入：nums = [2,2,1]
输出：1
```

**示例 2 ：**

```
输入：nums = [4,1,2,1,2]
输出：4
```

```java
class Solution {
    // 定义一个Solution类
    public int singleNumber(int[] nums) {
        // 定义一个方法，参数为整型数组nums，用于找出只出现一次的数字
        int ans = 0;
        // 初始化一个变量ans为0，用于存储结果
        for (int num : nums) {
            // 遍历整型数组nums中的每个元素
            ans ^= num;
            // 对结果ans与当前元素num进行异或操作
        }
        return ans;
        // 返回结果ans，即只出现一次的数字
    }
}
```

## 169.多数元素

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**

```
输入：nums = [2,2,1,1,1,2,2]
输出：2
```

```java
// 定义一个Solution类
class Solution {
    // 定义一个方法，用于找出数组中出现次数超过一半的元素
    public int majorityElement(int[] nums) {
        // 初始化两个变量，ans用于存储当前出现次数超过一半的元素，cnt用于记录当前元素出现的次数
        int ans = 0, cnt = 0;
        // 遍历数组
        for (int i = 0; i < nums.length; ++i) {
            // 如果当前元素出现次数为0
            if (cnt == 0) {
                // 更新ans为当前元素，并将出现次数加1
                ans = nums[i];
                ++cnt;
            } else {
                // 如果当前元素与ans相同，则出现次数加1，否则减1
                if (ans == nums[i]) {
                    ++cnt;
                } else {
                    --cnt;
                }
            }
        }
        // 返回出现次数超过一半的元素
        return ans;
    }
}
```

## 21.合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img" style="zoom:67%;" />

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

```java
// 定义一个Solution类
class Solution {
    // 定义一个方法，用于合并两个有序链表
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 如果list1为空，直接返回list2
        if (list1 == null) {
            return list2;
        }
        // 如果list2为空，直接返回list1
        if (list2 == null) {
            return list1;
        }
        // 比较 list1 和 list2 的头节点值，将较小值的节点作为当前节点；
        if (list1.val < list2.val) {
            // 对较小节点的下一个节点和另一个链表继续调用 mergeTwoLists 函数，并将结果连接到当前节点的下一个节点；
            list1.next = mergeTwoLists(list1.next, list2);
            return list1;
        } else {
            // 如果list2的值小于等于list1的值
            // 递归调用mergeTwoLists方法，将list1与list2的下一个节点合并，然后返回list2
            list2.next = mergeTwoLists(list1, list2.next);
            return list2;
        }
    }
}
```

## 448.找出数组中消失的数字

给你一个含 `n` 个整数的数组 `nums` ，其中 `nums[i]` 在区间 `[1, n]` 内。请你找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字，并以数组的形式返回结果。

**示例 1：**

```
输入：nums = [4,3,2,7,8]
```

```java
class Solution {
    // 寻找所有数组中消失的数字
    public List<Integer> findDisappearedNumbers(int[] nums) {
        // 数组长度
        int size = nums.length;
        // 创建一个新数组，长度比原数组多1
        int[] v = new int[size + 1];
        // 存储结果的列表
        List<Integer> res = new ArrayList<>();
        // 遍历原数组，标记出现过的数字
        for (int num : nums) {
            v[num] = 1;
        }
        // 遍历新数组，找出未出现过的数字，加入结果列表
        for (int i = 1; i < size + 1; ++i) {
            if (v[i] != 1) {
                res.add(i);
            }
        }
        // 返回结果列表
        return res;
    }
}
```

## 283.移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

```java
// 定义一个Solution类
class Solution {
    // 定义一个移动零的方法，参数为一个整型数组nums
    public void moveZeroes(int[] nums) {
        // 定义一个指针charpos，用于记录非零元素应该放置的位置
        int charpos = 0;

        // 遍历整型数组nums
        for (int i = 0; i < nums.length; ++i) {
            // 如果当前元素不为0
            if (nums[i] != 0) {
                // 将当前元素放到charpos位置，并将charpos向后移动一位
                nums[charpos++] = nums[i];
            }
        }

        // 将charpos之后的元素全部置为0
        for (int i = charpos; i < nums.length; ++i) {
            nums[i] = 0;
        }
    }
}
```

## 160.相交链表

```java
public class Solution {
    // 获取两个链表的相交节点
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int countA = 0; // 记录链表A的节点个数
        int countB = 0; // 记录链表B的节点个数
        ListNode tempA = headA; // 临时节点指向链表A的头节点
        ListNode tempB = headB; // 临时节点指向链表B的头节点
        
        // 遍历链表A，统计节点个数
        while(tempA != null) {
            countA++;
            tempA = tempA.next;
        }
        
        // 遍历链表B，统计节点个数
        while (tempB != null){
            countB++;
            tempB = tempB.next;
        }
        
        // 将两个链表的起始节点移动到同一起点
        if(countA > countB){
            for (int i = 0; i < countA - countB; i++){
                headA = headA.next;
            }
        }else {
            for (int i = 0; i < countB - countA; i++){
                headB = headB.next;
            }
        }
        
        // 同时遍历两个链表，直到找到相交节点
        while (headA != headB){
            headA = headA.next;
            headB = headB.next;
        }
        
        // 返回相交节点
        return headA;
    }
}
```

## 121.买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

- 示例 1：
- 输入：[7,1,5,3,6,4]
- 输出：5
  解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
- 示例 2：
- 输入：prices = [7,6,4,3,1]
- 输出：0
  解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

```java
// 定义一个Solution类
class Solution {
    // 定义一个方法，用于计算买卖股票的最佳时机
    public int maxProfit(int[] prices) {
        // dp[i]表示考虑i天内卖出股票的最大利润
        int dp[] = new int[prices.length];
        // 定义一个变量，用于存储最低股票价格
        int min = prices[0];
        // 遍历股票价格数组
        for (int i = 1; i < prices.length; i++) {
            // min表示到i天为止的最小价格
            min = Math.min(min, prices[i]);
            // dp[i]为考虑i天内卖出股票的最大利润，分两种情况，一是第i天不卖，即dp[i-1]；二是第i天卖，即是prices[i] - min
            dp[i] = Math.max(dp[i - 1], prices[i] - min);
        }
        // 返回考虑最后一天的最大利润
        return dp[prices.length - 1];
    }
}
```

## 155.最小栈

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

```java
class MinStack {
    // 定义一个私有成员变量minstack，用于存储最小值
    private Stack<Integer> minstack;
    // 定义一个私有成员变量stack，用于存储栈元素
    private Stack<Integer> stack;

    // 构造方法，初始化minstack和stack，并将Integer类型的最大值压入minstack
    public MinStack() {
        minstack = new Stack<>();
        stack = new Stack<>();
        minstack.push(Integer.MAX_VALUE);
    }

    // 将元素val压入栈stack，并更新minstack中的最小值
    public void push(int val) {
        stack.push(val);
        minstack.push(Math.min(val, minstack.peek()));
    }

    // 弹出栈顶元素，并同时弹出minstack中对应的最小值
    public void pop() {
        stack.pop();
        minstack.pop();
    }

    // 返回栈顶元素
    public int top() {
        return stack.peek();
    }

    // 返回minstack中的最小值
    public int getMin() {
        return minstack.peek();
    }
}
```

## 101.对称二叉树

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

<img src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" alt="img" style="zoom:80%;" />

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

```java
// 定义一个Solution类
class Solution {
    // 定义一个公共方法，用于判断二叉树是否对称
    public boolean isSymmetric(TreeNode root) {
        // 调用compare方法，比较二叉树的左右子树
        return compare(root.left, root.right);
    }

    // 定义一个私有方法，用于比较左右子树是否对称
    private boolean compare(TreeNode left, TreeNode right) {
        // 如果左右子树均为空，则对称
        if (left == null && right == null) {
            return true;
        }
        // 如果左右子树其中一个为空，则不对称
        if (left == null || right == null) {
            return false;
        }
        // 如果左右子树的节点值不相等，则不对称
        if (left.val != right.val) {
            return false;
        }
        // 递归比较左子树的左节点和右子树的右节点，以及左子树的右节点和右子树的左节点
        return compare(left.left, right.right) && compare(left.right, right.left);
    }
}
```

## 53.最大子序和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

```java
/**
 * 计算最大子数组和的解决方案类
 */
class Solution {
    /**
     * 计算最大子数组和
     * @param nums 给定的整数数组
     * @return 最大子数组和
     */
    public int maxSubArray(int[] nums) {
        int res = nums[0]; // 初始化最大子数组和为数组的第一个元素
        int[] dp = new int[nums.length]; // 创建一个与给定数组长度相同的数组dp，用于存储子问题的解
        dp[0] = nums[0]; // 初始化dp数组的第一个元素为给定数组的第一个元素
        for (int i = 1; i < nums.length; i++) { // 从第二个元素开始遍历给定数组
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); // 计算当前位置的最大子数组和，取当前元素与前一个元素的和与当前元素中的较大值
            res = Math.max(res, dp[i]); // 更新最大子数组和
        }
        return res; // 返回最大子数组和
    }
}
```

## 543.二叉树的直径

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

```java
class Solution {
    // 计算二叉树的直径
    public int diameterOfBinaryTree(TreeNode root) {
        // 创建一个长度为1的数组用于存储结果
        int[] ans = new int[1];
        // 调用深度优先搜索方法计算直径
        dfs(root, ans);
        // 返回直径结果
        return ans[0];
    }

    // 深度优先搜索方法，计算节点到节点的最长路径
    private int dfs(TreeNode root, int[] ans) {
        // 若节点为空，返回0
        if (root == null) {
            return 0;
        }
        // 递归计算左子树的深度
        int left = dfs(root.left, ans);
        // 递归计算右子树的深度
        int right = dfs(root.right, ans);
        // 更新直径结果为左右子树深度之和的最大值
        ans[0] = Math.max(ans[0], left + right);
        // 返回当前节点的深度，为左右子树深度的最大值加1
        return Math.max(left, right) + 1;
    }
}
```

## 70.爬楼梯

- 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

  每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

  **示例 1：**

  ```
  输入：n = 2
  输出：2
  解释：有两种方法可以爬到楼顶。
  1. 1 阶 + 1 阶
  2. 2 阶
  ```

```java
// 定义一个Solution类
class Solution {
    // 定义一个方法，用于计算爬楼梯的方法数
    public int climbStairs(int n) {
        // 创建一个长度为n+1的数组dp，用于存储每个台阶的爬楼梯方法数
        int[] dp = new int[n + 1];
        // 初始化dp数组的前两个元素
        dp[0] = 1;
        dp[1] = 1;
        // 从第二个台阶开始，计算每个台阶的爬楼梯方法数
        for (int i = 2; i <= n; i++) {
            // 当前台阶的爬楼梯方法数等于前两个台阶的爬楼梯方法数之和
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        // 返回第n个台阶的爬楼梯方法数
        return dp[n];
    }
}
```

## 141.环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

**示例 1：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom:80%;" />

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点
```

```java
public class Solution {
    // 检查链表是否有环
    public boolean hasCycle(ListNode head) {
        // 如果链表为空或只有一个节点，则肯定没有环
        if (head == null || head.next == null) {
            return false;
        }
        // 初始化慢指针和快指针
        ListNode slow = head;
        ListNode fast = head.next;
        // 当慢指针和快指针不相遇时，继续循环
        while (slow != fast) {
            // 如果快指针或快指针的下一个节点为空，则说明没有环
            if (fast == null || fast.next == null) {
                return false;
            }
            // 慢指针每次移动一步，快指针每次移动两步
            slow = slow.next;
            fast = fast.next.next;
        }
        // 当慢指针和快指针相遇时，说明有环
        return true;
    }
}
```

## 1.两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

```java
class Solution {
    // 定义一个Solution类
    public int[] twoSum(int[] nums, int target) {
        // 定义一个方法，传入一个整型数组nums和一个目标值target，返回一个整型数组
        Map<Integer, Integer> map = new HashMap<>();
        // 创建一个HashMap对象，用于存储数组元素及其对应的索引
        List<Integer> list = new ArrayList<>();
        // 创建一个ArrayList对象，用于存储符合条件的两个数的索引
        for (int i = 0; i < nums.length; i++) {
            // 遍历数组nums
            if (map.containsKey(target - nums[i])) {
                // 如果HashMap中存在目标值与当前元素之差的键
                list.add(map.get(target - nums[i]));
                // 将目标值与当前元素之差的索引加入list
                list.add(i);
                // 将当前元素的索引加入list
                break;
                // 跳出循环
            }
            map.put(nums[i], i);
            // 将当前元素及其索引存入HashMap
        }
        int[] res = new int[2];
        // 创建一个长度为2的整型数组
        res[0] = list.get(0);
        // 将list中第一个索引赋值给res的第一个元素
        res[1] = list.get(1);
        // 将list中第二个索引赋值给res的第二个元素
        return res;
        // 返回结果数组
    }
}
```

## 234.回文链表

```java
class Solution {
    // 判断给定的链表是否为回文链表
    public boolean isPalindrome(ListNode head) {
        // 使用栈来存储链表前半部分的节点值
        Deque<Integer> stack = new LinkedList<>();
        // 使用快慢指针找到链表中点
        ListNode fast = head, slow = head;
        while (fast != null && fast.next != null) {
            stack.push(slow.val);
            slow = slow.next;
            fast = fast.next.next;
        }
        // 链表节点个数为奇数时，跳过中间节点
        if (fast != null) {
            slow = slow.next;
        }
        // 从中点开始，与栈中的值逐个比较，判断链表是否为回文
        while (slow != null) {
            if (slow.val != stack.pop()) {
                return false;
            }
            slow = slow.next;
        }
        return true;
    }
}
```

## 20.有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

```
输入：s = "()"
输出：true
```

```java
class Solution {
    // 判断输入的字符串中的括号是否有效
    public boolean isValid(String s) {
        // 使用栈来存储左括号，便于匹配右括号
        Stack<Character> stack = new Stack<>();
        // 遍历字符串中的每个字符
        for (char c : s.toCharArray()) {
            // 如果是左括号，则入栈
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } 
            // 如果栈为空且遇到右括号，则返回false
            else if (stack.isEmpty()) {
                return false;
            } 
            // 匹配右括号与栈顶的左括号，如果匹配成功则出栈
            else if (c == ')' && stack.peek() == '('){
                stack.pop();
            } else if (c == '}' && stack.peek() == '{'){
                stack.pop();
            } else if (c == ']' && stack.peek() == '['){
                stack.pop();
            } 
            // 如果不是左括号也不匹配右括号，则返回false
            else {
                return false;
            }
        }
        // 最终判断栈是否为空，若为空则所有括号匹配成功
        return stack.isEmpty();
    }
}
```

## 78.子集

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]

```java
该代码实现的功能是生成给定数组的所有子集。
代码的具体步骤如下：
1. 创建一个空的列表`res`，用于存储所有子集。
2. 创建一个空的列表`list`，用于存储当前正在构建的子集。
3. 将空列表`list`添加到`res`中，作为初始的空子集。
4. 调用`backtrack`函数，开始构建子集。
5. 在`backtrack`函数中，如果`start`等于数组的长度，则表示已经遍历完所有元素，直接返回。
6. 使用一个循环，从`start`开始遍历数组中的元素。
7. 将当前元素添加到`list`中。
8. 将`list`添加到`res`中，作为一个新的子集。
9. 递归调用`backtrack`函数，传入更新后的`list`、`res`、`nums`和`i + 1`作为参数，继续构建子集。
10. 在递归调用返回后，将`list`中的最后一个元素移除，以便尝试下一个元素。
11. 重复步骤6-10，直到遍历完所有元素。
12. 返回最终的子集列表`res`。
/**
 * 子集
 */
class Solution {
    /**
     * 生成给定数组的所有子集
     * @param nums 给定的数组
     * @return 所有子集的列表
     */
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>(); // 存储结果的列表
        List<Integer> list = new ArrayList<>(); // 存储当前子集的列表
        res.add(new ArrayList<>(list)); // 将空集添加到结果列表中
        backtrack(res, list, nums, 0); // 回溯生成所有子集
        return res; // 返回结果列表
    }

    /**
     * 回溯生成所有子集
     * @param res 结果列表
     * @param list 当前子集的列表
     * @param nums 给定的数组
     * @param start 当前回溯的起始位置
     */
    private void backtrack(List<List<Integer>> res, List<Integer> list, int[] nums, int start) {
        if (start == nums.length) // 如果回溯的起始位置等于数组长度，说明已经遍历完所有元素，返回
            return;
        for (int i = start; i < nums.length; i++){ // 从起始位置开始遍历数组
            list.add(nums[i]); // 将当前元素加入当前子集
            res.add(new ArrayList<>(list)); // 将当前子集添加到结果列表中
            backtrack(res, list, nums, i + 1); // 递归回溯生成下一个子集
            list.remove(list.size() - 1); // 回溯，移除当前子集的最后一个元素
        }
    }
}
```

## 338.比特位计数

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**示例 1：**

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

**示例 2：**

```
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

```java
// 定义Solution类
class Solution {
    // 定义countBits方法，参数为整数n，返回一个整型数组
    public int[] countBits(int n) {
        // 创建一个长度为n+1的整型数组ans，用于存储结果
        int[] ans = new int[n + 1];
        // 循环遍历从1到n的每个整数
        for (int i = 1; i <= n; ++i) {
            // 计算ans[i]，使用i和i-1的与操作，再加1。ans[i] 实际上就是 ans[i & (i - 1)] 的值加上1，表示比 i 少一个1的数的二进制中1的个数再加上1
            ans[i] = ans[i & (i - 1)] + 1;
        }
        // 返回计算结果数组ans
        return ans;
    }
}
```

## 46.全排列

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

```java
class Solution {
    // 生成全排列
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>(); // 存储结果的列表
        if (nums == null || nums.length == 0) {
            return res; // 如果输入数组为空，则直接返回空结果列表
        }
        int len = nums.length; // 数组长度
        boolean[] visited = new boolean[len]; // 标记元素是否被访问过的数组
        List<Integer> path = new ArrayList<>(); // 存储当前路径的列表
        backtrack(nums, len, 0, visited, path, res); // 回溯生成全排列
        return res; // 返回结果列表
    }

    // 回溯生成全排列
    private void backtrack(int[] nums, int len, int depth, boolean[] visited, List<Integer> path, List<List<Integer>> res) {
        if (depth == len) { // 如果当前深度等于数组长度，说明找到一个全排列
            res.add(new ArrayList<>(path)); // 将当前路径加入结果列表
            return;
        }
        for (int i = 0; i < len; i++) {
            if (visited[i]) { // 如果元素已经被访问过，则跳过
                continue;
            }
            path.add(nums[i]); // 将当前元素加入路径
            visited[i] = true; // 标记当前元素为已访问
            backtrack(nums, len, depth + 1, visited, path, res); // 递归进入下一层
            path.remove(path.size() - 1); // 回溯，移除最后一个元素
            visited[i] = false; // 标记当前元素为未访问，以便其他路径使用
        } 
    }
}
```

## 22.括号生成

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

```java
class Solution {
    // 生成括号组合的方法
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<>();
        // 回溯法生成括号组合
        backtrack(ans, new StringBuilder(), 0, 0, n);
        return ans;
    }

    // 回溯法生成括号组合的具体实现
    public void backtrack(List<String> ans, StringBuilder path, int open, int close, int n) {
        // 当字符串长度等于2n时，表示生成了一个有效的括号组合，加入结果集
        if (path.length() == n * 2) {
            ans.add(path.toString());//path.toSring()
            return;
        }
        // 如果左括号数量小于n，可以添加左括号
        if (open < n) {
            path.append('(');
            backtrack(ans, path, open + 1, close, n);
            path.deleteCharAt(path.length() - 1);//path.deleteCharAt
        }
        // 如果右括号数量小于左括号数量，可以添加右括号
        if (close < open) {
            path.append(')');
            backtrack(ans, path, open, close + 1, n);
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```

## 94.二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

```java
class Solution {
    // 定义一个方法，实现二叉树的中序遍历
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();// 创建一个存放结果的列表
        if (root == null) {
            return res; // 如果根节点为空，直接返回空列表
        }
        Stack<TreeNode> stack = new Stack<>(); // 创建一个栈用于辅助遍历
        TreeNode cur = root;// 当前节点初始化为根节点
        while (cur != null || !stack.isEmpty()) { // 循环直到当前节点为空且栈为空
            while (cur != null) { // 将当前节点及其左子节点依次入栈
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop(); // 弹出栈顶节点，将节点值加入结果列表
            res.add(cur.val);
            cur = cur.right;  // 将当前节点指向右子节点，继续遍历右子树
        }
        // 返回最终结果列表
        return res;
    }
}
```

## 406.根据身高重建队列

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

示例 1：

- 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
- 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
- 解释：
  - 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
  - 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
  - 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
  - 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
  - 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
  - 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
  - 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

```java
/**
 * 根据身高重建队列
 */
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 根据身高降序排序，如果身高相同则按照k值升序排序
        Arrays.sort(people, (a, b) -> {
            if (a[0] != b[0]) {
                return b[0] - a[0];
            } else {
                return a[1] - b[1];
            }
        });
        // 创建一个动态数组用于存储重建后的队列
        List<int[]> res = new ArrayList<>();
        // 将每个人按照k值插入到对应的位置
        for (int[] p : people) {
            res.add(p[1], p);
        }
        // 将动态数组转换为二维数组并返回
        return res.toArray(new int[0][]);
    }
}
```

## 48.旋转图像

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img" style="zoom:50%;" />

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

**示例 2：**

<img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img" style="zoom: 50%;" />

```
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

```java
class Solution {
    // 旋转图像的方法
    public void rotate(int[][] matrix) {
        int n = matrix.length; // 获取矩阵的行数
        for (int i = 0; i < n; i++) { // 遍历矩阵的行
            for (int j = i; j < n; j++) { // 遍历矩阵的列，从第i列开始
                int temp = matrix[i][j]; // 临时存储当前元素的值
                matrix[i][j] = matrix[j][i]; // 交换当前元素和对角线上的元素
                matrix[j][i] = temp; // 将之前存储的值赋给对角线上的元素
            }
        }
        for (int i = 0; i < n; i++) { // 再次遍历矩阵的行
            for (int j = 0; j < n / 2; j++){ // 遍历矩阵的列，只需遍历一半
                int temp = matrix[i][j]; // 临时存储当前元素的值
                matrix[i][j] = matrix[i][n - 1 - j]; // 交换当前元素和对称位置的元素
                matrix[i][n - 1 - j] = temp; // 将之前存储的值赋给对称位置的元素
            }
        }
    }
}
```

## 39.组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

- 所有数字（包括 target）都是正整数。
- 解集不能包含重复的组合。

示例 1：

- 输入：candidates = [2,3,6,7], target = 7,
- 所求解集为： [ [7], [2,2,3] ]

示例 2：

- 输入：candidates = [2,3,5], target = 8,
- 所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ]

```java
/**
 * 组合总和问题的解决方案
 */
class Solution {
    /**
     * 求解组合总和
     * @param candidates 候选数字数组
     * @param target 目标和
     * @return 返回所有可能的组合
     */
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>(); // 存储结果的列表
        List<Integer> list = new ArrayList<>(); // 存储当前组合的列表
        dfs(candidates, target, 0, list, res); // 调用深度优先搜索函数
        return res; // 返回结果列表
    }
    /**
     * 深度优先搜索函数
     * @param candidates 候选数字数组
     * @param target 目标和
     * @param start 当前搜索的起始位置
     * @param list 当前组合的列表
     * @param res 存储结果的列表
     */
    private void dfs(int[] candidates, int target, int start, List<Integer> list, List<List<Integer>> res) {
        if (target < 0) { // 如果目标和小于0，说明当前组合不满足条件，直接返回
            return;
        }
        if (target == 0) { // 如果目标和等于0，说明当前组合满足条件，将其加入结果列表
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < candidates.length; i++) { // 遍历候选数字数组
            list.add(candidates[i]); // 将当前数字加入当前组合
            dfs(candidates, target - candidates[i], i, list, res); // 递归调用深度优先搜索函数
            list.remove(list.size() - 1); // 回溯，将当前数字从当前组合中移除
        }
    }
}
```

## 114.二叉树展开为链表

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

```java
class Solution {
    // 将二叉树展开为链表
    public void flatten(TreeNode root) {
        // 如果根节点为空，直接返回
        if (root == null) return;
        
        // 递归处理左子树
        flatten(root.left);
        // 递归处理右子树
        flatten(root.right);
        
        // 将根节点的左子树保存起来
        TreeNode left = root.left;
        // 将根节点的右子树保存起来
        TreeNode right = root.right;
        
        // 将根节点的左子树置空
        root.left = null;//不能忘记
        // 将根节点的右子树指向之前保存的左子树
        root.right = left;
        
        // 找到当前链表的末尾节点
        TreeNode p = root;//不能忘记建立临时节点
        while (p.right != null) {
            p = p.right;
        }
        
        // 将末尾节点的右子树指向之前保存的右子树
        p.right = right;
    }
}
```

## 238.除自身以外数组的乘积

给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。

**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

```java
class Solution {
    // 计算除自身以外数组的乘积
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] left = new int[n]; // 存储当前元素左侧所有元素的乘积
        int[] right = new int[n]; // 存储当前元素右侧所有元素的乘积
        int[] ans = new int[n]; // 存储最终结果
        left[0] = 1; // 初始化左侧第一个元素为1
        right[n - 1] = 1; // 初始化右侧最后一个元素为1

        // 计算每个元素左侧所有元素的乘积
        for (int i = 1; i < n; ++i) {
            left[i] = nums[i - 1] * left[i - 1];
        }

        // 计算每个元素右侧所有元素的乘积
        for (int i = n - 2; i >= 0; --i) {
            right[i] = nums[i + 1] * right[i + 1];
        }

        // 计算最终结果，即左侧所有元素乘以右侧所有元素
        for (int i = 0; i < n; ++i) {
            ans[i] = left[i] * right[i];
        }

        return ans; // 返回最终结果数组
    }
}
```

## 208.实现Trie前缀树

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

**示例：**

```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

```java
class Trie {
    private Trie[] children; // 存储子节点的数组
    private boolean isEnd; // 标记是否为单词结尾

    public Trie() {
        children = new Trie[26]; // 初始化26个子节点位置
        isEnd = false; // 初始时不是单词结尾
    }
    
    public void insert(String word) {
        Trie temp = this; // 从根节点开始
        for (char chr : word.toCharArray()) { // 遍历单词的每个字符
            if (temp.children[chr - 'a'] == null) // 如果当前字符对应的子节点为空
                temp.children[chr - 'a'] = new Trie(); // 创建新的子节点
            temp = temp.children[chr - 'a']; // 移动到下一个子节点
        }
        temp.isEnd = true; // 标记当前节点为单词结尾
    }

    public boolean search(String word) {
        Trie temp = this; // 从根节点开始
        for (char chr : word.toCharArray()) { // 遍历单词的每个字符
            if (temp.children[chr - 'a'] == null) // 如果当前字符对应的子节点为空
                return false; // 单词不存在
            temp = temp.children[chr - 'a']; // 移动到下一个子节点
        }
        return temp.isEnd; // 返回当前节点是否为单词结尾
    }

    public boolean startsWith(String prefix) {
        Trie temp = this; // 从根节点开始
        for (char chr : prefix.toCharArray()) { // 遍历前缀的每个字符
            if (temp.children[chr - 'a'] == null) // 如果当前字符对应的子节点为空
                return false; // 前缀不存在
            temp = temp.children[chr - 'a']; // 移动到下一个子节点
        }
        return true; // 存在以该前缀开头的单词
    }
}
```

## 105.中序和前序遍历构造二叉树

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1:**

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img" style="zoom:50%;" />

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

```java
class Solution {
    Map<Integer, Integer> map;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        map = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) { // 用map保存中序序列的数值对应位置
            map.put(inorder[i], i);
        }
        return findNode(preorder, 0, preorder.length, inorder, 0, inorder.length);
    }

    public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) {
        // 参数里的范围都是前闭后开
        if (inBegin >= inEnd || preBegin >= preEnd) {  // 不满足左闭右开，说明没有元素，返回空树
            return null;
        }
        int rootIndex = map.get(preorder[preBegin]);
        TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点
        int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定后序数列的个数
        root.left = findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1,
                inorder, inBegin, rootIndex);
        root.right = findNode(preorder, preBegin + lenOfLeft + 1, preEnd,
                inorder, rootIndex + 1, inEnd);

        return root;
    }
}

```

## 96.不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210113161941835.png" alt="img" style="zoom:50%;" />

```java
// 定义一个Solution类
class Solution {
    // 定义一个方法，用于计算不同的二叉搜索树的数量
    public int numTrees(int n) {
        // 创建一个长度为n+1的数组dp，用于存储计算结果
        int dp[] = new int[n + 1];
        // 初始化dp数组的前两个元素
        dp[0] = 1;
        dp[1] = 1;
        // 从i=2开始遍历到n，计算dp[i]的值
        for (int i = 2; i <= n; i++) {
            // 遍历j从1到i，计算dp[i]的值
            for (int j = 1; j <= i; j++) {
                // dp[i]的值等于dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        // 返回dp[n]，即不同的二叉搜索树的数量
        return dp[n];
    }
}
```

## 64.最小路径和

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

```java
class Solution {
    // 计算最小路径和
    public int minPathSum(int[][] grid) {
        int m = grid.length; // 获取网格行数
        int n = grid[0].length; // 获取网格列数
        int[][] dp = new int[m][n]; // 创建一个二维数组用于存储到达每个位置的最小路径和
        dp[0][0] = grid[0][0]; // 初始化起点的最小路径和为起点值

        // 计算第一列每个位置的最小路径和
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }

        // 计算第一行每个位置的最小路径和
        for (int i = 1; i < n; i++) {
            dp[0][i] = dp[0][i - 1] + grid[0][i];
        }

        // 计算其余位置的最小路径和
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }

        return dp[m - 1][n - 1]; // 返回右下角位置的最小路径和
    }
}
```

## 538.将二叉搜索树转化为累加树

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

**注意：**本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同

**示例 1：**

**<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt="img" style="zoom:50%;" />**

```
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

```java
class Solution {
    int sum = 0; // 定义一个整型变量sum，用于存储累加的值

    // 将二叉搜索树转换为累加树的方法
    public TreeNode convertBST(TreeNode root) {
        if (root == null) { // 如果当前节点为空，则返回null
            return null;
        }
        root.right = convertBST(root.right); // 递归遍历右子树
        sum += root.val; // 累加当前节点的值到sum中
        root.val = sum; // 更新当前节点的值为累加值
        root.left = convertBST(root.left); // 递归遍历左子树
        return root; // 返回根节点
    }
}
```

## 148.排序链表

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img" style="zoom:50%;" />

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

**示例 2：**

<img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img" style="zoom:50%;" />

```
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
```

**示例 3：**

```
输入：head = []
输出：[]
```

```java
public class Solution {
    // 对链表进行排序
    public ListNode sortList(ListNode head) {
        // 如果链表为空，直接返回null
        if (head == null) return null;

        // 创建一个ArrayList用于存储链表节点
        List<ListNode> list = new ArrayList<>();
        ListNode ptr = head;
        // 遍历链表，将节点加入到list中
        while (ptr != null) {
            list.add(ptr);
            ptr = ptr.next;
        }
        // 使用Collections对list进行排序，按节点的值升序排列
        Collections.sort(list, (a, b) -> (a.val - b.val));
        // 将排序后的节点重新连接成链表
        for (int i = 0; i < list.size(); i++) {
            if (i != list.size() - 1) {
                list.get(i).next = list.get(i + 1);
            } else {
                list.get(i).next = null;
            }
        }
        // 返回排序后的链表的头节点
        return list.get(0);
    }
}
```

## 236.二叉树的最近公共祖先

```java
/**
 * 二叉树的最近公共祖先
 */
class Solution {
    /**
     * 查找二叉树中两个节点的最近公共祖先
     *
     * @param root 二叉树的根节点
     * @param p    第一个节点
     * @param q    第二个节点
     * @return 最近公共祖先节点
     */
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 如果根节点为空或者根节点等于p或者根节点等于q，则返回根节点
        if (root == null || root == p || root == q)
            return root;
        // 在左子树中查找p和q的最近公共祖先
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        // 在右子树中查找p和q的最近公共祖先
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // 如果左子树和右子树都找到了最近公共祖先，则返回根节点
        if (left != null && right != null)
            return root;
        // 如果只有左子树找到了最近公共祖先，则返回左子树的最近公共祖先
        return left != null ? left : right;
    }
}
```

## 739.每日温度

请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

```java
// 定义一个类Solution
class Solution {
    // 定义一个方法dailyTemperatures，参数为一个整型数组temperatures，返回一个整型数组
    public int[] dailyTemperatures(int[] temperatures) {
        // 创建一个长度与temperatures相同的整型数组result
        int[] result = new int[temperatures.length];
        // 创建一个栈stack，用于存储数组元素的索引
        Stack<Integer> stack = new Stack<>();
        // 遍历temperatures数组
        for (int i = 0; i < temperatures.length; i++) {
            // 当栈不为空且当前温度大于栈顶元素对应的温度时，进入循环
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                // 弹出栈顶元素的索引
                int index = stack.pop();
                // 计算当前索引与弹出的索引之间的距离，即相邻更高温度的天数
                result[index] = i - index;
            }
            // 将当前索引入栈
            stack.push(i);
        }
        // 返回结果数组result
        return result;
    }
}
```

## 287.寻找重复数

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

**示例 1：**

```
输入：nums = [1,3,4,2,2]
输出：2
```

**示例 2：**

```
输入：nums = [3,1,3,4,2]
输出：3
```

**示例 3 :**

```
输入：nums = [3,3,3,3,3]
输出：3
```

```java
class Solution {
    // 寻找重复数的方法
    public int findDuplicate(int[] nums) {
        // 初始化慢指针和快指针
        int slow = 0, fast = 0;
        // 使用快慢指针找到相遇点
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        // 将慢指针重新指向起点，快慢指针以相同速度移动直到相遇，相遇点即为重复数
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        // 返回重复数
        return slow;
    }
}
```

## 49.字母异位词分组

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

```java
class Solution {
    // 使用HashMap存储分组后的异位词
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        // 遍历输入的字符串数组
        for (String str : strs) {
            // 将字符串转换为字符数组并排序
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            // 将排序后的字符数组转换为字符串作为HashMap的key
            String key = String.valueOf(chars);
            // 获取key对应的值，若不存在则新建一个空列表
            List<String> list = map.getOrDefault(key, new ArrayList<>());
            // 将当前字符串添加到对应的异位词分组中
            list.add(str);
            // 更新HashMap中的值
            map.put(key, list);
        }
        // 返回HashMap中所有值的列表，即为分组后的异位词列表
        return new ArrayList<>(map.values());
    }
}
```

## 647.回文子串

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

**示例 1：**

```
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

```java
class Solution {
    public int countSubstrings(String s) {
        // dp[i][j]表示s[i]到s[j]是否是回文串，是就是1，不是就是0
        int[][] dp = new int[s.length()][s.length()];
        int count = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            for (int j = i; j < s.length(); j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (j - i <= 1) {
                        dp[i][j] = 1; // 如果i和j相邻或者相等，则s[i]到s[j]是回文串
                        count++; // 回文串数量加1
                    } else {
                        dp[i][j] = dp[i + 1][j - 1]; // 如果s[i]到s[j]是回文串，则s[i+1]到s[j-1]也是回文串
                        if (dp[i][j] == 1) {
                            count++; // 回文串数量加1
                        }
                    }
                }
            }
        }
        return count; // 返回回文串的数量
    }
}
```

## 62.不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

示例 1：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210110174033215.png" alt="img" style="zoom:50%;" />

- 输入：m = 3, n = 7
- 输出：28

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int dp[][] = new int[m][n];  // 创建一个二维数组dp，用于存储路径数量
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;  // 初始化第一列的路径数量为1，因为只能向下走
        }
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;  // 初始化第一行的路径数量为1，因为只能向右走
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  // 动态规划，当前位置的路径数量等于上方位置和左方位置的路径数量之和
            }
        }
        return  dp[m - 1][n - 1];  // 返回右下角位置的路径数量
    }
}
```

## 215.数组中第k个最大元素

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

```java
// 定义一个Solution类
class Solution {
    // 定义一个方法，用于找到数组中第K个最大的元素
    public int findKthLargest(int[] nums, int k) {
        // 对数组进行排序
        Arrays.sort(nums);
        // 返回数组中倒数第K个元素
        return nums[nums.length - k];
    }
}
```

## 11.盛水最多的容器

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

**示例 1：**

<img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" style="zoom:50%;" />

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

```java
// 定义Solution类
class Solution {
    // 定义maxArea方法，参数为整型数组height，返回值为整型
    public int maxArea(int[] height) {
        // 初始化左指针left为0，右指针right为height数组的长度减1
        int left = 0, right = height.length - 1;
        // 初始化结果ans为0
        int ans = 0;
        // 当左指针小于右指针时循环执行
        while (left < right) {
            // 计算当前区域的面积，取左右指针对应高度的最小值乘以宽度
            int area = (right - left) * Math.min(height[left], height[right]);
            // 更新结果ans为当前面积area和ans的较大值
            ans = Math.max(ans, area);
            // 如果左指针对应高度小于右指针对应高度，则左指针右移一位
            if (height[left] < height[right]) {
                left++;
            } else {
                // 否则右指针左移一位
                right--;
            }
        }
        // 返回最大面积ans
        return ans;
    }
}
```

## 102.二叉树的层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

```java
// 定义Solution类
class Solution {
    // 定义levelOrder方法，参数为根节点root
    public List<List<Integer>> levelOrder(TreeNode root) {
        // 创建一个队列用于存储节点
        Queue<TreeNode> queue = new LinkedList<>();
        // 创建一个列表用于存储结果
        List<List<Integer>> res = new ArrayList<>();
        // 如果根节点为空，直接返回结果列表
        if (root == null) {
            return res;
        }
        // 将根节点加入队列
        queue.add(root);
        // 循环直到队列为空
        while (!queue.isEmpty()) {
            // 获取当前队列的大小
            int size = queue.size();
            // 创建一个列表用于存储当前层的节点值
            List<Integer> list = new ArrayList<>();
            // 遍历当前层的节点
            for (int i = 0; i < size; i++) {
                // 弹出队首节点
                TreeNode node = queue.poll();
                // 将节点值加入当前层列表
                list.add(node.val);
                // 如果左子节点不为空，加入队列
                if (node.left != null) {
                    queue.add(node.left);
                }
                // 如果右子节点不为空，加入队列
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
            // 将当前层节点值列表加入结果列表
            res.add(list);
        }
        // 返回结果列表
        return res;
    }
}
```

## 347.前k个高频元素

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        //遍历nums数组，将每个元素和出现次数存入map中
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        //将map中的元素存入list中
        List<Map.Entry<Integer, Integer>> list = new ArrayList<>(map.entrySet());
        //对list进行排序，按照value值降序排列
        list.sort((o1, o2) -> o2.getValue() - o1.getValue());
        //定义一个长度为k的数组，用于存放结果
        int[] res = new int[k];
        //遍历list，将前k个元素存入res中
        for (int i = 0; i < k; i++) {
            res[i] = list.get(i).getKey();
        }
        //返回结果
        return res;
    }
}
```

## 337.打家劫舍III

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210223173849619.png" alt="337.打家劫舍III" style="zoom:50%;" />

```java
/**
 * 打家劫舍 III
 */
class Solution {
    /**
     * 计算能够偷取的最大金额
     * @param root 根节点
     * @return 最大金额
     */
    public int rob(TreeNode root) {
        // 调用后序遍历方法，获取每个节点能够偷取的最大金额
        int[] dp = postorder(root);
        // 返回根节点能够偷取的最大金额
        return Math.max(dp[0], dp[1]);
    }

    /**
     * 后序遍历二叉树，计算每个节点能够偷取的最大金额
     * @param root 当前节点
     * @return 当前节点能够偷取的最大金额
     */
    private int[] postorder(TreeNode root) {
        // 如果当前节点为空，则返回金额为0的数组
        if (root == null) {
            return new int[]{0, 0};
        }
        // 递归调用后序遍历方法，计算左子树节点能够偷取的最大金额
        int[] left = postorder(root.left);
        // 递归调用后序遍历方法，计算右子树节点能够偷取的最大金额
        int[] right = postorder(root.right);
        // 创建一个长度为2的数组，用于存储当前节点能够偷取的最大金额，dp[0]表示当前节点不偷取，dp[1]表示当前节点偷取
        int[] dp = new int[2];
        // 当前节点不偷取时，左子树和右子树节点能够偷取的最大金额之和
        dp[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        // 当前节点偷取时，当前节点的值加上左子树不偷取和右子树不偷取的最大金额之和
        dp[1] = root.val + left[0] + right[0];
        // 返回当前节点能够偷取的最大金额
        return dp;
    }
}
```

## 249.完全平方数

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

```java
class Solution {
    // 计算n的完全平方数
    public int numSquares(int n) {
        // 创建一个数组dp，用于存储n以内每个数的最小完全平方数数量
        int [] dp = new int[n + 1];
        // 将dp数组初始化为最大值
        Arrays.fill(dp, Integer.MAX_VALUE);
        // 0本身就是完全平方数，所以数量为0
        dp[0] = 0;
        // 遍历1到n，计算每个数的最小完全平方数数量
        for (int i = 1; i *  i <= n; i++) {
            for (int j = i * i; j <= n; j++) {
                // 更新dp[j]，取当前dp[j]和dp[j - i * i] + 1的较小值
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        // 返回n的最小完全平方数数量
        return dp[n];
    }
}
```

## 399.除法求值

给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]` 。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。

另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。

返回 **所有问题的答案** 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 `-1.0` 替代这个答案。

**注意：**输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

**注意：**未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。

**示例 1：**

```
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
注意：x 是未定义的 => -1.0
```

```java
class Solution {
    // 计算商值
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        // 存储结果
        double[] res = new double[queries.size()];
        // 构建图结构
        Map<String, Map<String, Double>> graph = new HashMap<>();
        // 遍历方程式，构建图
        for (int i = 0; i < equations.size(); i++) {
            String a = equations.get(i).get(0);
            String b = equations.get(i).get(1);
            double val = values[i];
            graph.putIfAbsent(a, new HashMap<>());
            graph.putIfAbsent(b, new HashMap<>());
            graph.get(a).put(b, val);
            graph.get(b).put(a, 1.0 / val);
        }
        // 遍历查询列表
        for (int i = 0; i < queries.size(); i++) {
            String a = queries.get(i).get(0);
            String b = queries.get(i).get(1);
            // 使用深度优先搜索计算结果
            res[i] = dfs(graph, a, b, new HashSet<>());
        }
        return res;
    }

    // 深度优先搜索
    private double dfs(Map<String, Map<String, Double>> graph, String a, String b, Set<String> visited) {
        // 如果图中不包含节点a，返回-1.0
        if (!graph.containsKey(a)) {
            return -1.0;
        }
        visited.add(a);
        // 如果节点a直接连接节点b，返回对应的值
        if (graph.get(a).containsKey(b)) {
            return graph.get(a).get(b);
        }
        // 遍历节点a的邻居节点
        for (String key : graph.get(a).keySet()) {
            if (!visited.contains(key)) {
                // 递归计算结果
                double res = dfs(graph, key, b, visited);
                if (res != -1.0) {
                    // 返回计算结果
                    return graph.get(a).get(key) * res;
                }
            }
        }
        return -1.0;
    }
}
```

## 309.最佳买卖股票时机含冷冻期

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例:

- 输入: [1,2,3,0,2]
- 输出: 3
- 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]



动规五部曲，分析如下：

1. 确定dp数组以及下标的含义

dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。

**其实本题很多同学搞的比较懵，是因为出现冷冻期之后，状态其实是比较复杂度**，例如今天买入股票、今天卖出股票、今天是冷冻期，都是不能操作股票的。

具体可以区分出如下四个状态：

- 状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
- 不持有股票状态，这里就有两种卖出股票状态
  - 状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
  - 状态三：今天卖出股票
- 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/518d5baaf33f4b2698064f8efb42edbf.png" alt="img" style="zoom: 67%;" />

j的状态为：

- 0：状态一
- 1：状态二
- 2：状态三
- 3：状态四

很多题解为什么讲的比较模糊，是因为把这四个状态合并成三个状态了，其实就是把状态二和状态四合并在一起了。

从代码上来看确实可以合并，但从逻辑上分析合并之后就很难理解了，所以我下面的讲解是按照这四个状态来的，把每一个状态分析清楚。

如果大家按照代码随想录顺序来刷的话，会发现 买卖股票最佳时机 1，2，3，4 的题目讲解中

- [动态规划：121.买卖股票的最佳时机(opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)
- [动态规划：122.买卖股票的最佳时机II(opens new window)](https://programmercarl.com/0122.买卖股票的最佳时机II（动态规划）.html)
- [动态规划：123.买卖股票的最佳时机III(opens new window)](https://programmercarl.com/0123.买卖股票的最佳时机III.html)
- [动态规划：188.买卖股票的最佳时机IV(opens new window)](https://programmercarl.com/0188.买卖股票的最佳时机IV.html)

「今天卖出股票」我是没有单独列出一个状态的归类为「不持有股票的状态」，而本题为什么要单独列出「今天卖出股票」 一个状态呢？

因为本题我们有冷冻期，而冷冻期的前一天，只能是 「今天卖出股票」状态，如果是 「不持有股票状态」那么就很模糊，因为不一定是 卖出股票的操作。

如果没有按照 代码随想录 顺序去刷的录友，可能看这里的讲解 会有点困惑，建议把代码随想录本篇之前股票内容的讲解都看一下，领会一下每天 状态的设置。

**注意这里的每一个状态，例如状态一，是持有股票股票状态并不是说今天一定就买入股票，而是说保持买入股票的状态即：可能是前几天买入的，之后一直没操作，所以保持买入股票的状态**。

1. 确定递推公式

**达到买入股票状态**（状态一）即：dp[i] [0]，有两个具体操作：

- 操作一：前一天就是持有股票状态（状态一），dp[i] [0] = dp[i - 1] [0]
- 操作二：今天买入了，有两种情况
  - 前一天是冷冻期（状态四），dp[i - 1] [3] - prices[i]
  - 前一天是保持卖出股票的状态（状态二），dp[i - 1] [1] - prices[i]

那么dp[i] [0] = max(dp[i - 1] [0], dp[i - 1] [3] - prices[i], dp[i - 1] [1] - prices[i]);

**达到保持卖出股票状态**（状态二）即：dp[i] [1]，有两个具体操作：

- 操作一：前一天就是状态二
- 操作二：前一天是冷冻期（状态四）

dp[i] [1] = max(dp[i - 1] [1], dp[i - 1] [3]);

**达到今天就卖出股票状态**（状态三），即：dp[i] [2] ，只有一个操作：

昨天一定是持有股票状态（状态一），今天卖出

即：dp[i] [2] = dp[i - 1] [0] + prices[i];

**达到冷冻期状态**（状态四），即：dp[i][3]，只有一个操作：

昨天卖出了股票（状态三）

dp[i] [3] = dp[i - 1] [2];

综上分析，递推代码如下：

```cpp
dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
dp[i][2] = dp[i - 1][0] + prices[i];
dp[i][3] = dp[i - 1][2];
```

1. dp数组如何初始化

这里主要讨论一下第0天如何初始化。

如果是持有股票状态（状态一）那么：dp[0] [0] = -prices[0]，一定是当天买入股票。

保持卖出股票状态（状态二），这里其实从 「状态二」的定义来说 ，很难明确应该初始多少，这种情况我们就看递推公式需要我们给他初始成什么数值。

如果i为1，第1天买入股票，那么递归公式中需要计算 dp[i - 1] [1] - prices[i] ，即 dp[0] [1] - prices[1]，那么大家感受一下 dp[0] [1] （即第0天的状态二）应该初始成多少，只能初始为0。想一想如果初始为其他数值，是我们第1天买入股票后 手里还剩的现金数量是不是就不对了。

今天卖出了股票（状态三），同上分析，dp[0] [2]初始化为0，dp[0] [3]也初始为0。

1. 确定遍历顺序

从递归公式上可以看出，dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。

```java
/**
 * 买卖股票的最佳时机含冷冻期
 */
class Solution {
    public int maxProfit(int[] prices) {
        // 创建二维数组dp，用于记录每天的股票状态
        int dp[][] = new int[prices.length][4];
        // 初始化第一天的股票状态
        dp[0][0] = -prices[0];
        // 遍历每一天的股票状态
        for (int i = 1; i < prices.length; i++) {
            // 计算第i天持有股票的最大收益
            dp[i][0] = Math.max(dp[i -1][0], Math.max(dp[i - 1][1] - prices[i], dp[i - 1][3] - prices[i]));
            // 计算第i天保持不持有股票的最大收益
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
            // 计算第i天卖出的最大收益
            dp[i][2] = dp[i - 1][0] + prices[i];
            // 计算第i天处于冷冻期的最大收益
            dp[i][3] = dp[i - 1][2];
        }
        // 返回最后一天的最大收益
        return Math.max(dp[prices.length - 1][1], Math.max(dp[prices.length - 1][2], dp[prices.length - 1][3]));
    }
}
```

## 75.颜色分类

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

```java
class Solution {
    // 定义一个方法，用于对颜色进行分类
    public void sortColors(int[] nums) {
        // 外层循环遍历数组
        for (int i = 0; i < nums.length; i++) {
            // 内层循环遍历当前元素之后的元素
            for (int j = i + 1; j < nums.length; j++){
                // 如果当前元素大于后面的元素，交换它们的位置
                if (nums[i] > nums[j]) {
                    int temp = nums[i];
                    nums[i] = nums[j];
                    nums[j] = temp;
                }
            }
        }
    }
}
```

## 437.路径总和III

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

**示例 2：**

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```

```java
class Solution {
    // 计算从根节点到叶子节点的路径和等于目标和的路径数量
    public int pathSum(TreeNode root, int targetSum) {
        // 如果根节点为空，返回0
        if (root == null) {
            return 0;
        }
        // 返回以当前节点为起点的路径和等于目标和的路径数量，加上左子树和右子树的路径和等于目标和的路径数量
        return dfs(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);
    }

    // 递归计算以当前节点为起点的路径和等于目标和的路径数量
    private int dfs(TreeNode root, int targetSum) {
        // 如果当前节点为空，返回0
        if (root == null) {
            return 0;
        }
        int res = 0;
        // 如果当前节点的值等于目标和，路径数量加1
        if (root.val == targetSum) {
            res++; 
        }
        // 继续递归计算左子树和右子树的路径和等于目标和的路径数量
        res += dfs(root.left, targetSum - root.val);
        res += dfs(root.right, targetSum - root.val);
        return res;
    }
}
```

## 17.电话号码的字母组合

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)



**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```

```java
/**
 * 电话号码的字母组合
 */
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<>();
        if (digits.length() == 0) {
            return res;
        }
        // 数字到字母的映射关系
        String[] map = new String[]{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv",  "wxyz"};
        // 回溯法获取字母组合
        backtrack(res, map, digits, 0, new StringBuilder());
        return res;
    }

    private void backtrack(List<String> res, String[] map, String digits, int index, StringBuilder sb) {
        // 如果已经处理完所有数字，则将当前字母组合加入结果列表
        if (index == digits.length()) {
            res.add(sb.toString());
            return;
        }
        // 获取当前数字对应的字母集合
        String letters = map[digits.charAt(index) - '0'];
        // 遍历当前数字对应的字母集合
        for (int i = 0; i < letters.length(); i++) {
            // 将当前字母加入字母组合
            sb.append(letters.charAt(i));
            // 递归处理下一个数字
            backtrack(res, map, digits, index + 1, sb);
            // 回溯，将当前字母从字母组合中删除
            sb.deleteCharAt(sb.length() - 1);                                                                                  
        }
    }
}
```

## 621.任务调度器

给你一个用字符数组 `tasks` 表示的 CPU 需要执行的任务列表，用字母 A 到 Z 表示，以及一个冷却时间 `n`。每个周期或时间间隔允许完成一项任务。任务可以按任何顺序完成，但有一个限制：两个 **相同种类** 的任务之间必须有长度为 `n` 的冷却时间。

返回完成所有任务所需要的 **最短时间间隔** 。

**示例 1：**

```
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 
```

```java
class Solution {
    // 计算任务调度器执行任务的最小时间
    public int leastInterval(char[] tasks, int n) {
        // 统计每种任务出现的次数
        int[] cnt = new int[26];
        for (char t : tasks) {
            cnt[t - 'A']++;
        }
        // 对任务出现次数进行排序
        Arrays.sort(cnt);
        // 计算最大间隔数和最大空闲时间
        int mx = cnt[25] - 1, idle = mx * n;
        // 遍历任务，计算空闲时间
        for (int i = 24; i >= 0 && cnt[i] > 0; i--) {
            idle -= Math.min(cnt[i], mx);
        }
        // 返回最小时间
        return idle > 0 ? idle + tasks.length : tasks.length;
    }
}
```

## 207.课程表

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

**示例 2：**

```
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```

```java
class Solution {
    // 判断是否可以完成课程安排
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 创建一个邻接表来表示课程之间的依赖关系
        List<List<Integer>> graph = new ArrayList<>();
        // 初始化邻接表
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<>());
        }
        // 构建邻接表
        for (int[] edge : prerequisites) {
            graph.get(edge[1]).add(edge[0]);
        }
        // 记录节点的访问状态，0表示未访问，1表示正在访问，2表示已访问且不存在环
        int[] visited = new int[numCourses];
        // 遍历每个节点，判断是否存在环
        for (int i = 0; i < numCourses; i++) {
            if (hasRing(graph, visited, i)) {
                return false;
            }
        }
        return true;
    }

    // 判断从节点i开始是否存在环
    private boolean hasRing(List<List<Integer>> graph, int[] visited, int i) {
        // 如果节点i已经在当前路径中，则存在环
        if (visited[i] == 1) {
            return true;
        }
        // 如果节点i已经被访问过，说明不存在环
        if (visited[i] == 2) {
            return false;
        }
        // 将节点i标记为正在访问
        visited[i] = 1;
        // 遍历节点i的邻居节点
        for (int j : graph.get(i)) {
            // 递归判断邻居节点是否存在环
            if (hasRing(graph, visited, j)) {
                return true;
            }
        }
        // 将节点i标记为已访问
        visited[i] = 2;
        return false;
    }
}
```

## 142.环形链表II

```java
public class Solution {
    // 寻找环形链表的入口节点
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head; // 快指针，每次移动两步
        ListNode slow = head; // 慢指针，每次移动一步
        while(fast != null && fast.next != null) { // 当快指针和快指针的下一个节点都不为空时循环
            fast = fast.next.next; // 快指针移动两步
            slow = slow.next; // 慢指针移动一步
            if(fast == slow){ // 当快指针追上慢指针，表示有环
                ListNode temp = fast; // 临时节点指向相遇节点
                while(head != temp){ // 循环直到相遇节点等于头节点
                    head = head.next; // 头节点向后移动
                    temp = temp.next; // 临时节点向后移动
                }
                return temp; // 返回环的入口节点
            }
        }
        return null; // 没有环，返回null
    }
}
```

## 394.字符串解码*

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

**示例 1：**

```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

**示例 2：**

```
输入：s = "3[a2[c]]"
输出："accaccacc"
```

**示例 3：**

```
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

```java
class Solution {
    // 定义一个解码字符串的方法
    public String decodeString(String s) {
        String ret = ""; // 存储解码后的结果
        Stack<String> strings = new Stack<>(); // 用于存储字符串的栈
        Stack<Integer> ints = new Stack<>(); // 用于存储数字的栈
        int pos = 0, num = 0, size = s.length(); // 初始化位置、数字和字符串长度
        String temp = ""; // 临时存储字符串
        while (pos < size) {
            if (ints.isEmpty() && Character.isLetter(s.charAt(pos))) {
                ret += s.charAt(pos); // 如果数字栈为空且当前字符是字母，则直接加入结果字符串
            } else {
                if (Character.isDigit(s.charAt(pos))) {
                    num = num * 10 + (s.charAt(pos) - '0'); // 如果是数字，则计算数字的值
                } else if (s.charAt(pos) == '[') {
                    ints.push(num); // 遇到'['，将数字压入数字栈
                    strings.push(""); // 并将空字符串压入字符串栈
                    num = 0; // 重置数字
                } else if (Character.isLetter(s.charAt(pos))) {
                    strings.push(strings.pop() + s.charAt(pos)); // 如果是字母，则将当前字母加入栈顶字符串
                } else {
                    int tempnum = ints.pop(); // 弹出数字栈顶元素
                    String tempstring = strings.pop(); // 弹出字符串栈顶元素
                    for (int i = 0; i < tempnum; i++) {
                        temp += tempstring; // 将字符串重复tempnum次并存入temp中
                    }
                    if (!strings.isEmpty()) {
                        strings.push(strings.pop() + temp); // 如果字符串栈不为空，将temp加入栈顶字符串
                    } else {
                        ret += temp; // 否则将temp加入结果字符串
                    }
                    temp = ""; // 重置temp
                }
            }
            pos++; // 移动位置指针
        }
        return ret; // 返回解码后的结果字符串
    }
}
```

## 200.岛屿数量

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220726093256.png" alt="img" style="zoom: 50%;" />



本题思路，是用遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。

在遇到标记过的陆地节点和海洋节点的时候直接跳过。 这样计数器就是最终岛屿的数量。

下面的代码使用的是深度优先搜索 DFS 的做法。为了统计岛屿数量同时不重复记录，每当我们搜索到一个岛后，就将这个岛 “淹没” —— 将这个岛所占的地方从 “1” 改为 “0”，这样就不用担心后续会重复记录这个岛屿了。而 DFS 的过程就体现在 “淹没” 这一步中。详见代码：

```java
public int numIslands(char[][] grid) {
    int res = 0; //记录找到的岛屿数量
    for(int i = 0;i < grid.length;i++){
        for(int j = 0;j < grid[0].length;j++){
        	//找到“1”，res加一，同时淹没这个岛
            if(grid[i][j] == '1'){
                res++;
                dfs(grid,i,j);
            }
        }
    }
    return res;
}
//使用DFS“淹没”岛屿
public void dfs(char[][] grid, int i, int j){
	//搜索边界：索引越界或遍历到了"0"
    if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') return;
    //将这块土地标记为"0"
    grid[i][j] = '0';
    //根据"每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成"，对上下左右的相邻顶点进行dfs
    dfs(grid,i - 1,j);
    dfs(grid,i + 1,j);
    dfs(grid,i,j + 1);
    dfs(grid,i,j - 1);
}
```

## 146. LRU缓存

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

```java
class LRUCache {
    int size; // 缓存当前大小
    int cap; // 缓存容量
    Map<Integer, LinkedListNode> map; // 存储键值对的哈希表
    LinkedList<LinkedListNode> LRU; // 存储最近访问的节点的双向链表

    class LinkedListNode {
        int key; // 节点的键
        int value; // 节点的值

        public LinkedListNode(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    public LRUCache(int capacity) {
        size = 0; // 初始化缓存大小为0
        cap = capacity; // 初始化缓存容量
        map = new HashMap<>(); // 初始化哈希表
        LRU = new LinkedList<>(); // 初始化双向链表
    }

    public int get(int key) {
        if (!map.containsKey(key)) { // 如果哈希表中不包含该键，返回-1
            return -1;
        }
        LinkedListNode node = map.get(key); // 获取节点
        int ret = node.value; // 获取节点的值
        LRU.remove(node); // 从双向链表中移除节点
        LRU.addFirst(node); // 将节点添加到双向链表头部
        return ret; // 返回节点的值
    }

    public void put(int key, int value) {
        if (size == cap && !map.containsKey(key)) { // 如果缓存已满且哈希表中不包含该键
            LinkedListNode lastNode = LRU.removeLast(); // 移除双向链表尾部节点
            map.remove(lastNode.key); // 从哈希表中移除对应的键值对
            size--; // 缓存大小减一
        }

        if (map.containsKey(key)) { // 如果哈希表中包含该键
            LinkedListNode node = map.get(key); // 获取节点
            LRU.remove(node); // 从双向链表中移除节点
            size--; // 缓存大小减一
        }

        LinkedListNode newNode = new LinkedListNode(key, value); // 创建新节点
        LRU.addFirst(newNode); // 将新节点添加到双向链表头部
        map.put(key, newNode); // 在哈希表中存储新节点
        size++; // 缓存大小加一
    }
}
```

## 438.找到字符串中所有的字母异位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

**示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

```java
class Solution {
    // 寻找字符串s中所有p的字母异位词的起始索引
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> ans = new ArrayList<>(); // 用于存储结果的列表
        if (s.length() < p.length()) { // 如果s的长度小于p的长度，直接返回空列表
            return ans;
        }
        int[] cnt1 = new int[26]; // 用于统计p中各字母出现次数的数组
        int[] cnt2 = new int[26]; // 用于统计s中当前窗口内各字母出现次数的数组
        for (int i = 0; i < p.length(); ++i) {
            ++cnt1[p.charAt(i) - 'a']; // 统计p中各字母出现次数
            ++cnt2[s.charAt(i) - 'a']; // 统计s中前p.length()个字符的出现次数
        }
        if (Arrays.equals(cnt1, cnt2)) { // 如果初始窗口内p和s中各字母出现次数相同，加入结果列表
            ans.add(0);
        }
        for (int i = p.length(); i < s.length(); ++i) {
            ++cnt2[s.charAt(i) - 'a']; // 移动窗口，新增一个字符
            --cnt2[s.charAt(i - p.length()) - 'a']; // 移动窗口，移除一个字符
            if (Arrays.equals(cnt1, cnt2)) { // 如果窗口内p和s中各字母出现次数相同，加入结果列表
                ans.add(i - p.length() + 1);
            }
        }
        return ans; // 返回结果列表
    }
}
```

## 416.分割等和子集

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200

示例 1:

- 输入: [1, 5, 11, 5]
- 输出: true
- 解释: 数组可以分割成 [1, 5, 5] 和 [11].

示例 2:

- 输入: [1, 2, 3, 5]
- 输出: false
- 解释: 数组不能分割成两个元素和相等的子集.

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0; // 定义变量sum，用于存储数组nums的元素之和
        for (int num : nums) {
            sum += num; // 将数组nums的元素累加到sum中
        }
        if (sum % 2 != 0) { // 如果sum为奇数，则无法分割成两个相等的子集，返回false
            return false;
        }
        int target = sum / 2; // 计算目标值target，即每个子集的和
        int dp[] = new int[target + 1]; // 创建一个长度为target+1的数组dp，用于存储状态转移的结果
        for (int num : nums) { // 遍历数组nums的元素
            for (int i = target; i >= num; i--) { // 从target开始递减遍历
                dp[i] = Math.max(dp[i], dp[i - num] + num); // 更新dp数组的值，表示当前和为i的子集的最大和
            }
        }
        return dp[target] == target; // 如果dp[target]等于target，则说明存在一个子集的和为target，返回true；否则返回false
    }
}
```

## 300.最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：

- 输入：nums = [10,9,2,5,3,7,101,18]
- 输出：4
- 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。



**dp[i]表示以nums[i]结尾的最长递增子序列的长度**

为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在 做 递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。

1. 状态转移方程

位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。

所以：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);

**注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值**。

1. dp[i]的初始化

每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.

1. 确定遍历顺序

dp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。

j其实就是遍历0到i-1，那么是从前到后，还是从后到前遍历都无所谓，只要吧 0 到 i-1 的元素都遍历了就行了。 所以默认习惯 从前向后遍历。

```java
/**
 * 最长递增子序列问题
 */
class Solution {
    /**
     * 计算最长递增子序列的长度
     * @param nums 给定的整数数组
     * @return 最长递增子序列的长度
     */
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n]; // dp数组用于记录以当前元素结尾的最长递增子序列的长度
        Arrays.fill(dp, 1); // 初始化dp数组为1，因为每个元素本身就是一个递增子序列
        int res = 1; // 记录最长递增子序列的长度
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) { // 如果当前元素大于前面的元素，则可以将当前元素加入到以前面元素结尾的递增子序列中
                    dp[i] = Math.max(dp[i], dp[j] + 1); // 更新以当前元素结尾的最长递增子序列的长度
                }
            }
            res = Math.max(res, dp[i]); // 更新最长递增子序列的长度
        }
        return res;
    }
}
```

## 198.打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

- 示例 1：
- 输入：[1,2,3,1]
- 输出：4

解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。  偷窃到的最高金额 = 1 + 3 = 4 。



1.确定dp数组以及下标的含义

**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。

2.确定递推公式

决定dp[i]的因素就是第i房间偷还是不偷。

如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。

如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（**注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点**）

然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);

3.dp数组如何初始化

从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]

从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);

```java
class Solution {
    public int rob(int[] nums) {
        // 如果数组为空或者长度为0，则返回0
        if (nums == null || nums.length == 0) return 0;
        // 如果数组长度为1，则直接返回数组中的唯一元素
        if (nums.length == 1) return nums[0];

        // 创建一个与原数组长度相同的数组，用于存储每个位置的最大金额
        int[] dp = new int[nums.length];
        // 初始化dp数组的前两个元素
        dp[0] = nums[0];
        dp[1] = Math.max(dp[0], nums[1]);
        // 从第三个位置开始遍历原数组
        for (int i = 2; i < nums.length; i++) {
            // 当前位置的最大金额等于前一个位置的最大金额和前两个位置的最大金额加上当前位置的金额的较大值
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        // 返回dp数组的最后一个元素，即为最终的最大金额
        return dp[nums.length - 1];
    }
}
```

## 253.会议室II

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020091411253313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MDUxNDEz,size_16,color_FFFFFF,t_70#pic_center)

先对所有的会议时间按开始时间从小到大排序。

  接着定义一个小顶堆作为会议室，每个节点的值是会议的结束时间。

  小顶堆在我的代码中是用优先队列。无论加入多少个队列，小顶堆的堆顶就是当前使用会议室中最早的结束时间，并且小顶堆的元素个数即会议室当前占用的间数。

  最早开始的会议的结束时间 add 到小顶堆中。

  接着对 [1, size-1] 个会议依次进行以下操作：

  1、对比当前会议的开始时间和小顶堆的堆顶元素值，若小于，说明当前所有会议室正在进行的会议中，最早结束的都还没结束，只能新建会议室了；

  2、若当前会议的开始时间大于小顶堆的堆顶元素值，说明会议室正在进行的会议中，最早结束的会议已经结束，可以把它从小顶堆删除，自己进入小顶堆（重复利用会议室）。

  等最后一个会议时间进入小顶堆，此时的小顶堆元素个数即至少需要的会议室数量。

```java
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if (intervals.length == 0) return 0;

        // 最小堆
        PriorityQueue<Integer> allocator = new PriorityQueue<Integer>(intervals.length, (a, b) -> a - b);

        // 对时间表按照开始时间从小到大排序
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        // 添加第一场会议的结束时间
        allocator.add(intervals[0][1]);

        // 遍历除第一场之外的所有会议
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] >= allocator.peek()) {
                // 如果当前会议的开始时间大于前面已经开始的会议中最晚结束的时间
                // 说明有会议室空闲出来了，可以直接重复利用
                // 当前时间已经是 intervals[i][0]，因此把已经结束的会议删除
                allocator.poll();
            }
            // 把当前会议的结束时间加入最小堆中
            allocator.add(intervals[i][1]);
        }

        // 当所有会议遍历完毕，还在最小堆里面的，说明会议还没结束，此时的数量就是会议室的最少数量
        return allocator.size();
    }
}

```

## 240.搜索二维矩阵II

编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

**示例 1：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" alt="img" style="zoom:50%;" />

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

```java
class Solution {
    // 定义一个方法，用于在二维矩阵中搜索目标值
    public boolean searchMatrix(int[][] matrix, int target) {
        // 初始化起始点坐标为矩阵右上角
        int x = 0;
        int y = matrix[0].length - 1;

        // 在矩阵范围内进行搜索
        while (x < matrix.length && y >= 0) {
            // 如果当前元素小于目标值，向下移动
            if (matrix[x][y] < target) {
                x++;
            } 
            // 如果当前元素大于目标值，向左移动
            else if (matrix[x][y] > target) {
                y--;
            } 
            // 如果当前元素等于目标值，返回true
            else {
                return true;
            }
        }
        // 若循环结束仍未找到目标值，返回false
        return false;
    }
}
```

## 494.目标和

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

示例：

- 输入：nums: [1, 1, 1, 1, 1], S: 3
- 输出：5

解释：

- -1+1+1+1+1 = 3
- +1-1+1+1+1 = 3
- +1+1-1+1+1 = 3
- +1+1+1-1+1 = 3
- +1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。

假设加法的总和为x，那么减法对应的总和就是sum - x。

所以我们要求的是 x - (sum - x) = target

x = (target + sum) / 2

**此时问题就转化为，装满容量为x的背包，有几种方法**。

这里的x，就是bagSize，也就是我们后面要求的背包容量。



只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。

例如：dp[j]，j 为5，

- 已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。
- 已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。
- 已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包
- 已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包
- 已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包

那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0; // 定义变量sum，用于存储数组nums中所有元素的和
        for (int num : nums) {
            sum += num; // 将数组nums中的每个元素累加到sum中
        }
        if (target < 0 && sum < -target) // 如果目标值target小于0且sum小于-target，则返回0
            return 0;
        int left = (target + sum) / 2; // 计算目标值target和sum的和的一半，存储在变量left中
        if ((target + sum) % 2 != 0) // 如果目标值target和sum的和为奇数，则返回0
            return 0;
        int[] dp = new int[left + 1]; // 创建一个长度为left+1的数组dp，用于存储计算结果
        dp[0] = 1; // 将dp数组的第一个元素设置为1
        for (int num : nums) {
            for (int i = left; i >= num; i--) {
                dp[i] += dp[i - num]; // 根据动态规划的思想，更新dp数组的值，dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法
            }
        }
        return dp[left]; // 返回dp数组的最后一个元素，即为结果
    }
}
```

## 221.最大正方形

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" alt="img" style="zoom:50%;" />

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
```

```java
class Solution {
    // 计算最大正方形的面积
    public int maximalSquare(char[][] matrix) {
        // 获取矩阵的行数和列数
        int xSize = matrix.length;
        int ySize = matrix[0].length;
        // 初始化返回值为-1
        int ret = -1;
        // 创建二维数组dp用于存储以当前点为右下角的最大正方形的边长
        int[][] dp = new int[xSize][ySize];

        // 遍历矩阵中的每个点
        for (int i = 0; i < xSize; i++) {
            for (int j = 0; j < ySize; j++) {
                // 将字符转换为数字存入dp数组
                dp[i][j] = matrix[i][j] - '0';
                // 如果当前点不在第一行和第一列且当前点为1
                if (i > 0 && j > 0 && dp[i][j] != 0) {
                    // 非边界情况，根据左、上、左上三个位置的最小值加1得到当前位置的最大正方形边长
                    dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i - 1][j - 1], dp[i][j - 1])) + 1;
                }
                // 更新最大正方形的边长
                ret = Math.max(dp[i][j], ret);
            }
        }

        // 返回最大正方形的面积
        return ret * ret;
    }
}
```

## 56.合并区间

给出一个区间的集合，请合并所有重叠的区间。

示例 1:

- 输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
- 输出: [[1,6],[8,10],[15,18]]
- 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2:

- 输入: intervals = [[1,4],[4,5]]
- 输出: [[1,5]]
- 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 对二维数组按照每个子数组的第一个元素进行升序排序
        Arrays.sort(intervals,(a,b)->Integer.compare(a[0],b[0]));
        // 创建一个动态数组用于存储合并后的区间
        List<int[]> list = new ArrayList<>();
        // 将第一个区间加入到动态数组中
        list.add(intervals[0]);
        // 遍历剩余的区间
        for (int i = 1; i < intervals.length; i++) {
            // 如果当前区间的起始位置小于等于动态数组中最后一个区间的结束位置
            if (intervals[i][0] <= list.get(list.size() - 1)[1]){
                // 更新动态数组中最后一个区间的结束位置为当前区间的结束位置和动态数组中最后一个区间的结束位置的较大值
                list.get(list.size() - 1)[1] = Math.max(intervals[i][1],list.get(list.size() - 1)[1]);
            }else {
                // 否则，将当前区间加入到动态数组中
                list.add(intervals[i]);
            }
        }
        // 将动态数组转换为二维数组并返回
        return list.toArray(new int[0][]);
    }
}
```

## 79.单词搜索

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例 1：**

<img src="C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240313095323325.png" alt="image-20240313095323325" style="zoom:50%;" />

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

```java
class Solution {
    // 判断在二维字符数组board中是否存在单词word
    public boolean exist(char[][] board, String word) {
        // 遍历二维数组board的每个位置
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                // 调用深度优先搜索dfs方法查找单词
                if (dfs(board, word, i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    // 深度优先搜索方法，用于在二维字符数组board中查找单词word
    private boolean dfs(char[][] board, String word, int i, int j, int k) {
        // 如果单词word已经全部匹配完成，则返回true
        if (k == word.length()) {
            return true;
        }
        // 边界条件判断，包括数组越界和字符不匹配
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(k)) {
            return false;
        }
        // 临时保存当前位置的字符，并将当前位置标记为已访问
        char tmp = board[i][j];
        board[i][j] = '*';
        // 递归搜索上下左右四个方向
        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i, j - 1, k + 1);
        // 恢复当前位置的字符，并返回搜索结果
        board[i][j] = tmp;
        return res;
    }
}
```

## 560.和为k的子数组

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

```java
// 定义一个Solution类
class Solution {
    // 定义一个方法，计算和为k的子数组个数
    public int subarraySum(int[] nums, int k) {
        // 获取数组长度
        int n = nums.length;
        // 初始化结果
        int ans = 0;
        // 遍历数组
        for (int i = 0; i < n; ++i) {
            // 初始化子数组和
            int sum = 0;
            // 遍历子数组
            for (int j = i; j < n; ++j) {
                // 计算子数组和
                sum += nums[j];
                // 如果子数组和等于k，结果加一
                if (sum == k) {
                    ans++;
                }
            }
        }
        // 返回结果
        return ans;
    }
}
```

## 322.零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

示例 1：

- 输入：coins = [1, 2, 5], amount = 11
- 输出：3
- 解释：11 = 5 + 5 + 1



本题求钱币最小个数，**那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数**。可以看作为求最小子集，而474.一和零是求最大子集，唯一不同是在递推公式上，本题递推公式为 dp[i] = Math.min(dp[i], dp[i - coin] + 1); 一和零的递推公式为dp[i] [j] = Math.max(dp[i] [j], dp[i - zero] [j - one] + 1); 基本上一样，只不过是max和min的区别。

所以本题并不强调集合是组合还是排列。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

```java
/**
 * 零钱兑换
 */
class Solution {
    /**
     * 计算兑换零钱的最少硬币数量
     * @param coins 零钱的面值数组
     * @param amount 需要兑换的金额
     * @return 最少硬币数量，如果无法兑换则返回-1
     */
    public int coinChange(int[] coins, int amount) {
        // 创建一个长度为amount+1的数组，用于存储兑换不同金额所需的最少硬币数量
        int [] dp = new int[amount + 1];
        // 考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。所以下标非0的元			素都是应该是最大值。
        Arrays.fill(dp, amount + 1);
        // 兑换0元不需要硬币
        dp[0] = 0;
        // 遍历每种硬币的面值
        for (int coin : coins) {
            // 从硬币的面值开始遍历到目标金额
            for (int i = coin; i <= amount; i++) {
                // 计算兑换金额i所需的最少硬币数量
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
        // 如果目标金额无法兑换，则返回-1，否则返回最少硬币数量
        return dp[amount] == amount + 1 ? -1 : dp[amount];
    }
}
```

## 34.在排序数组中找到元素的第一个位置和最后一个位置

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

```java
/**
 * 在排序数组中查找元素的第一个和最后一个位置
 */
class Solution {
    /**
     * 查找排序数组中目标元素的第一个和最后一个位置
     * @param nums 给定的排序数组
     * @param target 目标元素
     * @return 包含第一个和最后一个位置的数组，若未找到则返回{-1, -1}
     */
    public int[] searchRange(int[] nums, int target) {
        // 初始化结果数组
        int[] ans = new int[]{-1, -1};
        // 若数组为空，则直接返回结果数组
        if (nums.length == 0) {
            return ans;
        }
        // 二分查找目标元素的第一个位置
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] >= target) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        // 若未找到目标元素，则返回结果数组
        if (nums[left] != target) {
            return ans;
        }
        // 更新第一个位置
        ans[0] = left;
        right = nums.length - 1;
        // 二分查找目标元素的最后一个位置
        while (left < right) {
            int mid = (left + right + 1) / 2;
            if (nums[mid] <= target) {
                left = mid;
            } else {
                right = mid - 1;
            }
        }
        // 更新最后一个位置
        ans[1] = right;
        return ans;
    }
}
```

## 55.跳跃游戏

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

```java
class Solution {
    // 定义一个方法，判断是否可以跳跃到最后一个位置
    public boolean canJump(int[] nums) {
        // 初始化覆盖范围为0
        int cover = 0;
        // 遍历数组
        for (int i = 0; i <= cover; i++) {
            // 更新覆盖范围
            cover = Math.max(cover, i + nums[i]);
            // 如果覆盖范围已经覆盖到最后一个位置，则返回true
            if (cover >= nums.length - 1) {
                return true;
            }
        }
        // 如果无法到达最后一个位置，则返回false
        return false;
    }
}
```

## 19.删除链表的倒数第N个节点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img" style="zoom: 67%;" />

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

```java
class Solution {
    // 定义一个方法，用于删除链表的倒数第 N 个结点
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 创建一个虚拟头结点，并将其指向头结点
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        // 初始化快慢指针，均指向虚拟头结点
        ListNode fast = dummyHead;
        ListNode slow = dummyHead;
        // 快指针先移动 n 步
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }
        // 快慢指针同时移动，直到快指针到达链表末尾
        while(fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        // 删除倒数第 N 个结点
        slow.next = slow.next.next;
        // 返回虚拟头结点的下一个结点，即删除倒数第 N 个结点后的链表头
        return dummyHead.next;
    }
}
```

## 33.搜索旋转排序数组

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1
```

```java
public class Solution {
    // 二分查找算法在旋转排序数组中查找目标值的方法
    public int search(int[] nums, int target) {
        int left = 0; // 左指针，指向数组起始位置
        int right = nums.length - 1; // 右指针，指向数组末尾位置
        while (left < right) { // 当左指针小于右指针时循环执行
            int mid = (left + right) / 2; // 计算中间位置
            if (nums[mid] == target) { // 如果中间值等于目标值，直接返回中间位置
                return mid;
            }
            if (nums[left] > nums[mid]) { // 如果左值大于中间值
                if (nums[mid] < target && nums[left] > target) { // 目标值在右半部分
                    left = mid + 1; // 更新左指针为中间位置的下一个位置
                } else {
                    right = mid - 1; // 更新右指针为中间位置
                }
            } else { // 如果左值小于等于中间值
                if (nums[mid] >= target && nums[left] <= target) { // 目标值在左半部分
                    right = mid - 1; // 更新右指针为中间位置
                } else {
                    left = mid + 1; // 更新左指针为中间位置的下一个位置
                }
            }
        }
        return nums[left] == target ? left : -1; // 返回目标值的索引，若不存在则返回-1
    }
}
```

## 152.乘积最大子数组

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

**示例 1:**

```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

```java
class Solution {
    // 计算乘积最大子数组
    public int maxProduct(int[] nums) {
        // 初始化最大值max、当前最大乘积imax、当前最小乘积imin
        int max = nums[0], imax = nums[0], imin = nums[0];
        // 循环遍历数组
        for (int i = 1; i < nums.length; i++) {
            // 如果当前元素为负数，则交换当前最大乘积和最小乘积
            if (nums[i] < 0) {
                int tmp = imax;
                imax = imin;
                imin = tmp;
            }
            // 更新当前最大乘积和最小乘积
            imax = Math.max(nums[i], imax * nums[i]);
            imin = Math.min(nums[i], imin * nums[i]);
            // 更新最大值max
            max = Math.max(max, imax);
        }
        // 返回最大值max
        return max;
    }
}
```

## 2.两数相加

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img" style="zoom:67%;" />

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

```java
class Solution {
    // 两数相加的方法，传入两个链表l1和l2，返回相加后的结果
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 调用私有方法add，初始进位为0
        return add(l1, l2, 0);
    }

    // 辅助方法add，实现链表节点相加的逻辑
    private ListNode add(ListNode l1, ListNode l2, int carry) {
        // 当两个链表节点都为空且进位为0时，返回空
        if (l1 == null && l2 == null && carry == 0) {
            return null;
        }
        int val = carry; // 初始化val为进位
        if (l1 != null) {
            val += l1.val; // 将l1节点的值加到val上
            l1 = l1.next; // 移动l1指针到下一个节点
        }
        if (l2 != null) {
            val += l2.val; // 将l2节点的值加到val上
            l2 = l2.next; // 移动l2指针到下一个节点
        }
        ListNode node = new ListNode(val % 10); // 创建新节点，值为val对10取余
        node.next = add(l1, l2, val / 10); // 递归调用add方法，传入新的l1、l2和进位值
        return node; // 返回当前节点
    }
}
```

## 3.无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
```

```java
class Solution {
    // 计算无重复字符的最长子串长度
    public int lengthOfLongestSubstring(String s) {
        int n = s.length(); // 字符串长度
        Set<Character> set = new HashSet<Character>(); // 用于存储字符的集合
        int ans = 0, i = 0, j = 0; // 初始化结果、左指针和右指针

        // 遍历字符串
        while (i < n && j < n) {
            // 如果集合中不包含当前字符，则加入集合并更新结果
            if (!set.contains(s.charAt(j))){
                set.add(s.charAt(j++));
                ans = Math.max(ans, j - i); // 更新最长子串长度
            }
            // 如果集合中包含当前字符，则移除左指针指向的字符
            else {
                set.remove(s.charAt(i++));
            }
        }
        return ans; // 返回最长子串长度
    }
}
```

## 31.下一个排列

整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

```java
class Solution {
    // 下一个排列
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        // 从倒数第二个数开始向前遍历，找到第一个不满足递减顺序的数
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        // 如果找到了这样的数
        if (i >= 0) {
            int j = nums.length - 1;
            // 从末尾向前找到第一个大于nums[i]的数
            while (nums[j] <= nums[i]) {
                j--;
            }
            // 交换这两个数
            swap(nums, i, j);
        }
        // 反转从i+1开始的部分，使其变为递增顺序
        reverse(nums, i + 1);
    }

    // 反转数组
    private void reverse(int[] nums, int start) {
        int i = start, j = nums.length - 1;
        // 从start到末尾依次交换数字
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }

    // 交换数组中的两个元素
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

## 581.最短连续无序子数组

给你一个整数数组 `nums` ，你需要找出一个 **连续子数组** ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

请你找出符合题意的 **最短** 子数组，并输出它的长度。

**示例 1：**

```
输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
```

**示例 2：**

```
输入：nums = [1,2,3,4]
输出：0
```

**示例 3：**

```
输入：nums = [1]
输出：0
```

```java
public class Solution {
    // 寻找最短无序连续子数组的方法
    public int findUnsortedSubarray(int[] nums) {
        // 复制原始数组
        int[] temp = Arrays.copyOf(nums, nums.length);
        // 对复制的数组进行排序
        Arrays.sort(temp);
        // 初始化左右指针
        int leftPos = 0;
        int rightPos = nums.length - 1;

        // 循环直到找到需要调整的子数组
        while (leftPos <= rightPos && (temp[leftPos] == nums[leftPos] || temp[rightPos] == nums[rightPos])) {
            // 移动左指针直到找到需要调整的位置
            if (temp[leftPos] == nums[leftPos]) {
                leftPos++;
            }
            // 移动右指针直到找到需要调整的位置
            if (temp[rightPos] == nums[rightPos]) {
                rightPos--;
            }
        }

        // 返回需要调整的子数组的长度
        return rightPos - leftPos + 1 >= 0 ? rightPos - leftPos + 1 : 0;
    }
}
```

## 98.验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。

- 节点的右子树只包含大于当前节点的数。

- 所有左子树和右子树自身必须也是二叉搜索树。

  <img src="C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240104113914046.png" alt="image-20240104113914046" style="zoom: 67%;" />

```java
// 定义一个Solution类
class Solution {
    // 声明一个TreeNode类型的变量max，用于记录当前节点的最大值
    TreeNode max;
    
    // 定义一个方法isValidBST，用于验证给定的二叉树是否为二叉搜索树
    public boolean isValidBST(TreeNode root) {
        // 若当前节点为空，返回true
        if(root == null)
            return true;
        
        // 递归验证左子树是否为二叉搜索树
        boolean left = isValidBST(root.left);
        // 若左子树不是二叉搜索树，直接返回false
        if(left == false)
            return false;
        
        // 若max不为空且当前节点的值小于等于max的值，返回false
        if(max != null && root.val <= max.val)
            return false;
        
        // 更新max为当前节点
        max = root;
        
        // 递归验证右子树是否为二叉搜索树
        boolean right = isValidBST(root.right);
        
        // 返回右子树是否为二叉搜索树的结果
        return right;
    }
}
```

## 5.最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

```java
public class Solution {
    // 计算最长回文子串
    public String longestPalindrome(String s) {
        // 创建一个二维数组dp，用于记录子串是否为回文串
        boolean[][] dp = new boolean[s.length()][s.length()];
        // 初始化返回结果字符串
        String ret = "";
        // 遍历字符串s，end表示子串的结束位置
        for (int end = 0; end < s.length(); ++end) {
            // start表示子串的起始位置，从end向前遍历
            for (int start = end; start >= 0; --start) {
                // 判断当前子串是否为回文串
                if (s.charAt(end) == s.charAt(start) && (end <= start + 1 || dp[start + 1][end - 1])) {
                    // 更新dp数组
                    dp[start][end] = true;
                    // 更新最长回文子串
                    if (ret.isEmpty() || end - start + 1 > ret.length()) {
                        ret = s.substring(start, end + 1);
                    }
                }
            }
        }
        // 返回最长回文子串
        return ret;
    }
}
```

## 15.三数之和

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

```java
class Solution {
    // 定义一个Solution类
    public List<List<Integer>> threeSum(int[] nums) {
        // 定义一个threeSum方法，参数为整型数组nums，返回一个整型数组列表的列表
        List<List<Integer>> res = new ArrayList<>();
        // 创建一个整型数组列表的列表res
        Arrays.sort(nums);
        // 对nums数组进行排序
        for (int i = 0; i < nums.length - 2; i++){
            // 遍历数组nums，注意遍历范围是nums.length - 2
            if (i > 0 && nums[i] == nums[i - 1])
                // 如果i大于0且当前元素与前一个元素相同，则跳过当前循环
                continue;
            int left = i + 1;
            // 初始化左指针为i+1
            int right = nums.length - 1;
            // 初始化右指针为数组最后一个元素的下标
            while (left < right){
                // 当左指针小于右指针时循环
                if(nums[i] + nums[left] + nums[right] == 0){
                    // 如果三数之和为0
                    List<Integer> list = new ArrayList<>();
                    // 创建一个整型列表list
                    list.add(nums[i]);
                    list.add(nums[left]);
                    list.add(nums[right]);
                    // 将三个数加入list中
                    res.add(list);
                    // 将list加入res中
                    left++;
                    right--;
                    // 左指针右移，右指针左移
                    while(left < right && nums[left] == nums[left - 1])
                        left++;
                    // 跳过重复元素
                    while(left < right && nums[right] == nums[right + 1])
                        right--;
                    // 跳过重复元素
                } else if (nums[i] + nums[left] + nums[right] > 0) {
                    // 如果三数之和大于0
                    right--;
                    // 右指针左移
                } else
                    left++;
                    // 否则左指针右移
            }
        }
        return res;
        // 返回结果res
    }
}
```

## 312.戳气球

有 `n` 个气球，编号为`0` 到 `n - 1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。

现在要求你戳破所有的气球。戳破第 `i` 个气球，你可以获得 `nums[i - 1] * nums[i] * nums[i + 1]` 枚硬币。 这里的 `i - 1` 和 `i + 1` 代表和 `i` 相邻的两个气球的序号。如果 `i - 1`或 `i + 1` 超出了数组的边界，那么就当它是一个数字为 `1` 的气球。

求所能获得硬币的最大数量。

**示例 1：**

```
输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
```

**示例 2：**

```
输入：nums = [1,5]
输出：10
```

```java
public class Solution {
    // 计算戳气球的最大硬币数
    public int maxCoins(int[] nums) {
        int numsSize = nums.length;
        int[] tempNums = new int[numsSize + 2]; // 创建一个长度比原数组多2的临时数组
        int[][] dp = new int[numsSize + 2][numsSize + 2]; // 创建一个二维数组用于存储计算结果，dp[i][j]表示戳破区间(i, j)内所有气球（开区间，不包括i和j）能获得的最大硬币数。

        // 将原数组复制到临时数组中
        for (int i = 0; i < numsSize; i++) {
            tempNums[i + 1] = nums[i];
        }
        tempNums[0] = tempNums[numsSize + 1] = 1; // 在临时数组的首尾添加1

        // 动态规划计算最大硬币数
        for (int i = numsSize - 1; i >= 0; i--) {
            for (int j = i + 2; j <= numsSize + 1; j++) {
                for (int k = i + 1; k < j; k++) {
                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + tempNums[i] * tempNums[k] * tempNums[j]);
                }
            }
        }

        return dp[0][numsSize + 1]; // 返回计算结果
    }
}
```

## 72.编辑距离

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符
- 示例 1：
- 输入：word1 = "horse", word2 = "ros"
- 输出：3
- 解释： horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e')
- 示例 2：
- 输入：word1 = "intention", word2 = "execution"
- 输出：5
- 解释： intention -> inention (删除 't') inention -> enention (将 'i' 替换为 'e') enention -> exention (将 'n' 替换为 'x') exention -> exection (将 'n' 替换为 'c') exection -> execution (插入 'u')



**1. 确定dp数组（dp table）以及下标的含义**

**dp[i] [j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i] [j]**。

有同学问了，为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？

为什么这么定义我在 [718. 最长重复子数组 (opens new window)](https://programmercarl.com/0718.最长重复子数组.html)中做了详细的讲解。

其实用i来表示也可以！ 用i-1就是为了方便后面dp数组初始化的。

**2. 确定递推公式**

在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：

```text
if (word1[i - 1] == word2[j - 1])
    不操作
if (word1[i - 1] != word2[j - 1])
    增
    删
    换
```

也就是如上4种情况。

```
if (word1[i - 1] == word2[j - 1])` 那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j] = dp[i - 1][j - 1];
```

此时可能有同学有点不明白，为啥要即`dp[i][j] = dp[i - 1][j - 1]`呢？

那么就在回顾上面讲过的`dp[i][j]`的定义，`word1[i - 1]` 与 `word2[j - 1]`相等了，那么就不用编辑了，以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串`word2`的最近编辑距离`dp[i - 1][j - 1]`就是 `dp[i][j]`了。

在下面的讲解中，如果哪里看不懂，就回想一下`dp[i][j]`的定义，就明白了。

**在整个动规的过程中，最为关键就是正确理解`dp[i][j]`的定义！**

`if (word1[i - 1] != word2[j - 1])`，此时就需要编辑了，如何编辑呢？

- 操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。

即 `dp[i][j] = dp[i - 1][j] + 1;`

- 操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。

即 `dp[i][j] = dp[i][j - 1] + 1;`

这里有同学发现了，怎么都是删除元素，添加元素去哪了。

**word1添加一个元素，相当于word2删除一个元素**，例如 `word1 = "ad" ，word2 = "a"`，`word1`删除元素`'d'` 和 `word2`添加一个元素`'d'`，变成`word1="a", word2="ad"`， 最终的操作数是一样！ dp数组如下图所示意的：

```text
            a                         a     d
   +-----+-----+             +-----+-----+-----+
   |  0  |  1  |             |  0  |  1  |  2  |
   +-----+-----+   ===>      +-----+-----+-----+
 a |  1  |  0  |           a |  1  |  0  |  1  |
   +-----+-----+             +-----+-----+-----+
 d |  2  |  1  |
   +-----+-----+
```

操作三：替换元素，`word1`替换`word1[i - 1]`，使其与`word2[j - 1]`相同，此时不用增删加元素。

可以回顾一下，`if (word1[i - 1] == word2[j - 1])`的时候我们的操作 是 `dp[i][j] = dp[i - 1][j - 1]` 对吧。

那么只需要一次替换的操作，就可以让 word1[i - 1] 和 word2[j - 1] 相同。

所以 `dp[i][j] = dp[i - 1][j - 1] + 1;`

综上，当 `if (word1[i - 1] != word2[j - 1])` 时取最小的，即：`dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;`

递归公式代码如下：

**3. dp数组如何初始化**

再回顾一下dp[i][j]的定义：

**dp[i] [j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i] [j]**。

那么dp[i] [0] 和 dp[0] [j] 表示什么呢？

dp[i] [0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i] [0]。

那么dp[i] [0]就应该是i，对word1里的元素全部做删除操作，即：dp[i] [0] = i;

同理dp[0] [j] = j;

所以C++代码如下：

```cpp
for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
```

**4. 确定遍历顺序**

从如下四个递推公式：

- `dp[i][j] = dp[i - 1][j - 1]`
- `dp[i][j] = dp[i - 1][j - 1] + 1`
- `dp[i][j] = dp[i][j - 1] + 1`
- `dp[i][j] = dp[i - 1][j] + 1`

可以看出dp[i] [j]是依赖左方，上方和左上方元素的，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210114162113131.jpg" alt="72.编辑距离" style="zoom:50%;" />

```java
class Solution {
    public int minDistance(String word1, String word2) {
        // 创建一个二维数组dp，用于存储编辑距离
        int [][] dp = new int[word1.length() + 1][word2.length() + 1];
        
        // 初始化第一行，表示将word1的前i个字符转换为空字符串的编辑距离
        for (int i = 0; i <= word1.length(); i++) {
            dp[i][0] = i;
        }
        
        // 初始化第一列，表示将空字符串转换为word2的前j个字符的编辑距离
        for (int j = 0; j <= word2.length(); j++) {
            dp[0][j] = j;
        }
        
        // 计算word1和word2之间的编辑距离
        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                // 如果word1的第i个字符和word2的第j个字符相等，则编辑距离不变
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                // 否则，取替换、插入和删除操作中的最小编辑距离
                else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 1,
                            Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }
        
        // 返回word1和word2之间的最小编辑距离
        return dp[word1.length()][word2.length()];
    }
}
```

## 42.接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

示例 1：

![img](https://code-thinking-1253855093.cos.ap-guangzhou.myqcloud.com/pics/20210713205038.png)

- 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
- 输出：6
- 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

```java
class Solution {
    public int trap(int[] height) {
        int sum = 0; // 存储接雨水的总量
        int len = height.length; // 数组的长度
        Stack<Integer> stack = new Stack<>(); // 使用栈来存储数组的索引
        stack.push(0); // 将第一个索引入栈
        for (int i = 1; i < len; i++) { // 遍历数组
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) { // 当栈不为空且当前高度大于栈顶高度时
                int top = stack.pop(); // 弹出栈顶元素
                if (stack.isEmpty()) { // 如果栈为空，说明无法形成凹槽，结束循环
                    break;
                }
                int distance = i - stack.peek() - 1; // 计算两个柱子之间的距离
                int boundedHeight = Math.min(height[i], height[stack.peek()]) - height[top]; // 计算凹槽的高度
                sum += distance * boundedHeight; // 计算凹槽的面积并累加到总量中
            }
            stack.push(i); // 将当前索引入栈
        }                 
        return sum; // 返回接雨水的总量
    }
}
```

## 23.合并k个有序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

```java
public class Solution {
    // 合并 K 个升序链表的方法
    public ListNode mergeKLists(ListNode[] lists) {
        // 创建一个虚拟头结点
        ListNode head = new ListNode(0);
        // 创建一个优先队列，用于存储链表节点，并按节点值大小进行排序
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);

        // 将所有链表的头结点加入优先队列
        for (ListNode h : lists) {
            if (h != null) {
                pq.offer(h);
            }
        }

        // 创建指针 p 指向虚拟头结点
        ListNode p = head;
        // 循环直到优先队列为空
        while (!pq.isEmpty()) {
            // 取出优先队列中值最小的节点，连接到新链表上
            p.next = pq.poll();
            p = p.next;
            // 如果取出的节点有下一个节点，则将下一个节点加入优先队列
            if (p.next != null) {
                pq.offer(p.next);
            }
        }

        // 返回合并后的链表
        return head.next;
    }
}
```

## 297.二叉树的序列化与反序列化

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**提示:** 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://support.leetcode.cn/hc/kb/article/1567641/)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

```
输入：root = [1,2]
输出：[1,2]
```

```java
public class Codec {
    // 序列化二叉树
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node != null) {
                sb.append(node.val).append(","); // 将节点值添加到序列化字符串中
                queue.offer(node.left); // 将左子节点加入队列
                queue.offer(node.right); // 将右子节点加入队列
            } else {
                sb.append("_").append(","); // 如果节点为空，用"_"表示
            }
        }
        return sb.toString(); // 返回序列化后的字符串
    }
    // 反序列化二叉树
    public TreeNode deserialize(String data) {
        String[] nodes = data.split(",");
        Queue<TreeNode> queue = new LinkedList<>();
        TreeNode root = getNode(nodes[0]); // 获取根节点
        queue.offer(root);

        for (int i = 1; i < nodes.length; ) {
            TreeNode parent = queue.poll(); // 出队父节点
            parent.left = getNode(nodes[i++]); // 设置左子节点
            parent.right = getNode(nodes[i++]); // 设置右子节点

            if (parent.left != null) {
                queue.offer(parent.left); // 将左子节点加入队列
            }
            if (parent.right != null) {
                queue.offer(parent.right); // 将右子节点加入队列
            }
        }
        return root; // 返回反序列化后的根节点
    }
    // 根据节点值获取节点
    private TreeNode getNode(String val) {
        if (val.equals("_")) {
            return null; // 如果节点值为"_"，表示为空节点
        }
        return new TreeNode(Integer.parseInt(val)); // 创建新节点
    }
}
```

## 128.最长连续序列

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

```java
public class Solution {
    // 计算最长连续序列的方法
    public int longestConsecutive(int[] nums) {
        // 使用HashMap存储数字及其对应的连续序列长度
        HashMap<Integer, Integer> map = new HashMap<>();
        // 初始化最长连续序列长度为0
        int ans = 0;

        // 遍历nums数组中的每个元素
        for (int num : nums) {
            // 如果map中已经包含当前元素num，则跳过本次循环
            if (map.containsKey(num)) {
                continue;
            }
            // 将当前元素num作为key，其值为num左侧连续序列长度、右侧连续序列长度和当前元素num本身的总长度
            map.put(num, map.getOrDefault(num - 1, 0) + map.getOrDefault(num + 1, 0) + 1);

            // 如果map中包含当前元素num左侧的元素
            if (map.containsKey(num - 1)) {
                // 更新以num为结尾的连续序列的起始位置的值为当前num的值
                map.put(num - map.get(num - 1), map.get(num));
            }
            // 如果map中包含当前元素num右侧的元素
            if (map.containsKey(num + 1)) {
                // 更新以num为起始的连续序列的终止位置的值为当前num的值
                map.put(num + map.get(num + 1), map.get(num));
            }

            // 更新最长连续序列的长度
            ans = Math.max(map.get(num), ans);
        }

        // 返回最长连续序列长度
        return ans;
    }
}
```

## 85.最大矩形

给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。

**示例 1：**

<img src="C:\Users\16083\AppData\Roaming\Typora\typora-user-images\image-20240321103039279.png" alt="image-20240321103039279" style="zoom:50%;" />

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：6
解释：最大矩形如上图所示。
```

**示例 2：**

```
输入：matrix = [["0"]]
输出：0
```

**示例 3：**

```
输入：matrix = [["1"]]
输出：1
```

```java
public class Solution {
    // 计算给定字符矩阵的最大矩形面积
    public int maximalRectangle(char[][] matrix) {
        // 如果矩阵为空或者行数为0或者列数为0，则返回0
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }

        // 获取矩阵的行数和列数
        int rows = matrix.length;
        int cols = matrix[0].length;
        // 创建一个二维数组dp用于存储每个位置的宽度
        int[][] dp = new int[rows][cols];
        // 初始化最大矩形面积为0
        int maxArea = 0;

        // 遍历矩阵的每个位置
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // 如果当前位置为'1'
                if (matrix[i][j] == '1') {
                    // 计算当前位置的宽度，如果j大于0，则宽度为前一个位置的宽度加1，否则为1
                    dp[i][j] = (j > 0 ? dp[i][j - 1] : 0) + 1;
                    int minWidth = dp[i][j];
                    // 遍历当前位置到第0行的所有行，更新最小宽度和最大矩形面积
                    for (int k = i; k >= 0; k--) {
                        minWidth = Math.min(minWidth, dp[k][j]);
                        maxArea = Math.max(maxArea, minWidth * (i - k + 1));
                    }
                }
            }
        }
        // 返回最大矩形面积
        return maxArea;
    }
}
```

## 301.删除无效的括号

给你一个由若干括号和字母组成的字符串 `s` ，删除最小数量的无效括号，使得输入的字符串有效。

返回所有可能的结果。答案可以按 **任意顺序** 返回。

**示例 1：**

```
输入：s = "()())()"
输出：["(())()","()()()"]
```

**示例 2：**

```
输入：s = "(a)())()"
输出：["(a())()","(a)()()"]
```

**示例 3：**

```
输入：s = ")("
输出：[""]
```

```java
public class Solution {
    int minDel = Integer.MAX_VALUE; // 定义最小删除次数为整型最大值
    public List<String> removeInvalidParentheses(String s) { // 移除无效括号的方法
        HashSet<String> set = new HashSet<>(); // 用于存放去重的结果集
        List<String> ret = new ArrayList<>(); // 存放最终结果的列表
        String temp = ""; // 用于暂存当前处理的字符串
        backtracking(set, ret, s, temp, 0, 0, 0, 0); // 回溯处理

        return ret; // 返回结果列表
    }
    private void backtracking(HashSet<String> set, List<String> ret, String s, String temp, int left, int del, int pos, int size) { // 回溯方法
        if (pos == s.length()) { // 当遍历到字符串末尾时
            if (left == 0 && del <= minDel) { // 如果左括号数为0且删除次数小于等于最小删除次数
                if (del < minDel) { // 如果删除次数小于最小删除次数
                    ret.clear(); // 清空结果列表
                }
                if (!set.contains(temp)) { // 如果结果集中不包含当前字符串
                    ret.add(temp); // 将当前字符串加入结果列表
                }
                set.add(temp); // 将当前字符串加入结果集
                minDel = Math.min(minDel, del); // 更新最小删除次数
            }
            return; // 返回
        }
        if (s.charAt(pos) == ')') { // 当前字符为右括号时
            if (left == 0) { // 如果左括号数为0
                backtracking(set, ret, s, temp, left, del + 1, pos + 1, size); // 继续向后遍历
            } else { // 如果左括号数大于0
                if (left > 0) { // 如果左括号数大于0
                    temp += ')'; // 将右括号加入暂存字符串
                    backtracking(set, ret, s, temp, left - 1, del, pos + 1, size + 1); // 继续向后遍历
                }
                temp = temp.substring(0, size); // 截取暂存字符串
                backtracking(set, ret, s, temp, left, del + 1, pos + 1, size); // 继续向后遍历
            }
        } else if (s.charAt(pos) == '(') { // 当前字符为左括号时
            temp += '('; // 将左括号加入暂存字符串
            backtracking(set, ret, s, temp, left + 1, del, pos + 1, size + 1); // 继续向后遍历
            temp = temp.substring(0, size); // 截取暂存字符串
            backtracking(set, ret, s, temp, left, del + 1, pos + 1, size); // 继续向后遍历
        } else { // 当前字符为其他字符时
            backtracking(set, ret, s, temp + s.charAt(pos), left, del, pos + 1, size + 1); // 继续向后遍历
        }
    }
}
```

## 239.滑动窗口最大值

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

```java
class Solution {
    // 滑动窗口最大值方法
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 如果数组长度为1，直接返回数组
        if (nums.length == 1) {
            return nums;
        }
        // 初始化结果数组
        int[] res = new int[nums.length - k + 1];
        // 创建自定义队列对象
        MyQueue queue = new MyQueue();
        int index = 0;
        // 将前k个元素加入队列
        for (int i = 0; i < k; i++){
            queue.push(nums[i]);
        }
        // 将第一个窗口的最大值加入结果数组
        res[index++] = queue.peek();
        // 遍历剩余元素，更新窗口中的最大值
        for (int i = k; i < nums.length; i++){
            queue.pop(nums[i - k]);
            queue.push(nums[i]);
            res[index++] = queue.peek();
        }
        return res;
    }
}

class MyQueue{
    // 使用双端队列实现自定义队列
    Deque<Integer> q = new LinkedList<>();

    // 入队操作
    public void push(int val) {
        // 将小于当前值的元素从队尾移除
        while (!q.isEmpty() && q.peekLast() < val){
            q.pollLast();
        }
        // 将当前值加入队尾
        q.addLast(val);
    }

    // 出队操作
    public void pop(int val) {
        // 如果队首元素等于指定值，移除队首元素
        if (!q.isEmpty() && q.peek() == val){
            q.poll();
        }
    }

    // 获取队首元素
    public int peek() {
        return q.peek();
    }
}
```

## 124.二叉树的最大路径和

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**

<img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

```java
public class Solution {
    int ret = Integer.MIN_VALUE; // ret用于记录最大路径和

    public int maxPathSum(TreeNode root) {
        visit(root); // 调用visit方法计算最大路径和
        return ret; // 返回最大路径和
    }

    private int visit(TreeNode root) {
        if (root == null) {
            return 0; // 如果节点为空，返回0
        }
        int left = Math.max(0, visit(root.left)); // 计算左子树的最大路径和
        int right = Math.max(0, visit(root.right)); // 计算右子树的最大路径和
        ret = Math.max(ret, root.val + left + right); // 更新最大路径和
        return Math.max(0, root.val + Math.max(left, right)); // 返回当前节点作为路径中的一部分的最大值
    }
}
```

## 84.柱状图最大的图形

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210803220437.png" alt="img" style="zoom:50%;" />

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210803220506.png" alt="img" style="zoom:50%;" />

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> st = new Stack<Integer>(); // 使用栈来存储索引

        int [] newHeights = new int[heights.length + 2]; // 创建一个新的数组，用于处理边界情况
        newHeights[0] = 0; // 在新数组的开头和结尾添加0，用于处理边界情况
        newHeights[newHeights.length - 1] = 0;
        for (int index = 0; index < heights.length; index++){
            newHeights[index + 1] = heights[index]; // 将原始数组的值复制到新数组中
        }

        heights = newHeights; // 将新数组赋值给原始数组

        st.push(0); // 将新数组的第一个索引入栈
        int result = 0; // 初始化结果变量
        for (int i = 1; i < heights.length; i++) { // 遍历新数组
            if (heights[i] > heights[st.peek()]) { // 如果当前高度大于栈顶索引对应的高度
                st.push(i); // 将当前索引入栈
            } else if (heights[i] == heights[st.peek()]) { // 如果当前高度等于栈顶索引对应的高度
                st.pop(); // 弹出栈顶索引
                st.push(i); // 将当前索引入栈
            } else { // 如果当前高度小于栈顶索引对应的高度
                while (heights[i] < heights[st.peek()]) { // 循环直到当前高度大于栈顶索引对应的高度
                    int mid = st.peek(); // 获取栈顶索引
                    st.pop(); // 弹出栈顶索引
                    int left = st.peek(); // 获取新的栈顶索引
                    int right = i; // 当前索引
                    int w = right - left - 1; // 计算宽度
                    int h = heights[mid]; // 获取高度
                    result = Math.max(result, w * h); // 更新结果
                }
                st.push(i); // 将当前索引入栈
            }
        }
        return result; // 返回结果
    }
}
```

## 76.最小覆盖子串

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

```java
class Solution {
    // 计算最小覆盖子串
    public String minWindow(String s, String t) {
        // 使用Map记录字符出现次数
        Map<Character, Integer> countMap = new HashMap<>();
        // 初始化t中字符出现次数
        for (char c : t.toCharArray()) {
            countMap.put(c, countMap.getOrDefault(c, 0) + 1);
        }

        int start = 0, end = 0;
        int minLen = Integer.MAX_VALUE;
        int minLeft = 0;
        int counter = t.length();

        // 滑动窗口
        while (end < s.length()) {
            char endChar = s.charAt(end);
            // 判断当前字符是否在t中
            if (countMap.containsKey(endChar)) {
                if (countMap.get(endChar) > 0) {
                    counter--;
                }
                countMap.put(endChar, countMap.get(endChar) - 1);
            }
            end++;

            // 当窗口包含t中所有字符时
            while (counter == 0) {
                // 更新最小覆盖子串的长度和起始位置
                if (end - start < minLen) {
                    minLen = end - start;
                    minLeft = start;
                }
                char startChar = s.charAt(start);
                // 判断当前字符是否在t中
                if (countMap.containsKey(startChar)) {
                    countMap.put(startChar, countMap.get(startChar) + 1);
                    if (countMap.get(startChar) > 0) {
                        counter++;
                    }
                }
                start++;
            }
        }

        // 返回最小覆盖子串
        return minLen == Integer.MAX_VALUE ? "" : s.substring(minLeft, minLeft + minLen);
    }
}
```

## 4.寻找两个正序数组的中位数

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

```java
class Solution {
    // 寻找两个正序数组的中位数
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        // 创建一个新数组用于存放合并后的数组
        int[] merged = new int[nums1.length + nums2.length];
        // 初始化左指针、右指针和合并数组的索引
        int left = 0, right = 0, index = 0;

        // 合并两个数组直到其中一个数组遍历完
        while (left < nums1.length || right < nums2.length) {
            // 如果 nums1 数组已经遍历完，则将 nums2 数组的元素加入合并数组
            if (left == nums1.length) {
                merged[index++] = nums2[right++];
            } 
            // 如果 nums2 数组已经遍历完，则将 nums1 数组的元素加入合并数组
            else if (right == nums2.length) {
                merged[index++] = nums1[left++];
            } 
            // 比较当前两个数组指针位置的元素大小，将较小的元素加入合并数组
            else {
                if (nums1[left] <= nums2[right]) {
                    merged[index++] = nums1[left++];
                } else {
                    merged[index++] = nums2[right++];
                }
            }
        }

        // 计算合并数组的中位数并返回
        if (merged.length % 2 == 1) {
            return merged[merged.length / 2];
        } else {
            return (double) (merged[merged.length / 2] + merged[(merged.length - 1) / 2]) / 2;
        }
    }
}
```

## 32.最长有效括号

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```

```java
class Solution {
    // 计算最长有效括号的长度
    public int longestValidParentheses(String s) {
        // 使用栈来存储括号的索引
        Deque<Integer> stack = new LinkedList<>();
        // 初始时将-1入栈
        stack.push(-1);
        // 初始化最长有效括号长度为0
        int max = 0;
        // 遍历字符串s
        for (int i = 0; i < s.length(); i++) {
            // 如果是左括号'('，将当前索引入栈
            if (s.charAt(i) == '(') {
                stack.push(i);
            }
            // 如果是右括号')'
            else {
                // 弹出栈顶元素
                stack.pop();
                // 如果栈为空，将当前索引入栈
                if (stack.isEmpty()) {
                    stack.push(i);
                }
                // 更新最长有效括号长度
                max = Math.max(max, i - stack.peek());
            }
        }
        // 返回最长有效括号长度
        return max;
    }
}
```

## 10.正则表达式匹配

给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 **整个** 字符串 `s`的，而不是部分字符串。

**示例 1：**

```
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入：s = "aa", p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

**示例 3：**

```
输入：s = "ab", p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

```java
/**
 * 正则表达式匹配
 */
class Solution {
    /**
     * 判断字符串s是否匹配正则表达式p
     * @param s 给定字符串
     * @param p 给定正则表达式
     * @return 是否匹配
     */
    public boolean isMatch(String s, String p) {
        // 创建一个二维数组dp，用于动态规划
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        dp[0][0] = true;

        // 遍历字符串s和正则表达式p
        for (int i = 0; i <= s.length(); i++) {
            for (int j = 1; j <= p.length(); j++) {
                if (p.charAt(j - 1) == '*') {
                    // 处理'*'的情况
                    dp[i][j] = dp[i][j - 2];
                    if (!dp[i][j] && helper(s, p, i, j - 1))
                        dp[i][j] = i > 0 && dp[i - 1][j];
                } else {
                    // 处理普通字符和'.'的情况
                    if (helper(s, p, i, j))
                        dp[i][j] = i > 0 && dp[i - 1][j - 1];
                }
            }
        }

        return dp[s.length()][p.length()];
    }

    /**
     * 辅助方法，用于判断字符是否匹配
     * @param s 给定字符串
     * @param p 给定正则表达式
     * @param spos 字符串s的索引
     * @param ppos 正则表达式p的索引
     * @return 是否匹配
     */
    private boolean helper(String s, String p, int spos, int ppos) {
        if (spos == 0) return false;

        if (p.charAt(ppos - 1) == '.') return true;
        return s.charAt(spos - 1) == p.charAt(ppos - 1);
    }
}
```

